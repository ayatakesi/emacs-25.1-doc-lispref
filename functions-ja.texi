@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*- mode: texinfo; coding: utf-8 -*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2016 Free Software
@c Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Functions
@chapter 関数

  Lispプログラムは主にLisp関数で構成されます。このチャプターは、関数とは何か、引数を受け取る方法、関数を定義する方法を説明します。

@menu
* What Is a Function::       Lisp関数 
                               vs. プリミティブ。専門用語。
* Lambda Expressions::       関数がLispオブジェクトとして表現される方法。
* Function Names::           シンボルは関数を名づける役割を果たすことができる。
* Defining Functions::       関数定義のためのLisp式。
* Calling Functions::        既存の関数を使う方法。
* Mapping Functions::        リストの各要素などに関数を適用する。
* Anonymous Functions::      ラムダ式、それは無名の関数。
* Generic Functions::        Polymorphism, Emacs-style.
* Function Cells::           シンボルの関数定義へのアクセスとセット。
* Closures::                 レキシカル環境に囲まれた関数。
* Advising Functions::       関数の定義への追加。
* Obsolete Functions::       関数を陳腐と宣言する。
* Inline Functions::         コンパイラーによりインライン展開される関数。
* Declare Form::             関数についての補足的な情報の追加。
* Declaring Functions::      関数が定義されていることをコンパイラーに知らせる。
* Function Safety::          呼び出しても安全な関数なのか判断する。
* Related Topics::           関数が動作する方法において特別な意味をもつ、特定のLispプリミティブのクロスリファレンス。
@end menu

@node What Is a Function
@section 関数とは?

@cindex return value
@cindex value of function
@cindex argument
  一般的な意味では、関数とは@dfn{引数(arguments)}と呼ばれる与えられた入力値の計算を担うルールです。計算の結果は、その関数の@dfn{値(value)}、または@dfn{return値(return
value)}と呼ばれます。計算は、変数の値やデータ構造の内容を変更する等の副作用をもつこともできます。

  ほとんどのコンピューター言語では、関数はそれぞれ名前をもちます。しかしLispでは、厳密な意味において、関数は名前をもちません。関数はオブジェクトであり、関数の名前の役割を果たすシンボルに関連づけることができますが(たとえば@code{car})、それは@emph{オプション}です。@ref{Function
Names}を参照してください。関数が名前を与えられたとき、通常はそのシンボルを``関数''として参照します(たとえば、関数@code{car}のように参照します)。このマニュアルでは、関数名と関数オブジェクト自身との間の区別は、通常は重要ではありませんが、それが意味をもつような場合は注記します。

  @dfn{スペシャルフォーム(special
form)}、@dfn{マクロ(macro)}と呼ばれる、関数likeなオブジェクトがいくつかあり、それらも引数を受け受け、計算を担います。しかし以下で説明するように、Emacs
Lispではこれらは関数とは考えられません。

  以下は関数および関数likeなオブジェクトにたいする、重要な条件です:

@table @dfn
@item lambda expression
Lispで記述された関数(厳密には関数オブジェクト)です。これらについては、以降のセクションで説明します。
@ifnottex
@ref{Lambda Expressions}を参照してください。
@end ifnottex

@item primitive
@cindex primitive
@cindex subr
@cindex built-in function
Lispから呼び出すことができますが、実際にはCで記述されています。プリミティブは、@dfn{ビルトイン関数(built-in
functions)}や、@dfn{サブルーチン(subr)}といった呼ばれかたもします。それらの例には関数likeな@code{car}や@code{append}が含まれます。加えて、すべてのスペシャルフォーム(以下参照)もプリミティブと考えられます。

関数はLispの基礎となる部分(たとえば@code{car})であり、オペレーティングシステムのサービスにたいして値レベルのインターフェースを与え、高速に実行される必要があるため、通常はプリミティブとして実装されています。Lispで定義された関数とは異なり、プリミティブの修正や追加には、Cソースの変更とEmacsのリコンパイルが必要です。@ref{Writing
Emacs Primitives}を参照してください。

@item special form
プリミティブは関数と似ていますが、すべての引数が通常の方法で評価はされません。いくつかの引数だけが評価されるかもしれず、通常ではない順序で、複数回評価されるかもしれません。プリミティブの例には、@code{if}、@code{and}、@code{while}が含まれます。@ref{Special
Forms}を参照してください。

@item macro
@cindex macro
あるLisp式を、オリジナルの式のかわりに評価される別の式に変換する、関数とは別のLispで定義された構造です。マクロは、スペシャルフォームが行う一連のことを、Lispプログラマーが行うのを可能にします。@ref{Macros}を参照してください。

@item command
@cindex command
@code{command-execute}プリミティブを通じて呼び出すことができるオブジェクトで、通常はそのコマンドに@dfn{バインド}されたキーシーケンスを、ユーザーがタイプすることにより呼び出されます。@ref{Interactive
Call}を参照してください。コマンドは通常、関数です。その関数がLispで記述されている場合は、関数の定義内の@code{interactive}フォームによりコマンドとなります(@ref{Defining
Commands}を参照してください)。関数であるコマンドは、他の関数と同様、Lisp式から呼び出すこともできます。

キーボードマクロ(文字列およびベクター)は関数ではありませんが、これらもコマンドです。@ref{Keyboard
Macros}を参照してください。シンボルの関数セルにコマンドが含まれている場合、わたしたちはそのシンボルをコマンドと言います(@ref{Symbol
Components}を参照してください)。そのような@dfn{名前つきコマンド(named
command)}は、@kbd{M-x}で呼び出すことができます。

@item closure
A function object that is much like a lambda expression, except that it also
encloses an environment of lexical variable bindings.  @xref{Closures}.

@item byte-code function
バイトコンパイラーによりコンパイルされた関数です。@ref{Byte-Code Type}を参照してください。

@item autoload object
@cindex autoload object
実際の関数のプレースホルダーです。autoloadオブジェクトが呼び出された場合、Emacsは実際の関数の定義を含むファイルをロードした後、実際の関数を呼び出します。@ref{Autoload}を参照してください。
@end table

  関数@code{functionp}を使用して、あるオブジェクトが関数かどうかテストできます:

@defun functionp object
この関数は@var{object}が任意の種類の関数(たとえば@code{funcall}に渡すことができる)の場合は、@code{t}をreturnします。@code{functionp}は関数を名づけるシンボルにたいしては@code{t}、スペシャルフォームにたいしては@code{nil}をreturnすることに注意してください。
@end defun

@noindent
@code{functionp}とは異なり、以下の3つの関数は、シンボルをそれの関数定義としては扱い@emph{ません}。

@defun subrp object
この関数は、@var{object}がビルトイン関数(たとえばLispプリミティブ)の場合は、@code{t}をreturnします。

@example
@group
(subrp 'message)            ; @r{@code{message}はシンボルであり、}
     @result{} nil                 ;   @r{subrオブジェクトではない。}
@end group
@group
(subrp (symbol-function 'message))
     @result{} t
@end group
@end example
@end defun

@defun byte-code-function-p object
この関数は、@var{object}がバイトコード関数の場合は、@code{t}をreturnします。たとえば:

@example
@group
(byte-code-function-p (symbol-function 'next-line))
     @result{} t
@end group
@end example
@end defun

@defun subr-arity subr
この関数はプリミティブ@var{subr}の引数リストについての情報を提供します。retrun値は、@code{(@var{min}
.
@var{max})}というペアーです。@var{min}は引数の最小数です。@var{max}は最大数、または引数@code{&rest}を伴う関数にたいしてはシンボル@code{many}、@var{subr}がスペシャルフォームの場合はシンボル@code{unevalled}です。
@end defun

@node Lambda Expressions
@section ラムダ式
@cindex lambda expression

  ラムダ式(lambda expression)は、Lispで記述された関数オブジェクトです。以下は例です:

@example
(lambda (x)
  "Xの双曲線コサインをreturnする。"
  (* 0.5 (+ (exp x) (exp (- x)))))
@end example

@noindent
Emacs Lispでは、このようなリストは、関数オブジェクトに評価される、有効な式です。

  ラムダ式自身は名前をもたない、@dfn{無名関数(anonymous
function)}です。ラムダ式をこの方法で使用できますが(@ref{Anonymous
Functions}を参照してください)、@dfn{名前付き関数(named
functions)}を作成するためにシンボルに関連付けられる方が一般的です(@pxref{Function
Names})。これらの詳細に触れる前に、以下のサブセクションではラムダ式の構成要素と、それらが行うことについて説明します。

@menu
* Lambda Components::        ラムダ式のパーツ。
* Simple Lambda::            シンプルな例。
* Argument List::            引数リストの詳細と特別な機能。
* Function Documentation::   関数内にドキュメントを記述する方法。
@end menu

@node Lambda Components
@subsection ラムダ式の構成要素

  ラムダ式は、以下のようなリストです:

@example
(lambda (@var{arg-variables}@dots{})
  [@var{documentation-string}]
  [@var{interactive-declaration}]
  @var{body-forms}@dots{})
@end example

@cindex lambda list
  ラムダ式の1番目の要素は常にシンボル@code{lambda}です。これは、そのリストが関数を表すことを示します。@code{lambda}で関数定義を開始する理由は、他の目的のたまえの使用が意図された他のリストが、意図せず関数として評価されないようにするためです。

  2番目の要素は、シンボル --- 引数変数名のリストです。これは@dfn{ラムダリスト(lambda
list)}と呼ばれます。Lisp関数が呼び出されたとき、引数値はラムダリスト内の変数と対応付けされます。ラムダリストは、与えられた値にたいするローカルバインディングが付与されます。@ref{Local
Variables}を参照してください。

  ドキュメント文字列(documentation string)はEmacs
Lispのヘルプ機能にたいしてその、関数を説明する、関数定義に配されたLisp文字列オブジェクトです。@ref{Function
Documentation}を参照してください。

  インタラクティブ宣言(interactive declaration)は、@code{(interactive
@var{code-string})}という形式のリストです。これは、この関数が対話的に使用された場合に引数を提供する方法を宣言します。この宣言をもつ関数は、@dfn{コマンド(command)}と呼ばれます。コマンドは@kbd{M-x}を使用したり、キーにバインドして呼び出すことができます。この方法で呼び出されることを意図しない関数は、インタラクティブ宣言を持つべきではありません。インタラクティブ定義を記述する方法は、@xref{Defining
Commands}を参照してください。

@cindex body of function
  残りの要素は、その関数の@dfn{body(本体)} ---
その関数が処理を行うためのLispコード(Lispプログラマーは``評価されるLispフォームのリスト''と言うでしょう)です。この関数からreturnされる値は、bodyの最後の要素によりreturnされる値です。

@node Simple Lambda
@subsection 単純なラムダ式の例

  以下の例を考えてみてください:

@example
(lambda (a b c) (+ a b c))
@end example

@noindent
以下のように、@code{funcall}に渡すことにより、この関数を呼び出すことができます:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 2 3)
@end group
@end example

@noindent
この呼び出しは、変数@code{a}に1、@code{b}に2、@code{c}に3をバインドして、ラムダ式のbodyを評価します。bodyの評価により、これら3つの数が加算されて、6が結果として生成されます。したがってこの関数呼び出しにより、6がreturnされます。

  以下のように、引数は他の関数の結果であってもよいことに注意してください:

@example
@group
(funcall (lambda (a b c) (+ a b c))
         1 (* 2 3) (- 5 4))
@end group
@end example

@noindent
これは引数@code{1}、@code{(* 2 3)}、@code{(- 5
4)}を左から右に評価します。その後、ラムダ式に引数1、6、1を適用して、値8が生成されます。

  これらの例が示すように、ローカル変数を作成して、それらに値を与えるフォームとして、@sc{car}がラムダ式であるようなフォームを使用することができます。古い時代のLispでは、この方法がローカル変数をバインドして初期化する唯一の方法でした。しかし現在では、この目的にはフォーム@code{let}を使用するほうが明解です(@ref{Local
Variables}を参照してください)。ラムダ式は主に、他の関数の引数として渡される無名関数(@ref{Anonymous
Functions}を参照してください)として、あるいは名前つき関数(@ref{Function
Names}を参照してください)を生成するためにシンボルの関数定義に格納するために使用されます。

@node Argument List
@subsection 引数リストのその他機能
@kindex wrong-number-of-arguments
@cindex argument binding
@cindex binding arguments
@cindex argument lists, features

  シンプルなサンプル関数@code{(lambda (a b c) (+ a b
c))}は、3つの引数変数を指定しているので、3つの引数で呼び出されなければなりません。引数を2つしか指定しなかったり4つ指定した場合は、@code{wrong-number-of-arguments}エラーとなります。

  特定の引数を省略できる関数を記述できると便利なこともあります。たとえば関数@code{substring}は3つの引数 ---
文字列、開始インデックス、終了インデックス ---
を受け取りますが、3つ目の引数を省略した場合、デフォルトでその文字列の@var{length}となります。関数@code{list}や@code{+}が行うように、特定の関数にたいして不定個の引数を指定できると便利なときもあります。

@cindex optional arguments
@cindex rest arguments
@kindex &optional
@kindex &rest
  関数が呼び出されるとき省略されるかもしれないオプションの引数を指定するには、オプションの引数の前にキーワード@code{&optional}を含めるだけです。0個以上の追加引数のリストを指定するには、最後の引数の前にキーワード@code{&rest}を含めます。

  したがって、引数リストの完全な構文は以下のようになります:

@example
@group
(@var{required-vars}@dots{}
 @r{[}&optional @var{optional-vars}@dots{}@r{]}
 @r{[}&rest @var{rest-var}@r{]})
@end group
@end example

@noindent
角カッコ(square
bracket)は、@code{&optional}と@code{&rest}、およびそれらに続く変数が省略できることを示します。

  この関数の呼び出しには、@var{required-vars}のそれぞれにたいして、実際の引数が要求されます。0個以上の@var{optional-vars}にたいして実際の引数があるかもしれませんが、ラムダ式が@code{&rest}を使用していなければ、その個数を超えて実際の引数を記述することはできません。@code{&rest}が記述されている場合、追加で任意個の実際の引数があるかもしれません。

  optionaやrest変数にたいして実際の引数が省略された場合、それらのデフォルトは常に@code{nil}になります。関数にたいして引数に明示的に@code{nil}が使用されたのか、引数が省略されたのかを区別することはできません。しかし関数のbodyが、@code{nil}を他の有意な値が省略されたと判断することは自由です。これは@code{substring}が行っていることです。@code{substring}の3つ目の引数が@code{nil}の場合、それは文字列の長さを使用することを意味します。

@cindex CL note---default optional arg
@quotation
@b{Common Lisp note:} Common Lisp allows the function to specify what
default value to use when an optional argument is omitted; Emacs Lisp always
uses @code{nil}.  Emacs Lisp does not support @code{supplied-p} variables
that tell you whether an argument was explicitly passed.
@end quotation

  例えば、引数リストは以下のようになります:

@example
(a b &optional c d &rest e)
@end example

@noindent
これは@code{a}と@code{b}は最初の2つの実引数となり、これらは必須です。さらに1つまたは2つの引数が指定された場合、それらは順番に@code{c}と@code{d}にバインドされます。1つ目から4つ目の引数の後の引数は、リストにまとめられて、@code{e}にそのリストがバインドされます。2つしか引数が指定されなかった場合、@code{c}は@code{nil}になります。2つまたは3つの引数の場合、@code{d}は@code{nil}です。引数が4つ以下の場合、@code{e}は@code{nil}になります。

  オプションの引数の後ろに必須の引数を指定する方法はありません ---
これは意味を成さないからです。なぜそうなるかは、この例で@code{c}がオプションで@code{d}が必須な場合を考えてみてください。実際に3つの引数が与えられたとします。3番めの引数は何を指定したのでしょうか?
この引数は@var{c}なのでしょうか、それとも@var{d}に使用されるのでしょうか?
両方の場合が考えられます。同様に、@code{&rest}引数の後に、さらに引数(必須またはオプション)をもつことも意味を成しません。

  以下に引数リストと、それを正しく呼び出す例をいくつか示します:

@example
(funcall (lambda (n) (1+ n))        ; @r{1つの必須:}
         1)                         ; @r{これは正確に1つの引数を要求する。}
     @result{} 2
(funcall (lambda (n &optional n1)   ; @r{1つは必須で、1つはオプション:}
           (if n1 (+ n n1) (1+ n))) ; @r{1つまたは2つの引数。}
         1 2)
     @result{} 3
(funcall (lambda (n &rest ns)       ; @r{1つは必須で、後は残り:}
           (+ n (apply '+ ns)))     ; @r{1つ以上の引数。}
         1 2 3 4 5)
     @result{} 15
@end example

@node Function Documentation
@subsection 関数のドキュメント文字列
@cindex documentation of function

  ラムダ式は、ラムダリストの食後に、オプションで@dfn{ドキュメント文字列(documentation
string)}をもつことができます。この文字列は、その関数の実行に影響を与えません。これはコメントの一種ですが、Lisp機構に内在するシステム化されたコメントであり。Emacsのヘルプ機能で使用できます。ドキュメント文字列にアクセスする方法は、@ref{Documentation}を参照してください。

  たとえその関数があなたのプログラム内だけで呼び出される関数だとしても、すべての関数にドキュメント文字列を与えるのはよいアイデアです。ドキュメント文字列はコメントと似ていますが、コメントより簡単にアクセスできます。

  ドキュメント文字列の1行目は、関数自体にもとづくものであるべきです。なぜなら@code{apropos}は、最初の1行目だけを表示するからです。ドキュメント文字列の1行目は、その関数の目的を要約する、1つまたは2つの完全なセンテンスで構成されるべきです。

  ドキュメント文字列の開始は通常、ソースファイル内ではインデントされていますが、ドキュメント文字列の開始のダブルクォート文字の前にインデントのスペースがあるので、インデントはドキュメント文字列の一部にはなりません。ドキュメント文字列の残りの行がプログラムソース内で揃うようにインデントする人がいます。@emph{これは、間違いです。}後続の行のインデントは文字列の内部にあります。これはソースコード内での見栄えはよくなりますが、ヘルプコマンドで表示したとき見栄えが悪くなります。

  ドキュメント文字列がなぜオプションになるのか不思議に思うかもしれません。なぜなら、ドキュメント文字列の後には必須となる関数の構成要素であるbodyが続くからです。文字列を評価するとその文字列自身がれつｒｎされるので、それがbody内の最後のフォームでない限りなんの効果もありません。したがって、実際はbodyの1行目とドキュメント文字列で混乱が生じることはありません。bodyの唯一のフォームが文字列の場合、それはreturn値とドキュメントの両方の役目を果たします。

  ドキュメント文字列の最後の行には、実際の関数引数とは異なる呼び出し規約を指定できます。これは以下のようなテキストを記述します

@example
\(fn @var{arglist})
@end example

@noindent
ただし、このテキストの前に空行があり、テキスト自身が行頭から記述されていて、ドキュメント文字列内でこのテキストの後に改行が続かない場合です(@samp{\}はEmacsの移動コマンドが混乱するのを避けるために使用されます)。この方法で指定された呼び出し規約は、ヘルプメッセージ内で関数の実引数から生成される呼び出し例と同じ場所に表示されます。

  マクロ定義内に記述された引数は、ユーザーがマクロ呼び出しの一部だと考える方法と合致しない場合がしばしばあるので、この機能はマクロ定義で特に有用です。

@node Function Names
@section 関数の命名
@cindex function definition
@cindex named function
@cindex function name

  シンボルは関数の名前となることができます。これは、そのシンボルの@dfn{関数セル(function cell}: @ref{Symbol
Components}を参照してください)が、関数オブジェクト(たとえばラムダ式)を含むときに起こります。するとそのシンボル自身が呼び出し可能な有効な関数、つまりそのシンボルの関数セルの関数と等価になります。

  関数セルの内容は、そのシンボルの@dfn{関数定義(function
definition)}と呼ぶこともできます。そのシンボルのかわりに、シンボルの関数定義を使う手続きのことを@dfn{シンボル関数インダイレクション(symbol
function indirection)}と呼びます。@ref{Function
Indirection}を参照してください。与えられたシンボルに関数定義がない場合、シンボルの関数セルは@dfn{void}と呼ばれ、それを関数として使用することはできません。

  実際のところ、ほとんどすべての関数は名前をもち、その名前により参照されます。ラムダ式を定義することにより名前つきのLisp関数を作成、それを関数セル(@ref{Function
Cells}を参照してください)に置くことができます。しかし、さらに一般的なのは@code{defun}スペシャルフォーム(次のセクションで説明します)を使う方法です。
@ifnottex
@ref{Defining Functions}を参照してください。
@end ifnottex

  わたしたちは関数名を与えるのは、Lisp式内で関数を名前で参照するのが便利だからです。また、名前つきの関数は簡単に自分自身を
---再帰的(recursive)に参照することができます。さらに、プリミティブはテキスト的な名前だけで参照することができます。なぜならプリミティブ関数は入力構文(read
syntax)をもたないオブジェクトだからです(@ref{Primitive Function Type}を参照してください)。

  関数は一意な名前をもつ必要はありません。与えられた関数オブジェクトは、@emph{通常}は1つのシンボルの関数セルだけに存在しますが、これは単に慣習的なものです。@code{fset}を使用して、関数を複数のシンボルに格納するのは簡単です。それらのシンボルはそれぞれ、同じ関数にたいする有効な名前となります。

  関数として使用されているシンボルを、変数としても利用できることに注意してください。シンボルのこれら2つの利用法は独立しており、競合はしません(これはSchemaのような他のいくつかのLisp方言には当てはまりません)。

@node Defining Functions
@section 関数の定義
@cindex defining a function

  わたしたちは通常、関数を最初に作成したときに名前を与えます。これは@dfn{関数の定義(defining a
function)}と呼ばれ、@code{defun}マクロにより行われます。

@defmac defun name args [doc] [declare] [interactive] body@dots{}
@code{defun}は新たなLisp関数を定義する通常の方法です。これは、引数リスト@var{args}、および@var{body}により与えられるbodyフォームとともに、シンボル@var{name}を関数として定義します。@var{name}と@var{args}を、クォートする必要はありません。

@var{doc}が与えられた場合、それはその関数のドキュメント文字列を指定する文字列であるべきです(@ref{Function
Documentation}を参照してください)。@var{declare}が与えられた場合、それは関数のメタデータを指定する、@code{declare}フォームであるべきです(@ref{Declare
Form}を参照してください)。@var{interactive}が与えられた場合、それは関数が対話的に呼び出される方法を指定する@code{interactive}フォームであるべきです(@ref{Interactive
Call}を参照してください)。

@code{defun}のreturn値は定義されていません。

以下にいくつか例を示します:

@example
@group
(defun foo () 5)
(foo)
     @result{} 5
@end group

@group
(defun bar (a &optional b &rest c)
    (list a b c))
(bar 1 2 3 4 5)
     @result{} (1 2 (3 4 5))
@end group
@group
(bar 1)
     @result{} (1 nil nil)
@end group
@group
(bar)
@error{} Wrong number of arguments.
@end group

@group
(defun capitalize-backwards ()
  "Upcase the last letter of the word at point."
  (interactive)
  (backward-word 1)
  (forward-word 1)
  (backward-char 1)
  (capitalize-word 1))
@end group
@end example

意図せず既存の関数を再定義しないように、注意してください。@code{defun}は@code{car}のようなプリミティブ関数でさえ、躊躇なく問い合わせもなしに再定義します。Emacsががががこれを妨げることはありません。なぜなら関数の再定義は故意に行われることがあり、そのような意図した再定義を、意図しない再定義と見分ける方法はないからです。
@end defmac

@cindex function aliases
@cindex alias, for functions
@defun defalias name definition &optional doc
@anchor{Definition of defalias}
この関数は、定義@var{definition}(任意の有効なLisp関数)とともに、シンボル@var{name}を関数として定義します。この関数のreturn値は@emph{未定義}です。

@var{doc}が非@code{nil}の場合、それは関数@var{name}のドキュメントになります。それ以外は、@var{definition}により提供されるドキュメントが使用されます。

@cindex defalias-fset-function property
内部的には、@code{defalias}は通常、定義のセットに@code{fset}を使用します。しかし@var{name}が@code{defalias-fset-function}プロパティーをもつ場合、@code{fset}を呼び出すかわりに、それに割り当てられた値が使用されます。

@code{defalias}を使う正しい場所は、特定の関数名がまさに定義される場所 ---
特にソースファイルがロードされるとき明示的にその名前が出現する場所です。これは@code{defalias}が、@code{defun}と同じように、どれが関数を定義するファイルなのか記録するからです(@ref{Unloading}を参照してください)。

それとは対象的に、他の目的のために関数を操作するプログラムでは、そのような記録を保持しない@code{fset}を使用するほうがよいでしょう。@ref{Function
Cells}を参照してください。
@end defun

  @code{defun}や@code{defalias}で新たなプリミティブ関数を作成することはできませんが、任意の関数定義を変更するのに使用することができ、通常の定義がプリミティブである@code{car}や@code{x-popup-menu}のような関数でさえ変更することができます。しかし、これは危険なことです。たとえば、Lispの完全性を損なうことなく、@code{car}を再定義するのはほとんど不可能だからです。それほど有名ではない@code{x-popup-menu}のような関数の再定義では、危険は減るものの、それでも期待したとおりに機能しないかもしれません。Cコードにこのプリミティブの呼び出しがある場合、それは直接そのプリミティブのC定義を呼び出すので、シンボル定義を変更しても、それらに影響はありません。

  @code{defsubst}も参照してください。これは@code{defun}のように関数を定義して、それのインライン展開を処理するようLispコンパイラーに指示します。@ref{Inline
Functions}を参照してください。

  Alternatively, you can define a function by providing the code which will
inline it as a compiler macro.  The following macros make this possible.

@c FIXME: Can define-inline use the interactive spec?
@defmac define-inline name args [doc] [declare] body@dots{}
Define a function @var{name} by providing code that does its inlining, as a
compiler macro.  The function will accept the argument list @var{args} and
will have the specified @var{body}.

If present, @var{doc} should be the function's documentation string
(@pxref{Function Documentation}); @var{declare}, if present, should be a
@code{declare} form (@pxref{Declare Form}) specifying the function's
metadata.
@end defmac

Functions defined via @code{define-inline} have several advantages with
respect to macros defined by @code{defsubst} or @code{defmacro}:

@itemize @minus
@item
They can be passed to @code{mapcar} (@pxref{Mapping Functions}).

@item
They are more efficient.

@item
They can be used as @dfn{place forms} to store values (@pxref{Generalized
Variables}).

@item
They behave in a more predictable way than @code{cl-defsubst}
(@pxref{Argument Lists,,, cl, Common Lisp Extensions for GNU Emacs Lisp}).
@end itemize

Like @code{defmacro}, a function inlined with @code{define-inline} inherits
the scoping rules, either dynamic or lexical, from the call site.
@xref{Variable Scoping}.

The following macros should be used in the body of a function defined by
@code{define-inline}.

@defmac inline-quote expression
Quote @var{expression} for @code{define-inline}.  This is similar to the
backquote (@pxref{Backquote}), but quotes code and accepts only @code{,},
not @code{,@@}.
@end defmac

@defmac inline-letevals (bindings@dots{}) body@dots{}
This is is similar to @code{let} (@pxref{Local Variables}): it sets up local
variables as specified by @var{bindings}, and then evaluates @var{body} with
those bindings in effect.  Each element of @var{bindings} should be either a
symbol or a list of the form @w{@code{(@var{var} @var{expr})}}; the result
is to evaluate @var{expr} and bind @var{var} to the result.  The tail of
@var{bindings} can be either @code{nil} or a symbol which should hold a list
of arguments, in which case each argument is evaluated, and the symbol is
bound to the resulting list.
@end defmac

@defmac inline-const-p expression
Return non-@code{nil} if the value of @var{expression} is already known.
@end defmac

@defmac inline-const-val expression
Return the value of @var{expression}.
@end defmac

@defmac inline-error format &rest args
Signal an error, formatting @var{args} according to @var{format}.
@end defmac

Here's an example of using @code{define-inline}:

@lisp
(define-inline myaccessor (obj)
  (inline-letevals (obj)
    (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
@end lisp

@noindent
This is equivalent to

@lisp
(defsubst myaccessor (obj)
  (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
@end lisp

@node Calling Functions
@section 関数の呼び出し
@cindex function invocation
@cindex calling a function

  関数を定義しただけでは、半分しか終わっていません。関数はそれを@dfn{呼び出す(call)} ---
たとえば実行(run)するまでは、何も行いません。関数のcallは、@dfn{invocation}としても知られています。

  関数を呼び出すもっとも一般的な方法は、リストの評価による方法です。たとえば、リスト@code{(concat "a"
"b")}を評価することにより、関数@code{concat}が引数@code{"a"}と@code{"b"}で呼び出されます。評価については、@ref{Evaluation}を参照してください。

  プログラム内で式としてリストを記述するときは、プログラム内にテキストで、どの関数を呼び出すか、いくつの引数を与えるかを指定します。通常は、これが行いたいことです。どの関数を呼び出すかを、実行時に計算する必要がある場合もあります。これを行うには、関数@code{funcall}を使用します。実行時にいくつの引数を渡すか決定する必要があるときは、@code{apply}を使用します。

@defun funcall function &rest arguments
@code{funcall}は、関数@var{function}を引数@var{arguments}で呼び出し、@var{function}がreturnした値をreturnします。

@code{funcall}は関数なので、@var{function}を含むすべての引数は、@code{funcall}の呼び出し前に評価されます。これは、呼び出される関数を得るための任意の式を使用できることを意味します。これはまた、@code{funcall}が@var{arguments}に記述した式ではなく、その値だけを見ることを意味します。これらの値は@var{function}呼び出し中では、2回目は評価@emph{されません}。@code{funcall}の処理は、関数の通常の呼び出し手続きと似ており、すでに評価された引数は評価されません。

The argument @var{function} must be either a Lisp function or a primitive
function.  Special forms and macros are not allowed, because they make sense
only when given the unevaluated argument expressions.  @code{funcall} cannot
provide these because, as we saw above, it never knows them in the first
place.

If you need to use @code{funcall} to call a command and make it behave as if
invoked interactively, use @code{funcall-interactively} (@pxref{Interactive
Call}).

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(funcall f 'x 'y 'z)
     @result{} (x y z)
@end group
@group
(funcall f 'x 'y '(z))
     @result{} (x y (z))
@end group
@group
(funcall 'and t nil)
@error{} Invalid function: #<subr and>
@end group
@end example

これらの例を、@code{apply}の例と比較してみてください。
@end defun

@defun apply function &rest arguments
@code{apply}は、関数@var{function}を引数@var{arguments}で呼び出します。これは@code{funcall}と同様ですが、1つ違いがあります。@var{arguments}の最後はオブジェクトのリストです。これは1つのリストではなく、個別の引数として@var{function}に渡されます。わたしたちはこれを、@code{apply}がこのリストを@dfn{展開(spread)}(個々の要素が引数となるので)する、と言います。

@code{apply}は、@var{function}を呼び出した結果をreturnします。@code{funcall}と同様、@var{function}はLisp関数かプリミティブ関数でなければなりません。つまりスペシャルフォームやマクロは、@code{apply}では意味をもちません。

@example
@group
(setq f 'list)
     @result{} list
@end group
@group
(apply f 'x 'y 'z)
@error{} Wrong type argument: listp, z
@end group
@group
(apply '+ 1 2 '(3 4))
     @result{} 10
@end group
@group
(apply '+ '(1 2 3 4))
     @result{} 10
@end group

@group
(apply 'append '((a b c) nil (x y z) nil))
     @result{} (a b c x y z)
@end group
@end example

@code{apply}を使用した興味深い例は、@ref{Definition of mapcar}を参照してください。
@end defun

@cindex partial application of functions
@cindex currying
  ある関数にたいして、その関数のある引数を特定の値に固定し、他の引数は実際に呼びだされたときの値にできれば便利なことがあります。関数のいくつかの引数を固定することは、その関数の@dfn{部分適用(partial
application)}と呼ばれます@footnote{これは@dfn{カリー化(currying)}と関連しますが、異なる機能です。カーリングは、複数の引数をとる関数を、関数チェーンとして呼び出せるような、１つの引数を取る個々の関数に変換するような方法です。}。結果は、残りの引数をとる新たな関数で、すべての引数を合わせて元の関数を呼び出します。

  Emacs Lispで部分適用を行う方法を示します:

@defun apply-partially func &rest args
この関数は、新たな関数をreturnします。この新しい関数は、呼びだされたときに@var{args}と、呼び出し時に指定された追加の引数から成る引数リストで@var{func}を呼び出す関数です。@var{func}に@var{n}個の引数を指定できる場合、@w{@code{@var{m}
< @var{n}}}個の引数で@code{apply-partially}を呼び出すと、@w{@code{@var{n} -
@var{m}}}個の新たな関数を生成します。

以下は、@code{apply-partially}と他のビルトイン関数@code{+},を使用して、(もし存在しないなら)ビルトイン関数@code{1+}を定義する例です:

@example
@group
(defalias '1+ (apply-partially '+ 1)
  "Increment argument by one.")
@end group
@group
(1+ 10)
     @result{} 11
@end group
@end example
@end defun

@cindex functionals
  引数として関数をとったり、データ構造(特にフック変数やプロパティーリスト)から関数を探す関数はLispでは一般的で、それらは@code{funcall}や@code{apply}を使用してそれらの関数を呼び出します。引数として関数をとる関数は、@dfn{ファンクショナル(functional)}と呼ばれるときもあります。

  ファンクショナルを呼び出すとき、引数としてno-op関数(何も行わない関数)を指定できると便利なときがあります。以下に２つの異なるno-op関数を示します:

@defun identity arg
この関数は@var{arg}をreturnします。副作用はありません。
@end defun

@defun ignore &rest args
この関数は任意の引数を無視して、@code{nil}をreturnします。
@end defun

  いくつかの関数はユーザーに可視な@dfn{コマンド}で、これらは(通常はキーシーケンスを介して)対話的に呼び出すことができます。そのようなコマンドは、@code{call-interactively}関数を使用することにより、対話的に呼びだされたときと同様に呼び出すことができます。@ref{Interactive
Call}を参照してください。

@node Mapping Functions
@section 関数のマッピング
@cindex mapping functions

  @dfn{マップ関数(mapping
function)}は与えられた関数(スペシャルフォームやマクロでは@emph{ない})を、リストや他のコレクションの各要素に適用します。Emacs
Lispにはそのような関数がいくつかあります。このセクションでは、リストにたいしてマッピングを行う@code{mapcar}、@code{mapc}、@code{mapconcat}を説明します。obarray内のシンボルにたいしてマッピングを行う関数@code{mapatoms}は、@ref{Definition
of
mapatoms}を参照してください。ハッシュテーブル内のkey/value関係にたいしてマッピングを行う関数@code{maphash}は、@ref{Definition
of maphash}を参照してください。

  これらのマップ関数は、文字テーブル(char-table)には適用されません。なぜなら文字テーブルは非常に広い範囲の疎な配列だからです。疎な配列であるという性質に適う方法で文字いテーブルにマッピングするには、関数@code{map-char-table}を使用します(@ref{Char-Tables}を参照してください)。

@defun mapcar function sequence
@anchor{Definition of mapcar}
@code{mapcar}は、関数@var{function}を@var{sequence}の各要素にたいして順番に適用し、その結果をリストでreturnします。

引数@var{sequence}には、文字テーブルを除く任意の種類のシーケンス ---
つまりリスト、ベクター、ブールベクター、文字列を指定できます。結果は常にリストになります。結果の長さは、@var{sequence}の長さと同じです。たとえば:

@example
@group
(mapcar 'car '((a b) (c d) (e f)))
     @result{} (a c e)
(mapcar '1+ [1 2 3])
     @result{} (2 3 4)
(mapcar 'string "abc")
     @result{} ("a" "b" "c")
@end group

@group
;; @r{@code{my-hooks}内の各関数を呼び出す。}
(mapcar 'funcall my-hooks)
@end group

@group
(defun mapcar* (function &rest args)
  "Apply FUNCTION to successive cars of all ARGS.
Return the list of results."
  ;; @r{リストが消費されていなければ、}
  (if (not (memq nil args))
      ;; @r{@sc{car}に関数を適用する。}
      (cons (apply function (mapcar 'car args))
            (apply 'mapcar* function
                   ;; @r{残りの要素のための再帰。}
                   (mapcar 'cdr args)))))
@end group

@group
(mapcar* 'cons '(a b c) '(1 2 3 4))
     @result{} ((a . 1) (b . 2) (c . 3))
@end group
@end example
@end defun

@defun mapc function sequence
@code{mapc}は@code{mapcar}と似ていますが、@var{function}は副作用のためだけに使用されます ---
つまり@var{function}がreturnする値は無視され、リストに収集されません。@code{mapc}は常に@var{sequence}をreturnします。
@end defun

@defun mapconcat function sequence separator
@code{mapconcat} applies @var{function} to each element of @var{sequence};
the results, which must be sequences of characters (strings, vectors, or
lists), are concatenated into a single string return value.  Between each
pair of result sequences, @code{mapconcat} inserts the characters from
@var{separator}, which also must be a string, or a vector or list of
characters.  @xref{Sequences Arrays Vectors}.

The argument @var{function} must be a function that can take one argument
and returns a sequence of characters: a string, a vector, or a list.  The
argument @var{sequence} can be any kind of sequence except a char-table;
that is, a list, a vector, a bool-vector, or a string.

@example
@group
(mapconcat 'symbol-name
           '(The cat in the hat)
           " ")
     @result{} "The cat in the hat"
@end group

@group
(mapconcat (function (lambda (x) (format "%c" (1+ x))))
           "HAL-8000"
           "")
     @result{} "IBM.9111"
@end group
@end example
@end defun

@node Anonymous Functions
@section 無名関数
@cindex anonymous function

  関数は通常、@code{defun}により定義され、同時に名前が与えられますが、明示的にラムダ式を使う --- @dfn{無名関数(anonymous
function)}のほうが便利なときもあります。無名関数は、名前つき関数が有効な場所なら、どこでも有効です。無名関数は変数や関数の引数に割り当てられることがよくあります。たとえば、ある関数をリストの各要素に適用する@code{mapcar}の@var{function}引数に渡すかもしれません(@ref{Mapping
Functions}を参照してください)。現実的な例は、@ref{describe-symbols example}を参照してください。

  無名関数として使用するためのラムダ式を定義するとき、原則的にはリストを構築する任意の手法を使用できます。しかし通常は、マクロ@code{lambda}、スペシャルフォーム@code{function}、または入力構文@code{#'}を使用するべきです。

@defmac lambda args [doc] [interactive] body@dots{}
このマクロは引数リスト@var{args}、(もしあれば)ドキュメント文字列@var{doc}、(もしあれば)インタラクティブ指定@var{interactive}、および@var{body}で与えられるbodyフォームをもつ無名関数をreturnします。

In effect, this macro makes @code{lambda} forms self-quoting: evaluating a
form whose @sc{car} is @code{lambda} yields the form itself:

@example
(lambda (x) (* x x))
     @result{} (lambda (x) (* x x))
@end example

@code{lambda}フォームは別に、1つの効果をもちます。このマクロは、@code{function}(以下参照)をサブルーチンとして使用することにより、Emacs評価機能(Emacs
evaluator)とバイトコンパイラーに、その引数が関数であることを告げます。
@end defmac

@defspec function function-object
@cindex function quoting
このスペシャルフォームは、評価を行わずに、@var{function-object}をreturnします。この点では、@code{quote}(@ref{Quoting}を参照してください)と似ています。しかし@code{quote}とは異なり、Emacs評価機能とバイトコンパイラーに、これを関数として使用する意図を告げる役割をもちます。@var{function-object}が有効なラムダ式と仮定すると、これは２つの効果をもちます:

@itemize
@item
そのコードがバイトコンパイルされているとき、@var{function-object}はバイトコード関数オブジェクトにコンパイルされます(@ref{Byte
Compilation}を参照してください)。

@item
レキシカルバインドが有効な場合、@var{function-object}はクロージャーに変換されます。@ref{Closures}を参照してください。
@end itemize
@end defspec

@cindex @samp{#'} syntax
入力構文@code{#'}は、@code{function}の使用の略記です。以下のフォームは等価です:

@example
(lambda (x) (* x x))
(function (lambda (x) (* x x)))
#'(lambda (x) (* x x))
@end example

  以下の例では、3つ目の引数に関数をとる、@code{change-property}関数を定義し、その後の@code{change-property}で、無名関数を渡してこれを使用しています:

@example
@group
(defun change-property (symbol prop function)
  (let ((value (get symbol prop)))
    (put symbol prop (funcall function value))))
@end group

@group
(defun double-property (symbol prop)
  (change-property symbol prop (lambda (x) (* 2 x))))
@end group
@end example

@noindent
@code{lambda}フォームをクォートしていないことに注意してください。

   上記のコードをコンパイルした場合は、無名関数もコンパイルされます。リストをクォートすることにより無名関数を構築した場合、コンパイルはされません。

@c Do not unquote this lambda!
@example
@group
(defun double-property (symbol prop)
  (change-property symbol prop '(lambda (x) (* 2 x))))
@end group
@end example

@noindent
この場合、無名関数はコンパイルされたコード内のラムダ式に保持されます。バイトコンパイラーは、@code{change-property}が関数としての使用を意図していることを知ることができないので、たとえこの関数が関数のように見えるとしても、このリストが関数であると決め込むことはできません。

@node Generic Functions
@section Generic Functions
@cindex generic functions
@cindex polymorphism

  Functions defined using @code{defun} have a hard-coded set of assumptions
about the types and expected values of their arguments.  For example, a
function that was designed to handle values of its argument that are either
numbers or lists of numbers will fail or signal an error if called with a
value of any other type, such as a vector or a string.  This happens because
the implementation of the function is not prepared to deal with types other
than those assumed during the design.

  By contrast, object-oriented programs use @dfn{polymorphic functions}: a set
of specialized functions having the same name, each one of which was written
for a certain specific set of argument types.  Which of the functions is
actually called is decided at run time based on the types of the actual
arguments.

@cindex CLOS
  Emacs provides support for polymorphism.  Like other Lisp environments,
notably Common Lisp and its Common Lisp Object System (@acronym{CLOS}), this
support is based on @dfn{generic functions}.  The Emacs generic functions
closely follow @acronym{CLOS}, including use of similar names, so if you
have experience with @acronym{CLOS}, the rest of this section will sound
very familiar.

  A generic function specifies an abstract operation, by defining its name and
list of arguments, but (usually) no implementation.  The actual
implementation for several specific classes of arguments is provided by
@dfn{methods}, which should be defined separately.  Each method that
implements a generic function has the same name as the generic function, but
the method's definition indicates what kinds of arguments it can handle by
@dfn{specializing} the arguments defined by the generic function.  These
@dfn{argument specializers} can be more or less specific; for example, a
@code{string} type is more specific than a more general type, such as
@code{sequence}.

  Note that, unlike in message-based OO languages, such as C@t{++} and Simula,
methods that implement generic functions don't belong to a class, they
belong to the generic function they implement.

  When a generic function is invoked, it selects the applicable methods by
comparing the actual arguments passed by the caller with the argument
specializers of each method.  A method is applicable if the actual arguments
of the call are compatible with the method's specializers.  If more than one
method is applicable, they are combined using certain rules, described
below, and the combination then handles the call.

@defmac cl-defgeneric name arguments [documentation] [options-and-methods@dots{}] &rest body
This macro defines a generic function with the specified @var{name} and
@var{arguments}.  If @var{body} is present, it provides the default
implementation.  If @var{documentation} is present (it should always be), it
specifies the documentation string for the generic function, in the form
@code{(:documentation @var{docstring})}.  The optional
@var{options-and-methods} can be one of the following forms:

@table @code
@item (declare @var{declarations})
A declare form, as described in @ref{Declare Form}.
@item (:argument-precedence-order &rest @var{args})
This form affects the sorting order for combining applicable methods.
Normally, when two methods are compared during combination, method arguments
are examined left to right, and the first method whose argument specializer
is more specific will come before the other one.  The order defined by this
form overrides that, and the arguments are examined according to their order
in this form, and not left to right.
@item (:method [@var{qualifiers}@dots{}] args &rest body)
This form defines a method like @code{cl-defmethod} does.
@end table
@end defmac

@defmac cl-defmethod name [qualifier] arguments &rest [docstring] body
This macro defines a particular implementation for the generic function
called @var{name}.  The implementation code is given by @var{body}.  If
present, @var{docstring} is the documentation string for the method.  The
@var{arguments} list, which must be identical in all the methods that
implement a generic function, and must match the argument list of that
function, provides argument specializers of the form @code{(@var{arg}
@var{spec})}, where @var{arg} is the argument name as specified in the
@code{cl-defgeneric} call, and @var{spec} is one of the following
specializer forms:

@table @code
@item @var{type}
This specializer requires the argument to be of the given @var{type}, one of
the types from the type hierarchy described below.
@item (eql @var{object})
This specializer requires the argument be @code{eql} to the given
@var{object}.
@item (head @var{object})
The argument must be a cons cell whose @code{car} is @code{eql} to
@var{object}.
@item @var{struct-tag}
The argument must be an instance of a class named @var{struct-tag} defined
with @code{cl-defstruct} (@pxref{Structures,,, cl, Common Lisp Extensions
for GNU Emacs Lisp}), or of one of its parent classes.
@end table

Alternatively, the argument specializer can be of the form @code{&context
(@var{expr} @var{spec})}, in which case the value of @var{expr} must be
compatible with the specializer provided by @var{spec}; @var{spec} can be
any of the forms described above.  In other words, this form of specializer
uses the value of @var{expr} instead of arguments for the decision whether
the method is applicable.  For example, @code{&context (overwrite-mode (eql
t))} will make the method compatible only when @code{overwrite-mode} is
turned on.

The type specializer, @code{(@var{arg} @var{type})}, can specify one of the
@dfn{system types} in the following list.  When a parent type is specified,
an argument whose type is any of its more specific child types, as well as
grand-children, grand-grand-children, etc. will also be compatible.

@table @code
@item integer
Parent type: @code{number}.
@item number
@item null
Parent type: @code{symbol}
@item symbol
@item string
Parent type: @code{array}.
@item array
Parent type: @code{sequence}.
@item cons
Parent type: @code{list}.
@item list
Parent type: @code{sequence}.
@item marker
@item overlay
@item float
Parent type: @code{number}.
@item window-configuration
@item process
@item window
@item subr
@item compiled-function
@item buffer
@item char-table
Parent type: @code{array}.
@item bool-vector
Parent type: @code{array}.
@item vector
Parent type: @code{array}.
@item frame
@item hash-table
@item font-spec
@item font-entity
@item font-object
@end table

The optional @var{qualifier} allows combining several applicable methods.
If it is not present, the defined method is a @dfn{primary} method,
responsible for providing the primary implementation of the generic function
for the specialized arguments.  You can also define @dfn{auxiliary methods},
by using one of the following values as @var{qualifier}:

@table @code
@item :before
This auxiliary method will run before the primary method.  More accurately,
all the @code{:before} methods will run before the primary, in the
most-specific-first order.
@item :after
This auxiliary method will run after the primary method.  More accurately,
all such methods will run after the primary, in the most-specific-last
order.
@item :around
This auxiliary method will run @emph{instead} of the primary method.  The
most specific of such methods will be run before any other method.  Such
methods normally use @code{cl-call-next-method}, described below, to invoke
the other auxiliary or primary methods.
@item :extra @var{string}
This allows you to add more methods, distinguished by @var{string}, for the
same specializers and qualifiers.
@end table
@end defmac

@cindex dispatch of methods for generic function
@cindex multiple-dispatch methods
Each time a generic function is called, it builds the @dfn{effective method}
which will handle this invocation by combining the applicable methods
defined for the function.  The process of finding the applicable methods and
producing the effective method is called @dfn{dispatch}.  The applicable
methods are those all of whose specializers are compatible with the actual
arguments of the call.  Since all of the arguments must be compatible with
the specializers, they all determine whether a method is applicable.
Methods that explicitly specialize more than one argument are called
@dfn{multiple-dispatch methods}.

The applicable methods are sorted into the order in which they will be
combined.  The method whose left-most argument specializer is the most
specific one will come first in the order.  (Specifying
@code{:argument-precedence-order} as part of @code{cl-defmethod} overrides
that, as described above.)  If the method body calls
@code{cl-call-next-method}, the next most-specific method will run.  If
there are applicable @code{:around} methods, the most-specific of them will
run first; it should call @code{cl-call-next-method} to run any of the less
specific @code{:around} methods.  Next, the @code{:before} methods run in
the order of their specificity, followed by the primary method, and lastly
the @code{:after} methods in the reverse order of their specificity.

@defun cl-call-next-method &rest args
When invoked from within the lexical body of a primary or an @code{:around}
auxiliary method, call the next applicable method for the same generic
function.  Normally, it is called with no arguments, which means to call the
next applicable method with the same arguments that the calling method was
invoked.  Otherwise, the specified arguments are used instead.
@end defun

@defun cl-next-method-p
This function, when called from within the lexical body of a primary or an
@code{:around} auxiliary method, returns non-@code{nil} if there is a next
method to call.
@end defun


@node Function Cells
@section 関数セルの内容へのアクセス

  あるシンボルの@dfn{関数定義(function
definition)}とは、そのシンボルの関数セルに格納されたオブジェクトのことです。ここでは、シンボルの関数セルにアクセス、テスト、セットする関数を説明します。

  @ref{Definition of indirect-function}の、関数@code{indirect-function}も参照してください。

@defun symbol-function symbol
@kindex void-function
これは@var{symbol}の関数セル内のオブジェクトをreturnします。これは、returnされたオブジェクトが本物のの関数であるかチェックしません。

関数セルがvoidの場合、return値は@code{nil}です。関数セルがvoidのときと、@code{nil}がセットされているときを区別するには、@code{fboundp}(以下参照)を使用します。

@example
@group
(defun bar (n) (+ n 2))
(symbol-function 'bar)
     @result{} (lambda (n) (+ n 2))
@end group
@group
(fset 'baz 'bar)
     @result{} bar
@end group
@group
(symbol-function 'baz)
     @result{} bar
@end group
@end example
@end defun

@cindex void function cell
  シンボルに何の関数定義も与えていない場合、そのシンボルの関数セルは@dfn{void}だと言います。別の言い方をすると、その関数セルは、どんなLispオブジェクトも保持しません。そのシンボルを関数として呼びだそうとすると、Emacsは@code{void-function}エラーをシグナルします。

  voidは、@code{nil}やシンボル@code{void}とは異なることに注意してください。シンボル@code{nil}および@code{void}はLispオブジェクトであり、他のオブジェクトと同様、関数セルに格納することができます(これらのシンボルは@code{defun}を使用して有効な関数に成ることができます)。voidである関数セルは、どのようなオブジェクトも含みません。

  @code{fboundp}を使用して、任意のシンボルの関数定義がvoidかどうかテストすることができます。シンボルに関数定義を与えた後は、@code{fmakunbound}をつかえば、再びvoidにすることができます。

@defun fboundp symbol
この関数は、そのシンボルが関数セルにオブジェクトをもっていれば@code{t}、それ以外は@code{nil}をreturnします。これは、そのオブジェクトが本物の関数であるかチェックしません。
@end defun

@defun fmakunbound symbol
この関数は@var{symbol}の関数セルをvoidにします。そのため、これ以降に関数セルにアクセスしようと試みると、@code{void-function}エラーが発生します。これは@var{symbol}をreturnします(@ref{Void
Variables}の@code{makunbound}も参照してください)。

@example
@group
(defun foo (x) x)
(foo 1)
     @result{}1
@end group
@group
(fmakunbound 'foo)
     @result{} foo
@end group
@group
(foo 1)
@error{} Symbol's function definition is void: foo
@end group
@end example
@end defun

@defun fset symbol definition
この関数は@var{symbol}の関数セルに、@var{definition}を格納します。結果は@var{definition}です。@var{definition}は通常、関数または関数の名前であるべきですが、これはチェックされません。引数@var{symbol}は、通常のどおり評価される引数です。

この関数は主に、関数を定義したり変更して構成を行う、@code{defun}や@code{advice-add}のようなものからサブルーチンとして使用されます。シンボルにたいして、たとえばキーボードマクロ(@ref{Keyboard
Macros}を参照してください)のような、関数ではない関数定義与えるためにも使用することができます:

@example
;; @r{名前つきのキーボードマクロを定義する。}
(fset 'kill-two-lines "\^u2\^k")
     @result{} "\^u2\^k"
@end example

関数にたいして別の名前を作成するために@code{fset}を使いたい場合は、かわりに@code{defalias}の使用を考慮してください。@ref{Definition
of defalias}を参照してください。
@end defun

@node Closures
@section クロージャー

  @ref{Variable
Scoping}で説明したように、Emacsはオプションで変数のレキシカルバインディングを有効にできます。レキシカルバインディングが有効な場合、あなたが(たとえば@code{defun}などで)作成した任意の名前つき関数、同様に@code{lambda}マクロ、@code{function}スペシャルフォーム、@code{#'}構文を使用して作成した任意の無名関数(@ref{Anonymous
Functions}を参照してください)は、自動的に@dfn{クロージャー(closure)}に変換されます。

@cindex closure
  クロージャーとは、その関数が定ぎされたどときに存在したレキシカル環境の記録もあわせもつ関数です。クロージャーが呼び出されたとき、定義内のレキシカル変数の参照には、その保持されたレキシカル環境を使用されます。他のすべての点では、クロージャーは通常の関数と同様に振る舞います。特に、クロージャーは通常の関数と同じ方法で呼び出すことができます。

  クロージャー使用する例は、@ref{Lexical Binding}を参照してください。

  現在のところ、Emacs
Lispのクロージャーオブジェクトは、1つ目の要素にシンボル@code{closure}をもつリストとして表現されます。そのリストは2つ目の要素としてレキシカル環境を表し、残りの要素で引数リストとbodyフォームを表します:

@example
;; @r{レキシカルバインディングが有効。}
(lambda (x) (* x x))
     @result{} (closure (t) (x) (* x x))
@end example

@noindent
However, the fact that the internal structure of a closure is exposed to the
rest of the Lisp world is considered an internal implementation detail.  For
this reason, we recommend against directly examining or altering the
structure of closure objects.

@node Advising Functions
@section Emacs Lisp関数にたいするアドバイス
@cindex advising functions
@cindex piece of advice

他のライブラリーの関数定義を変更する必要があるとき、または@code{@var{foo}-function}oのようなフックやプロセスフィルター(process
filter)、または関数を値としてもつ任意の変数またはオブジェクトを変更する必要があるときには、名前つきの関数には@code{fset}か@code{defun}、フック変数には@code{setq}、プロセスフィルターには@code{set-process-filter}のように、適切なセッター関数(setter
function)を使用することができます。しかし、これらが以前の値を完全に破棄してしまうのが好ましくない場合もあります。

  @dfn{アドバイス(advice)}機能により、@dfn{関数にアドバイス}することにより、既存の関数定義に機能を追加できます。これは関数全体を再定義するより明解な手法です。

Emacsのアドバイスシステムは2つのプリミティブセットを提供します。コアとなるセットは、変数やオブジェクトのフィールドに保持された関数値にたいするものです(対応するプリミティブは@code{add-function}と@code{remove-function}です)。もう1つのセットは、名前つき関数の最上位のレイヤーとなるものです(主要なプリミティブは@code{advice-add}と@code{advice-remove}です)。

たとえば、プロセス@var{proc}のプロセスフィルターの呼び出しをトレースするためには、以下を使用できます:

@example
(defun my-tracing-function (proc string)
  (message "Proc %S received %S" proc string))

(add-function :before (process-filter @var{proc}) #'my-tracing-function)
@end example

これにより、そのプロセスの出力は、元のプロセスフィルターに渡される前に、@code{my-tracing-function}に渡されるようになります。@code{my-tracing-function}は元の関数と同じ引数を受け取ります。これを行った場合、以下のようにしてトレースを行わない振る舞いにリバートすることができます。

@example
(remove-function (process-filter @var{proc}) #'my-tracing-function)
@end example

同様に、@code{display-buffer}という名前つきの関数の実行をトレースしたい場合は、以下を使用できます:

@example
(defun his-tracing-function (orig-fun &rest args)
  (message "display-buffer called with args %S" args)
  (let ((res (apply orig-fun args)))
    (message "display-buffer returned %S" res)
    res))

(advice-add 'display-buffer :around #'his-tracing-function)
@end example

ここで、@code{his-tracing-function}は元の関数のかわりに呼び出され、元の関数(加えてその関数の引数)を引数として受け取るので、必要な場合はそれを呼び出すことができます。出力を確認し終えたら、以下のようにしてトレースしない振る舞いにリバートできます:

@example
(advice-remove 'display-buffer #'his-tracing-function)
@end example

The arguments @code{:before} and @code{:around} used in the above examples
specify how the two functions are composed, since there are many different
ways to do it.  The added function is also called a piece of @emph{advice}.

@menu
* Core Advising Primitives::  アドバイスを扱うプリミティブ。
* Advising Named Functions::  名前つき関数のアドバイス。
* Advice combinators::       Ways to compose advice.
* Porting old advice::       古いdefadviceを使用したコードの改良。
@end menu

@node Core Advising Primitives
@subsection アドバイスを操作するためのプリミティブ
@cindex advice, add and remove

@defmac add-function where place function &optional props
このマクロは@var{place}(@ref{Generalized
Variables}を参照してください)に格納された関数に、アドバイス@var{function}を追加する手軽な方法です。

@var{where} determines how @var{function} is composed with the existing
function, e.g., whether @var{function} should be called before, or after the
original function.  @xref{Advice combinators}, for the list of available
ways to compose the two functions.

(通常は名前が@code{-function}で終わる)変数を変更するときには、@var{function}がグローバルに使用されるか、あるいはカレントバッファーだけに使用されるか選ぶことができます。@var{place}が単にシンボルの場合、@var{function}は@var{place}のグローバル値に追加されます。@var{place}が@code{(local
@var{symbol})}というフォームの場合、@var{symbol}はその変数の名前をreturnする式なので、@var{function}はカレントバッファーだけに追加されます。最後に、レキシカル変数を変更したい場合には、@code{(var
@var{variable})}を使用する必要があるでしょう。

@code{add-function}で追加されたすべての関数は、自動的にプロパティー@var{props}の関連リストに加えることができます。現在のところ、特別な意味をもつのは2つのプロパティーだけです:

@table @code
@item name
これはアドバイスの名前を与えます。この名前は、@code{remove-function}が取り除く関数を識別するのに使用できます。これは通常、@var{function}が無名関数のときに使用されます。

@item depth
This specifies how to order the advice, should several pieces of advice be
present.  By default, the depth is 0.  A depth of 100 indicates that this
piece of advice should be kept as deep as possible, whereas a depth of -100
indicates that it should stay as the outermost piece.  When two pieces of
advice specify the same depth, the most recently added one will be
outermost.

For @code{:before} advice, being outermost means that this advice will be
run first, before any other advice, whereas being innermost means that it
will run right before the original function, with no other advice run
between itself and the original function.  Similarly, for @code{:after}
advice innermost means that it will run right after the original function,
with no other advice run in between, whereas outermost means that it will be
run right at the end after all other advice.  An innermost @code{:override}
piece of advice will only override the original function and other pieces of
advice will apply to it, whereas an outermost @code{:override} piece of
advice will override not only the original function but all other advice
applied to it as well.
@end table

@var{function}がインタラクティブでない場合、欠オグされた関数は、(もしあれば)元の関数のインタラクティブ指定(interactive
spec)を継承します。それ以外は、結合された関数はインタラクティブになり、@var{function}のインタラクティブ指定を使用します。1つ例外があります。@var{function}のインタラクティブ指定が、(式や文字列ではない)関数の場合、元の関数のインタラクティブ指定を唯一の引数として、その関数を呼び出して、それが結合された関数のインタラクティブ指定になります。引数として受け取ったインタラクティブ指定を解釈するためには、@code{advice-eval-interactive-spec}を使用します。

注意:
@var{function}のインタラクティブ指定は結合された関数に適用され、@var{function}ではなく、結合された関数の呼び出し規約に従うべきです。多くの場合、これらは等しいので差異は生じませんが、@var{function}の@code{:around}、@code{:filter-args}、@code{filter-return}では、重要になります。
@end defmac

@defmac remove-function place function
このマクロは@var{place}に格納された関数から、@var{function}を取り除きます。これは、@code{add-function}を使用して、@var{function}が@var{place}に追加されたときだけ機能します。

@var{function}は、@var{place}に追加された関数にたいして、ラムダ式にたいしても機能するように、@code{equal}を使用して比較を試みます。これは追加で@var{place}に追加された関数の@code{name}プロパティーも比較します。これは@code{equal}を使用してラムダ式を比較するより信頼性があります。
@end defmac

@defun advice-function-member-p advice function-def
@var{advice}がすでに@var{function-def}内にある場合は、非@code{nil}をreturnします。上記の@code{remove-function}と同様、実際の関数@var{advice}のかわりに、アドバイス断片(piece
of advice)の@code{name}も使用できます。
@end defun

@defun advice-function-mapc f function-def
Call the function @var{f} for every piece of advice that was added to
@var{function-def}.  @var{f} is called with two arguments: the advice
function and its properties.
@end defun

@defun advice-eval-interactive-spec spec
Evaluate the interactive @var{spec} just like an interactive call to a
function with such a spec would, and then return the corresponding list of
arguments that was built.  E.g., @code{(advice-eval-interactive-spec
"r\nP")} will return a list of three elements, containing the boundaries of
the region and the current prefix argument.
@end defun

@node Advising Named Functions
@subsection 名前つき関数にたいするアドバイス
@cindex advising named functions

アドバイスの一般的な使い方は、名前つき関数やマクロにたいして使用する方法です。これは単に@code{add-function}を使用して以下のように行うことができます:

@example
(add-function :around (symbol-function '@var{fun}) #'his-tracing-function)
@end example

  But you should use @code{advice-add} and @code{advice-remove} for that
instead.  This separate set of functions to manipulate pieces of advice
applied to named functions, offers the following extra features compared to
@code{add-function}: they know how to deal with macros and autoloaded
functions, they let @code{describe-function} preserve the original docstring
as well as document the added advice, and they let you add and remove advice
before a function is even defined.

  既存の関数を関数全体を再定義せずに、既存の呼び出しを変更するために、@code{advice-add}は有用になります。しかし、その関数の既存の呼び出し元は、古い振る舞いを前提としているかもしれず、アドバイスによりその振る舞いが変更されたときに正しく機能しないかもしれないので、これはソースのバグにもなり得ます。アドバイスはデバッグを難しくする可能性もあります。デバッグを行う人は、その関数がアドバイスにより変更されたことに気づかなかったり、失念しているかもしれません。

  これらの理由により、他の方法で関数の振る舞いを変更できない場合のために、アドバイスの使用は控えるべきです。フックを通じて同じことが行えるなら、フック(@ref{Hooks}を参照してください)の使用が望ましい方法です。特定のキーが行う何かを変更したいだけなら、新しいコマンドを記述して、古いコマンドのキーバインドを新しいコマンドにリマップ(@ref{Remapping
Commands}を参照してください)するのが、おそらくより良い方法です。特に、Emacs自身のソースファイルは、Emacs内の関数をアドバイスするべきではありません(現在のところこの慣習には数少ない例外がありますが、わたしたちはこれを改善しようと思っています)。

  スペシャルフォーム(@ref{Special
Forms}を参照してください)はアドバイスできませんが、マクロは関数と同じ方法でアドバイスできます。もちろん、これはすでにマクロ展開されたコードには影響しないため、マクロ展開前にアドバイスが確実にインストールされる必要があります。

  プリミティブ(@ref{What Is a
Function}を参照してください)にアドバイスするのは可能ですが、2つの理由により通常は行うべきでは@emph{ありません}。1つ目の理由は、いくつかのプリミティブはアドバイスのメカニズム内で使用されているため、それらにたいしてアドバイスを行うと無限再帰が発生するからです。2つ目の理由は、多くのプリミティブがCから直接呼び出されていて、そのような呼び出しはアドバイスを無視するからです。したがって、プリミティブにたいしてアドバイスの使用を控えることは、ある呼び出しはアドバイスにしたがい(Lispコードから呼びだされたため)、他の呼び出しではアドバイスにしたがわない(Cコードから呼び出されたため)という混乱した状況を解決します。

@defmac define-advice symbol (where lambda-list &optional name depth) &rest body
This macro defines a piece of advice and adds it to the function named
@var{symbol}.  The advice is an anonymous function if @var{name} is nil or a
function named @code{symbol@@name}.  See @code{advice-add} for explanation
of other arguments.
@end defmac

@defun advice-add symbol where function &optional props
名前つき関数@var{symbol}に、アドバイス@var{function}を追加します。@var{where}と@var{props}は、@code{add-function}(@ref{Core
Advising Primitives}を参照してください)のときと同じ意味をもちます。
@end defun

@defun advice-remove symbol function
Remove the advice @var{function} from the named function @var{symbol}.
@var{function} can also be the @code{name} of a piece of advice.
@end defun

@defun advice-member-p function symbol
Return non-@code{nil} if the advice @var{function} is already in the named
function @var{symbol}.  @var{function} can also be the @code{name} of a
piece of advice.
@end defun

@defun advice-mapc function symbol
Call @var{function} for every piece of advice that was added to the named
function @var{symbol}.  @var{function} is called with two arguments: the
advice function and its properties.
@end defun

@node Advice combinators
@subsection Ways to compose advice

以下は@code{add-function}および@code{advice-add}の@var{where}引数に可能な値で、そのアドバイス@var{function}と元の関数が構成されるべき方法を指定します。

@table @code
@item :before
古い関数の前に@var{function}を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (apply @var{function} r) (apply @var{oldfun} r))
@end example
@code{(add-function :before @var{funvar}
@var{function})}は、ノーマルフックにたいする@code{(add-hook '@var{hookvar}
@var{function})}のような、1関数のフックと同等です。

@item :after
古い関数の後に@var{function}を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (prog1 (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after @var{funvar}
@var{function})}は、ノーマルフックにたいする@code{(add-hook '@var{hookvar} @var{function}
'append)}のような、1関数のフックと同等です。

@item :override
これは古い関数を新しい関数に完全に置き換えます。もちろん、@code{remove-function}を呼び出した後に、古い関数は復元されます。

@item :around
古い関数のかわりに@var{function}を呼び出しますが、古い関数は@var{function}の追加の引数になります。これはもっとも柔軟な結合です。たとえば、古い関数を異なる引数で呼び出したり、複数回呼び出したり、letバインディングで呼び出したり、あるときは古い関数に処理を委譲し、またあるときは完全にオーバーライドすることが可能になります。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (apply @var{function} @var{oldfun} r))
@end example

@item :before-while
古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をreturnした場合は古い関数を呼び出しません。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、古い関数のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (and (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-while @var{funvar}
@var{function})}は、@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function})}のような、1関数のフックと同等です。

@item :before-until
古い関数の前に@var{function}を呼び出し、@var{function}が@code{nil}をreturnした場合だけ古い関数を呼び出します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (or (apply @var{function} r) (apply @var{oldfun} r)))
@end example
@code{(add-function :before-until @var{funvar} @var{function})}
は、@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function})}のような、1関数のフックと同等です。

@item :after-while
古い関数が非@code{nil}をreturnした場合だけ、古い関数の後に@var{function}を呼び出します。関数は両方とも同じ引数を受け取り、2つの関数の結合のreturn値は、@var{function}のreturn値です。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (and (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-while @var{funvar}
@var{function})}は、@code{run-hook-with-args-until-failure}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function} 'append)}のような、1関数のフックと同等です。

@item :after-until
古い関数が@code{nil}をreturnした場合だけ、古い関数の後に@var{function}を呼び出します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (or  (apply @var{oldfun} r) (apply @var{function} r)))
@end example
@code{(add-function :after-until @var{funvar}
@var{function})}は、@code{run-hook-with-args-until-success}を通じて@var{hookvar}が実行されたときの@code{(add-hook
'@var{hookvar} @var{function} 'append)}のような、1関数のフックと同等です。

@item :filter-args
最初に@var{function}を呼び出し、その結果(リスト)を新たな引数として古い関数に渡します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (apply @var{oldfun} (funcall @var{function} r)))
@end example

@item :filter-return
最初に古い関数を呼び出し、その結果を@var{function}に渡します。より正確に言うと、2つの関数の結合は、以下のように振る舞います:
@example
(lambda (&rest r) (funcall @var{function} (apply @var{oldfun} r)))
@end example
@end table


@node Porting old advice
@subsection 古いdefadviceを使用するコードの改良
@cindex old advices, porting

多くのコードは古い@code{defadvice}メカニズムを使用しており、これらの大半は@code{advice-add}により陳腐化しました。@code{advice-add}の実装と意味は、とてもシンプルです。

An old piece of advice such as:

@example
(defadvice previous-line (before next-line-at-end
                                 (&optional arg try-vscroll))
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

新しいアドバイスメカニズムを使用すれば、これを通常の関数に変換できます:

@example
(defun previous-line--next-line-at-end (&optional arg try-vscroll)
  "Insert an empty line when moving up from the top line."
  (if (and next-line-add-newlines (= arg 1)
           (save-excursion (beginning-of-line) (bobp)))
      (progn
        (beginning-of-line)
        (newline))))
@end example

これが実際の@code{previous-line}を変更しないことは明確です。古いアドバイスには、以下が必要です:
@example
(ad-activate 'previous-line)
@end example
一方、新しいアドバイスメカニズムでは、以下が必要です:
@example
(advice-add 'previous-line :before #'previous-line--next-line-at-end)
@end example

Note that @code{ad-activate} had a global effect: it activated all pieces of
advice enabled for that specified function.  If you wanted to only activate
or deactivate a particular piece, you needed to @emph{enable} or
@emph{disable} it with @code{ad-enable-advice} and
@code{ad-disable-advice}.  The new mechanism does away with this
distinction.

Around advice such as:

@example
(defadvice foo (around foo-around)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    ad-do-it))
(ad-activate 'foo)
@end example

これは以下のように変換できます:

@example
(defun foo--foo-around (orig-fun &rest args)
  "Ignore case in `foo'."
  (let ((case-fold-search t))
    (apply orig-fun args)))
(advice-add 'foo :around #'foo--foo-around)
@end example

Regarding the advice's @emph{class}, note that the new @code{:before} is not
quite equivalent to the old @code{before}, because in the old advice you
could modify the function's arguments (e.g., with @code{ad-set-arg}), and
that would affect the argument values seen by the original function, whereas
in the new @code{:before}, modifying an argument via @code{setq} in the
advice has no effect on the arguments seen by the original function.  When
porting @code{before} advice which relied on this behavior, you'll need to
turn it into new @code{:around} or @code{:filter-args} advice instead.

Similarly old @code{after} advice could modify the returned value by
changing @code{ad-return-value}, whereas new @code{:after} advice cannot, so
when porting such old @code{after} advice, you'll need to turn it into new
@code{:around} or @code{:filter-return} advice instead.

@node Obsolete Functions
@section 関数を陳腐と宣言する
@cindex obsolete functions

  名前つき関数を@dfn{陳腐化している(obsolete)}とマークすることができます。これは、その関数が将来のある時点で削除されるかもしれないことを意味します。陳腐化しているとマークされた関数を含むコードをバイトコンパイルしたとき、Ｅｍａｃｓは警告を発します。また、その関数のヘルプドキュメントは表示されなくなります。他の点においては、陳腐化した関数は他の任意の関数と同様に振る舞います。

  関数を陳腐化しているとマークするもっとも簡単な方法は、その関数の@code{defun}定義に@code{(declare (obsolete
@dots{}))}を配置することです。@ref{Declare
Form}を参照してください。かわりに、以下で説明している@code{make-obsolete}関数を使うこともできます。

  @code{make-obsolete}を使用して、マクロ(@ref{Macros}を参照してください)を陳腐化しているとマークすることもできます。これは関数のときと同じ効果をもちます。関数またはマクロにたいするエイリアスも、陳腐化しているとマークできます。これはエイリアス自身をマークし、名前解決される関数またはマクロにたいしてではありません。

@defun make-obsolete obsolete-name current-name &optional when
この関数は、@var{obsolete-name}を陳腐化しているとマークします。@var{obsolete-name}には関数またはマクロを名前づけるシンボル、、または関数やマクロにたいするエイリアスを指定します。

@var{current-name}がシンボルの場合は、@var{obsolete-name}のかわりに@var{current-name}の使用を促す警告メッセージになります。@var{current-name}は、@var{obsolete-name}にたいするエイリアスである必要はありません。似たような機能をもつ、別の関数かもしれません。@var{current-name}には、警告メッセージとなる文字列も指定できます。メッセージは小文字で始まりピリオドで終えるべきです。@code{nil}も指定でき、この場合には警告メッセージに追加の詳細は提供されません。

@var{when}が与えられた場合、それは最初にその関数が陳腐化する時期を示す文字列 --- たとえば火付けやリリース番号を指定します。
@end defun

@defmac define-obsolete-function-alias obsolete-name current-name &optional when doc
この便利なマクロは関数@var{obsolete-name}を陳腐化しているとマークするとともに、それを関数@var{current-name}のエイリアスにします。これは以下と等価です:

@example
(defalias @var{obsolete-name} @var{current-name} @var{doc})
(make-obsolete @var{obsolete-name} @var{current-name} @var{when})
@end example
@end defmac

加えて、陳腐化した関数にたいする特定の呼び出し規約をマークできます。

@defun set-advertised-calling-convention function signature when
この関数は、@var{function}を呼び出す正しい方法として、引数リスト@var{signature}を指定します。これにより、Emacs
Lispプログラムが他の方法で@var{function}を呼び出している場合には、Emacsのバイトコンパイラーが警告を発します(それでもコードはバイトコンパイルされます)。@var{when}には、その変数が最初に陳腐化するときを示す文字列(通常はバージョン番号)を指定します。

たとえば、古いバージョンのEmacsでは、@code{sit-for}には以下のように3つの引数を指定していました

@example
  (sit-for seconds milliseconds nodisp)
@end example

しかしこの方法による@code{sit-for}の呼び出しは陳腐化していると判断されます(@ref{Waiting}を参照してください)。以下のように、古い呼び出し規約は推奨されません:

@example
(set-advertised-calling-convention
  'sit-for '(seconds &optional nodisp) "22.1")
@end example
@end defun

@node Inline Functions
@section インライン関数Inline Functions
@cindex inline functions

  @dfn{インライン関数(inline
function)}は関数と同様に機能しますが、1つ例外があります。その関数の呼び出しがバイトコンパイルされると(@ref{Byte
Compilation}を参照してください)、その関数の定義が呼び出し元に展開されます。インライン関数を定義するには、@code{defun}のかわりに@code{defsubst}を使用します。

@defmac defsubst name args [doc] [declare] [interactive] body@dots{}
このマクロはインライン関数を定義します。マクロの構文は@code{defun}とまったく同じです(@ref{Defining
Functions}を参照してください)。
@end defmac

  関数をインラインにすることにより、その関数の呼び出しが高速になる場合があります。しかし欠点もあります。1つは柔軟性の減少です。その関数の定義を変更した場合、すでにインライン化された呼び出しは、リコンパイルを行うまで古い定義を使用します。

  もう1つの欠点は、大きな関数をインライン化することにより、コンパイルされたコードのファイル上およびメモリー上のサイズが増大することです。スピード面でのインライン化の有利性は小さい関数にたいして顕著なので、一般的に大きな関数をインライン化するべきではありません。

  インライン関数は、デバッグ、トレース、アドバイス(@ref{Advising
Functions}を参照してください)に際してうまく機能しません。デバッグの容易さと関数の再定義の柔軟さはEmacsの重要な機能なので、スピードがとても重要であり、@code{defun}の使用が実際に性能の面で問題となるのか検証するためにすでにコードをチューニングしたのでなければ、たとえその関数が小さくてもインライン化するべきでは
ありません。

  インライン関数を定義した後、そのインライン展開はマクロ同様、同じファイル内の後の部分で処理されます。

  It's possible to use @code{defsubst} to define a macro to expand into the
same code that an inline function would execute (@pxref{Macros}).  But the
macro would be limited to direct use in expressions---a macro cannot be
called with @code{apply}, @code{mapcar} and so on.  Also, it takes some work
to convert an ordinary function into a macro.  To convert it into an inline
function is easy; just replace @code{defun} with @code{defsubst}.  Since
each argument of an inline function is evaluated exactly once, you needn't
worry about how many times the body uses the arguments, as you do for
macros.

  As an alternative to @code{defsubst}, you can use @code{define-inline} to
define functions via their exhaustive compiler macro.  @xref{Defining
Functions, define-inline}.

@node Declare Form
@section @code{declare}フォーム
@findex declare

  @code{declare} is a special macro which can be used to add meta properties
to a function or macro: for example, marking it as obsolete, or giving its
forms a special @key{TAB} indentation convention in Emacs Lisp mode.

@anchor{Definition of declare}
@defmac declare specs@dots{}
このマクロは引数を無視して、@code{nil}として評価され、実行時の効果はありません。しかし@code{defun}または@code{defsubst}(@ref{Defining
Functions}を参照してください)、または@code{defmacro}マクロ(@ref{Defining
Macros}を参照してください)の定義の@var{declare}引数に@code{declare}フォームがある場合は、@var{specs}で指定されたプロパティーを関数またはマクロに追加します。これは@code{defun}、@code{defsubst}、@code{defmacro}により特別に処理されます。

@var{specs}内の各要素は@code{(@var{property}
@var{args}@dots{})}というフォームをもつべきです。また、クォートするべきではありません。これらは、以下の効果をもちます:

@table @code
@item (advertised-calling-convention @var{signature} @var{when})
これは@code{set-advertised-calling-convention}(@ref{Obsolete
Functions}を参照してください)の呼び出しと同じように振る舞います。@var{signature}はその関数(またはマクロにたいする正しい引数リスト)で、@var{when}は古い引数リストが最初に陳腐化する時期を示す文字列を指定します。

@item (debug @var{edebug-form-spec})
これはマクロだけに有効です。Edebugでそのマクロ入ったときに、@var{edebug-form-spec}を使用します。@ref{Instrumenting
Macro Calls}を参照してください。

@item (doc-string @var{n})
それ自身が関数、マクロ、または変数のようなエンティティーを定義するために使用される関数やマクロを定義するときに使用されます。これは@var{n}番目の引数を示し、もしあれば、それはドキュメント文字列です。

@item (indent @var{indent-spec})
この関数(またはマクロ)にたいするインデント呼び出しは、@var{indent-spec}にしたがいます。これは関数でも機能しますが、通常はマクロで使用されます。@ref{Indenting
Macros}を参照してください。

@item (interactive-only @var{value})
Set the function's @code{interactive-only} property to @var{value}.
@xref{The interactive-only property}.

@item (obsolete @var{current-name} @var{when})
@code{make-obsolete}(@ref{Obsolete
Functions}を参照してください)と同様に、関数(またはマクロ)を陳腐化しているとマークします。@var{current-name}にはシンボル(かわりにこのシンボルを使うことをすすめる警告メッセージになります)、文字列(警告メッセージを指定します)、または@code{nil}(警告メッセージには追加の詳細が含まれません)を指定します。@var{when}には、その関数(またはマクロ)が最初に陳腐化する時期を示す文字列を指定します。

@item (compiler-macro @var{expander})
これは関数だけに使用でき、最適化関数(optimization
function)として@var{expander}を使用するようコンパイラーに告げます。@code{(@var{function}
@var{args}@dots{})}のようなその関数への呼び出しフォームに出会うと、マクロ展開機能(macro
expander)は@var{args}@dots{}と同様のフォームで@var{expander}を呼び出します。@var{expander}はその関数呼び出しのかわりに使用するための新しい式、または変更されていないフォーム(その関数呼び出しを変更しないことを示す)のどちらかをreturnすることができます。@var{expander}にはシンボル、またはフォーム@code{(lambda
(@var{arg})
@var{body})}を指定できます。フォームの場合、@var{arg}は元の関数呼び出し式を保持して、その関数の形式に適う引数を使用することにより、その関数にたいする(評価されていない)引数にアクセスできます。

@item (gv-expander @var{expander})
@var{expander}が@code{gv-define-expander}と同様、汎変数としてマクロ(または関数)にたいする呼び出しを処理する関数であることを宣言します。@var{expander}はシンボル、またはフォーム@code{(lambda
(@var{arg}) @var{body})}を指定できます。フォームの場合、その関数は追加でそのマクロ(または関数)にアクセスできます。

@item (gv-setter @var{setter})
@var{setter}が、汎変数としてマクロ(または関数)にたいする呼び出しを処理する関数であることを宣言します。@var{setter}はシンボル、またはフォームを指定できます。シンボルの場合、そのシンボルは@code{gv-define-simple-setter}に渡されます。フォームの場合は@code{(lambda
(@var{arg})
@var{body})}という形式で、その関数は追加でマクロ(または関数)にアクセスでき、@code{gv-define-setter}に渡されます。

@end table

@end defmac

@node Declaring Functions
@section コンパイラーへの定義済み関数の指示
@cindex function declaration
@cindex declaring functions
@findex declare-function

あるファイルをバイトコンパイルするとき、コンパイラーが知らない関数について警告が生成されるときがあります(@ref{Compiler
Errors}を参照してください)。実際に問題がある場合もありますが、問題となっている関数がそのコードの実行時にロードされる他のファイルで定義されている場合が通常です。たとえば以前は、@file{fortran.el}をバイトコンパイルすると、以下のような警告が出ていました:

@example
In end of data:
fortran.el:2152:1:Warning: the function ‘gud-find-c-expr’ is not
    known to be defined.
@end example

実際のところ、@code{gud-find-c-expr}は、Fortranモードが使用する@code{gud-find-expr-function}のローカル値(GUDからのコールバック)の中だけで使用されていて、呼びだされた場合はGUD関数がロードされます。そのような警告が実際には問題を示さないことを知っているときには、警告を抑制したほうがよいでしょう。そうすれば、実際に問題があることを示す新しい警告の識別性が良くなります。@code{declare-function}を使用して、これを行うことができます。

必要なのは、問題となっている関数を最初に使用する前に@code{declare-function}命令を追加するだけです:

@example
(declare-function gud-find-c-expr "gud.el" nil)
@end example

これは@code{gud-find-c-expr}が@file{gud.el}(@samp{.el}は省略可)の中で定義していることを告げます。コンパイラーは関数がそのファイルで実際に定義されているとみなし、チェックを行いません。

  3つ目の引数はオプションで、@code{gud-find-c-expr}の引数リストを指定します。この例では、引数はありません(@code{nil}と値を指定しないのは、異なります)。それ以外の場合は、@code{(file
&optional
overwrite)}のようになります。引数リストを指定する必要はありませんが、指定すればコンパイラーはその呼び出しが宣言と合致するかチェックできます。

@defmac declare-function function file &optional arglist fileonly
バイトコンパイラーにたいして、引数@var{arglist}をとる@var{function}が定義されていて、その定義は@var{file}にあるとみなすように告げます。@var{fileonly}が非@code{nil}の場合は、@var{file}が存在することだけをチェックして、実際の@var{function}の定義はチェックしないことを意味します。
@end defmac

  これらの関数が@code{declare-function}が告げる場所で実際に宣言されているか検証するには、@code{check-declare-file}を使用して、1つのソースファイル中のすべての@code{declare-function}呼び出しをチェックするか、@code{check-declare-directory}を使用して、特定のディレクトリー配下のすべてのファイルをチェックします。

  これらのコマンドは、@code{locate-library}で使用する関数の定義を含むべきファイルを探します。ファイルが見つからない場合、これらのコマンドは@code{declare-function}の呼び出しを含むファイルをがあるディレクトリーからの相対ファイル名に、定義ファイル名を展開します。

  @samp{.c}や@samp{.m}で終わるファイル名を指定することにより、プリミティブ関数を指定することもできます。これが有用なのは、特定のシステムだけで定義されるプリミティブを呼び出す場合だけです。ほとんどのプリミティブは常に定義されているので、それらについて警告を受け取ることはありえないはずです。

  あるファイルがオプションとして外部のパッケージの関数を使う場合があります。@code{declare-function}命令内のファイル名のプレフィクスを@samp{ext:}にすると、そのファイルが見つかった場合はチェックして、見つからない場合はエラーとせずにスキップします。

  @samp{check-declare}が理解しない関数定義もいくつか存在します(たとえば@code{defstruct}や、その他いくつかのマクロ)。そのような場合、@code{declare-function}の@var{fileonly}引数に、非@code{nil}を渡すことができます。これはファイルの存在だけをチェックして、その関数の実際の定義はチェックしないことを意味します。これを行う場合、引数リストを指定する必要はないのですが、@var{arglist}引数には@code{t}をセットするべきだということに注意してください(なぜなら@code{nil}は、引数リストが指定されなかったという意味ではなく、空の引数リストを意味するからです)。

@node Function Safety
@section 安全に関数を呼び出せるかどうかの判断
@cindex function safety
@cindex safety of functions

SESのようないくつかのメジャーモードは、ユーザーファイル内に格納された関数を呼び出します(@inforef{Top, ,ses}, for more
information on SESを参照してください)。 ユーザーファイルには素性があやふやな場合があります ---
初対面の人から受け取ったスプレッドシートかもしれず、会ったことのない誰かから受け取ったeメールかもしれません。そのため、ユーザーファイルに格納されたソースコードの関数を呼び出すのは、それが安全だと決定されるすまでは危険です。

@defun unsafep form &optional unsafep-vars
@var{form}が@dfn{安全(safe)}なLisp式の場合は@code{nil}、危険な場合はなぜその式が危険かもしれないのか説明するリストをreturnします。引数@var{unsafep-vars}は、この時点で一時的なバインドだと判っているシンボルのリストです。これは主に内部的な再帰呼び出しで使用されます。カレントバッファーは暗黙の引数になり、これはバッファーローカルなバインディングのリストを提供します。
@end defun

Being quick and simple, @code{unsafep} does a very light analysis and
rejects many Lisp expressions that are actually safe.  There are no known
cases where @code{unsafep} returns @code{nil} for an unsafe expression.
However, a safe Lisp expression can return a string with a @code{display}
property, containing an associated Lisp expression to be executed after the
string is inserted into a buffer.  This associated expression can be a
virus.  In order to be safe, you must delete properties from all strings
calculated by user code before inserting them into buffers.

@ignore
What is a safe Lisp expression?  Basically, it's an expression that
calls only built-in functions with no side effects (or only innocuous
ones).  Innocuous side effects include displaying messages and
altering non-risky buffer-local variables (but not global variables).

@table @dfn
@item Safe expression
@itemize
@item
An atom or quoted thing.
@item
A call to a safe function (see below), if all its arguments are
safe expressions.
@item
One of the special forms @code{and}, @code{catch}, @code{cond},
@code{if}, @code{or}, @code{prog1}, @code{prog2}, @code{progn},
@code{while}, and @code{unwind-protect}], if all its arguments are
safe.
@item
A form that creates temporary bindings (@code{condition-case},
@code{dolist}, @code{dotimes}, @code{lambda}, @code{let}, or
@code{let*}), if all args are safe and the symbols to be bound are not
explicitly risky (see @pxref{File Local Variables}).
@item
An assignment using @code{add-to-list}, @code{setq}, @code{push}, or
@code{pop}, if all args are safe and the symbols to be assigned are
not explicitly risky and they already have temporary or buffer-local
bindings.
@item
One of [apply, mapc, mapcar, mapconcat] if the first argument is a
safe explicit lambda and the other args are safe expressions.
@end itemize

@item Safe function
@itemize
@item
A lambda containing safe expressions.
@item
A symbol on the list @code{safe-functions}, so the user says it's safe.
@item
A symbol with a non-@code{nil} @code{side-effect-free} property.
@item
A symbol with a non-@code{nil} @code{safe-function} property.  The
value @code{t} indicates a function that is safe but has innocuous
side effects.  Other values will someday indicate functions with
classes of side effects that are not always safe.
@end itemize

The @code{side-effect-free} and @code{safe-function} properties are
provided for built-in functions and for low-level functions and macros
defined in @file{subr.el}.  You can assign these properties for the
functions you write.
@end table
@end ignore

@node Related Topics
@section 関数に関するその他トピック

  以下のテーブルは、関数呼び出しと関数定義に関連したことを行ういくつかの関数です。これらは別の場所で説明されているので、ここではクロスリファレンスを提供します。

@table @code
@item apply
@ref{Calling Functions}を参照してください。

@item autoload
@ref{Autoload}を参照してください。

@item call-interactively
@ref{Interactive Call}を参照してください。

@item called-interactively-p
@ref{Distinguish Interactive}を参照してください。

@item commandp
@ref{Interactive Call}を参照してください。

@item documentation
@ref{Accessing Documentation}を参照してください。

@item eval
@ref{Eval}を参照してください。

@item funcall
@ref{Calling Functions}を参照してください。

@item function
@ref{Anonymous Functions}を参照してください。

@item ignore
@ref{Calling Functions}を参照してください。

@item indirect-function
@ref{Function Indirection}を参照してください。

@item interactive
@ref{Using Interactive}を参照してください。

@item interactive-p
@ref{Distinguish Interactive}を参照してください。

@item mapatoms
@ref{Creating Symbols}を参照してください。

@item mapcar
@ref{Mapping Functions}を参照してください。

@item map-char-table
@ref{Char-Tables}を参照してください。

@item mapconcat
@ref{Mapping Functions}を参照してください。

@item undefined
@ref{Functions for Key Lookup}を参照してください。
@end table
