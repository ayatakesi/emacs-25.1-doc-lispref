@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================
@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-2016 Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@node Text
@chapter テキスト
@cindex text

  このチャプターでは、バッファー内のテキストを扱う関数を説明します。ほとんどはカレントバッファー内のテキストにたいして検査、挿入、削除を行い、ポイント位置やポイントに隣接するテキストを操作することが多々あります。その多くはインタラクティブ(interactive:
対話的)です。テキストを変更するすべての関数は、その変更にたいするundo(アンドゥ、取り消し)を提供します(@ref{Undo}を参照)。

  テキストに関連する関数の多くが、@var{start}および@var{end}という名前の引数として渡された、2つのバッファー位置により定義された、テキストのリージョンを操作します。これらの引数は、マーカー(@ref{Markers}を参照)か、数値的な文字位置(@ref{Positions}を参照)のいずれかであるべきです。これらの引数の順序は関係ありません。@var{start}がリージョンの終端で、@var{end}がリージョンの先頭であっても、何も問題はないのです。たとえば、@code{(delete-region
1 10)}と@code{(delete-region 10
1)}は等価です。@var{start}と@var{end}のいずれかが、バッファーのアクセス可能範囲の外部なら、@code{args-out-of-range}エラーがシグナルされます。インタラクティブな呼び出しでは、これらの引数にポイントとマークが使用されます。

@cindex buffer contents
  このチャプターを通じて、``テキスト(text)''とは(関係あるときは)そのプロパティも含めた、バッファー内の文字を意味します。ポイントは常に2つの文字の間にあり、カーソルはポイントの後の文字上に表示されることを覚えておいてください。

@menu
* Near Point::               ポイント付近のテキストを調べる。
* Buffer Contents::          一般的な方法によってテキストを調べる。
* Comparing Text::           バッファーの部分文字列を比較する。
* Insertion::                バッファーへの新たなテキストの追加。
* Commands for Insertion::   テキスト挿入のためのユーザーレベルコマンド。
* Deletion::                 バッファーからテキストを削除する。
* User-Level Deletion::      テキスト削除のためのユーザーレベルコマンド。
* The Kill Ring::            テキスト削除時にユーザーのためにそれを保存する場所。
* Undo::                     バッファーのテキストにたいする変更の取り消し。
* Maintaining Undo::         undo情報の有効と無効。情報をどれだけ保持するか制御する方法。
* Filling::                  明示的にフィルを行う関数。
* Margins::                  フィルコマンドにたいしてマージンを指定する方法。
* Adaptive Fill::            コンテキストからフィルプレフィクスを選択するAdaptive 
                               Fillモード。
* Auto Filling::             行ブレークにたいするauto-fillの実装方法。
* Sorting::                  バッファーの一部をソートする関数。
* Columns::                  水平位置の計算とその使用方法。
* Indentation::              インデントの挿入や調整のための関数。
* Case Changes::             バッファーの一部にたいする大文字小文字変換。
* Text Properties::          テキスト文字にたいするLispプロパティリストの追加。
* Substitution::             与ええられた文字の出現箇所を置換する。
* Registers::                レジスターの実装方法。レジスターに格納されたテキストや位置にアクセスする。
* Transposition::            バッファーの2つの部分を交換する。
* Decompression::            圧縮データの扱い。
* Base 64::                  Base64エンコーディングとの変換。
* Checksum/Hash::            暗号ハッシュの計算。
* Parsing HTML/XML::         HTMLおよびXMLの解析。
* Atomic Changes::           Installing several buffer changes atomically.
* Change Hooks::             テキスト変更時に実行する関数の指定。
@end menu

@node Near Point
@section ポイント周辺のテキストを調べる
@cindex text near point

  ポイント付近にある文字を調べるための関数が、数多く提供されています。簡単な関数のいくつかは、ここで説明します。@ref{Regexp
Search}の@code{looking-at}も参照してください。

以下の4つの関数においてバッファーの``先頭(beginning)''と``終端(end)''はそれぞれ、アクセス可能範囲の先頭と終端を意味します。

@defun char-after &optional position
この関数は、カレントバッファーの位置@var{position}(つまり直後)の文字をリターンする。@var{position}が、この目的にたいする範囲の外にある場合、すなわちバッファーの先頭より前、またはバッファーの終端以降にある場合、値は@code{nil}となる。@var{position}のデフォルトは、ポイントである。

以下の例では、バッファーの最初の文字が@samp{@@}であると仮定する:

@example
@group
(string (char-after 1))
     @result{} "@@"
@end group
@end example
@end defun

@defun char-before &optional position
この関数は、カレントバッファーの位置@var{position}の直前の文字をリターンする。@var{position}が、この目的にたいする範囲の外にある場合、すなわちバッファーの先頭より前、またはバッファーの終端より後にある場合、値は@code{nil}となる。@var{position}のデフォルトは、ポイントである。
@end defun

@defun following-char
この関数は、カレントバッファーのポイントの後にある文字をリターンする。これは@code{(char-after
(point))}と同様。ただし、ポイントがバッファー終端にある場合、@code{following-char}は0をリターンする。

ポイントが常に2文字間にあり、通常カーソルはポイント後の文字上に表示されることを思い出していただきたい。したがって、@code{following-char}がリターンする文字は、カーソル上の文字となる。

以下の例では、@samp{a}と@samp{c}の間にポイントがある。

@example
@group
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------
@end group

@group
(string (preceding-char))
     @result{} "a"
(string (following-char))
     @result{} "c"
@end group
@end example
@end defun

@defun preceding-char
この関数は、カレントバッファーのポイントの前の文字をリターンする。上記@code{following-char}の下の例を参照されたい。ポイントがバッファー先頭にある場合、@code{preceding-char}は0をリターンする。
@end defun

@defun bobp
この関数は、ポイントがバッファー先頭にあれば@code{t}をリターンする。ナローイングが効力をもつ場合、これはテキストのアクセス可能範囲の先頭を意味する。@ref{Point}の@code{point-min}も参照のこと。
@end defun

@defun eobp
この関数は、ポイントがバッファー終端にあれば@code{t}をリターンする。ナローイングが効力をもつ場合、これはテキストのアクセス可能範囲の終端を意味する。@ref{Point}の@code{point-max}も参照のこと。
@end defun

@defun bolp
この関数は、ポイントが行の先頭にあれば@code{t}をリターンする。@ref{Text
Lines}を参照のこと。バッファー(またはアクセス可能範囲)の先頭は、常に行の先頭とみなされる。
@end defun

@defun eolp
この関数は、ポイントが行の終端にあれば@code{t}をリターンする。@ref{Text
Lines}を参照のこと。バッファー(またはアクセス可能範囲)の終端は、常に行の先頭とみなされる。
@end defun

@node Buffer Contents
@section バッファーのコンテンツを調べる
@cindex buffer portion as string

  このセクションでは、Lispプログラムがバッファー内の任意の範囲のテキストを、文字列に変換するための関数を説明します。

@defun buffer-substring start end
この関数は、カレントバッファー内の位置@var{start}と@var{end}で定義されるリージョンのテキストのコピーを含む文字列をリターンする。引数がバッファーのアクセス可能範囲内の位置でない場合、@code{buffer-substring}は@code{args-out-of-range}エラーをリターンする。

以下の例では、Font-Lockモードが有効でないものとする:

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------
@end group

@group
(buffer-substring 1 10)
     @result{} "This is t"
@end group
@group
(buffer-substring (point-max) 10)
     @result{} "he contents of buffer foo\n"
@end group
@end example

コピーされるテキストが何らかのテキストプロパティをもっていた場合、それらのプロパティが属す文字とともに文字列にコピーされる。しかし、バッファー内のオーバーレイ(@ref{Overlays}を参照)、およびそれらのプロパティは無視されるため、コピーされない。

たとえば、Font-Lockモードが有効なら、以下のような結果を得るだろう:

@example
@group
(buffer-substring 1 10)
     @result{} #("This is t" 0 1 (fontified t) 1 9 (fontified t))
@end group
@end example
@end defun

@defun buffer-substring-no-properties start end
これは@code{buffer-substring}と同様だが、テキストプロパティはコピーせず、文字自体だけをコピーする点が異なる。@ref{Text
Properties}を参照のこと。
@end defun

@defun buffer-string
この関数は、カレントバッファーのアクセス可能範囲全体のコンテンツを、文字列としてリターンする。
@end defun

  If you need to make sure the resulting string, when copied to a different
location, will not change its visual appearance due to reordering of
bidirectional text, use the @code{buffer-substring-with-bidi-context}
function (@pxref{Bidirectional Display,
buffer-substring-with-bidi-context}).

@defun filter-buffer-substring start end &optional delete
この関数は、変数@code{filter-buffer-substring-function}により指定された関数を使用して、@var{start}と@var{end}の間のバッファーテキストをフィルターし、その結果をリターンする。

デフォルトのフィルター関数は時代遅れとなったラッパーフック@code{filter-buffer-substring-functions}、および同様に時代遅れとなった変数@code{buffer-substring-filters}を参照する。これら両者が@code{nil}なら、バッファーから未変更のテキスト、すなわち@code{buffer-substring}がリターンするであろうテキストをリターンする。

@var{delete}が非@code{nil}なら、この関数は@code{delete-and-extract-region}と同様、コピー後に@var{start}と@var{end}の間のテキストを削除する。

Lispコードは、killリング、Xクリップボード、レジスターのようなユーザーがアクセス可能なデータ構造内にコピーする際は@code{buffer-substring}、@code{buffer-substring-no-properties}、@code{delete-and-extract-region}のかわりにこの関数を使用するべきである。メジャーモードおよびマイナーモードは、バッファー外部にコピーするテキストを変更するために@code{filter-buffer-substring-function}を変更することができる。
@end defun

@defvar filter-buffer-substring-function
この変数の値は、実際の処理を行うために@code{filter-buffer-substring}が呼び出す関数である。その関数は、@code{filter-buffer-substring}と同じように3つの引数を受けとり、それらは@code{filter-buffer-substring}にドキュメントされているように扱われるべきである。関数は、フィルターされたテキストをリターン(およびオプションでソーステキストを削除)すること。
@end defvar

@noindent
以下の2つの変数は、@code{filter-buffer-substring-function}により時代遅れになりましたが、後方互換のために依然サポートされます。

@defvar filter-buffer-substring-functions
これは時代遅れとなったラッパーフックであり、このフックのメンバーは@var{fun}、@var{start}、@var{end}、@var{delete}の4つの引数を受け取る関数であること。@var{fun}は3つの引数(@var{start}、@var{end}、@var{delete})をとり、文字列をリターンする関数である。両者とも、引数@var{start}、@var{end}、@var{delete}は@code{filter-buffer-substring}のときと同様の意味をもつ。

1つ目のフック関数は@code{filter-buffer-substring}のデフォルトの処理と同じく@var{start}と@var{end}の間の(任意の@code{buffer-substring-filters}により処理された)バッファー部分文字列をリターンし、オプションでバッファーから元テキストを削除する関数で、それが@var{fun}に渡される。ほとんどの場合、フック関数は@var{fun}を1回だけ呼び出してから、その結果にたいして自身の処理を行う。次のフック関数はこれと等しい@var{fun}を受け取り、順次それが繰り返されていく。実際のリターン値は、すべてのフック関数が順次処理した結果である。
@end defvar

@defvar buffer-substring-filters
時代遅れとなったこの変数の値は、文字列を唯一の引数ちして別の文字列をリターンする関数のリストであること。デフォルトの@code{filter-buffer-substring}関数は、バッファー部分文字列をこのリストの1つ目の関数に渡し、そのリターン値を次の関数に渡して、それぞれの関数にたいしてこれが順次繰り返される。最後の関数のリターン値は、@code{filter-buffer-substring-functions}に渡される。
@end defvar

@defun current-word &optional strict really-word
この関数は、ポイント位置またはその付近のシンボル(または単語)を、文字列としてリターンする。リターン値にはテキストプロパティは含まれない。

オプション引数@var{really-word}が非@code{nil}なら単語、それ以外はシンボル(単語文字とシンボル構成文字の両方を含む)を探す。

オプション引数@var{strict}が非@code{nil}の場合、ポイントは単語(またはシンボル)の内部にあるか隣接しなければならない。そこに単語(またはシンボル)がなければ、この関数は@code{nil}をリターンする。@var{strict}が@code{nil}なら、ポイントと同一行にある近接する単語(またはシンボル)が許容される。
@end defun

@defun thing-at-point thing &optional no-properties
ポイントに隣接または周辺にある@var{thing}を、文字列としてリターンする。

引数@var{thing}は、構文エンティティの種別を指定するシンボルである。可能なシンボルとしては@code{symbol}、@code{list}、@code{sexp}、@code{defun}、@code{filename}、@code{url}、@code{word}、@code{sentence}、@code{whitespace}、@code{line}、@code{page}、その他が含まれる。

When the optional argument @var{no-properties} is non-@code{nil}, this
function strips text properties from the return value.

@example
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------

(thing-at-point 'word)
     @result{} "Peace"
(thing-at-point 'line)
     @result{} "Gentlemen may cry ``Peace! Peace!,''\n"
(thing-at-point 'whitespace)
     @result{} nil
@end example
@end defun

@node Comparing Text
@section テキストの比較
@cindex comparing buffer text

  この関数により、最初にバッファー内のテキストを文字列内にコピーすることなく、バッファー内のテキスト断片を比較することが可能になります。

@defun compare-buffer-substrings buffer1 start1 end1 buffer2 start2 end2
この関数により、1つのバッファー、または2つの異なるバッファーの、2つの部分文字列(substrings)を比較できる。最初の3つの引数は、バッファーとそのバッファー内の2つの位置を与えることにより、1つの部分文字列を指定する。最後の3つの引数は、同様の方法によりもう一方の部分文字列を指定する。@var{buffer1}と@var{buffer2}のいずれか、または両方にたいして、カレントバッファーを意味する@code{nil}を使用できる。

1つ目の部分文字列が2つ目の部分文字列より小なら負、大なら正、等しければ値は0となる。結果の絶対値は、部分文字列内で最初に異なる文字のインデックスに1を和した値である。

@code{case-fold-search}が非@code{nil}なら、この関数は大文字小文字の違いを無視する。テキストプロパティは常に無視される。

カレントバッファー内にテキスト@w{@samp{foobarbar
haha!rara!}}があるとしよう。そしてこの例では2つの部分文字列が@samp{rbar
}と@samp{rara!}であるとする。1つ目の文字列の2つ目の文字が大きいので、値は2となる。

@example
(compare-buffer-substrings nil 6 11 nil 16 21)
     @result{} 2
@end example
@end defun

@node Insertion
@section テキストの挿入
@cindex insertion of text
@cindex text insertion

@cindex insertion before point
@cindex before point, insertion
  @dfn{挿入(insertion)}とは、バッファーへの新たなテキストの追加を意味します。テキストはポイント位置、すなわちポイント前の文字とポイント後の文字の間に追加されます。挿入関数は挿入されたテキストの後にポイントを残しますが、前にポイントを残す関数もいくつかあります。前者の挿入を@dfn{ポイント後挿入(after
point)}、後者を@dfn{ポイント前挿入(before point)}と呼びます。

  挿入により、挿入位置の後にあったマーカーは、テキストを取り囲むように移動されます(@ref{Markers}を参照)。マーカーは挿入箇所をさしている際は、挿入によるマーカー再配置の有無は、そのマーカーの挿入タイプに依存します(@ref{Marker
Insertion
Types}を参照)。@code{insert-before-markers}のような特定のスペシャル関数は、マーカーの挿入タイプとは関係なく、挿入されたテキストの後にそのようなマーカーすべてを再配置します。

  カレントバッファーが読み取り専用(@ref{Read Only Buffers}を参照)、または読み取り専用テキスト(@ref{Special
Properties}を参照)を挿入しようとした場合、挿入関数はエラーをシグナルします。

  以下の関数は、文字列およびバッファーからプロパティとともにテキスト文字をコピーします。挿入される文字は、コピー元の文字と完全に同一のプロパティをもちます。それとは対照的に、文字列やバッファーの一部ではない個別の引数として指定された文字は、隣接するテキストからテキストプロパティを継承します。

  テキストが文字列またはバッファー由来の場合、マルチバイトバッファーに挿入するために、挿入関数はユニバイトからマルチバイトへの変換、およびその逆も行います。しかし、たとえカレントバッファーがマルチバイトバッファーであったとしても、コード128から255までのユニバイトはマルチバイトに変換しません。@ref{Converting
Representations}を参照してください。

@defun insert &rest args
この関数は、文字列および/または1つ以上の文字@var{args}を、カレントバッファーのポイント位置に挿入して、ポイントを前方に移動する。言い換えると、ポイントの前にテキストを挿入する。すべての@var{args}が文字列が文字列と文字のいずれでもない場合は、エラーをシグナルする。値は@code{nil}。
@end defun

@defun insert-before-markers &rest args
この関数は、文字列および/または1つ以上の文字@var{args}を、カレントバッファーのポイント位置に挿入して、ポイントを前方に移動する。すべての@var{args}が文字列が文字列と文字のいずれでもない場合は、エラーをシグナルする。値は@code{nil}。

他の挿入関数と異なり、この関数は挿入されたテキストの後を指すように、まずマーカーが挿入位置を指すように再配置する。挿入位置からオーバーレイが開始される場合、挿入されたテキストはそのオーバーレイの外側に出される。空でないオーバーレイが挿入位置で終わる場合、挿入されたテキストはそのオーバーレイの内側に入れられる。
@end defun

@deffn Command insert-char character &optional count inherit
このコマンドは、カレントバッファーのポイントの前に、@var{character}のインスタンスを@var{count}個挿入する。引数@var{count}は整数、@var{character}は文字でなければならない。

インタラクティブに呼び出された際は、このコマンドは@var{character}にたいしてコードポイントかUnicode名による入力を求める。@ref{Inserting
Text,,, emacs, The GNU Emacs Manual}を参照のこと。

この関数は、たとえカレントバッファーがマルチバイトバッファーであっても、コード128から255のユニバイト文字をマルチバイト文字に変換しない。@ref{Converting
Representations}を参照のこと。

@var{inherit}が非@code{nil}の場合、挿入された文字は挿入位置前後の2文字から、ステッキーテキストプロパティ(sticky text
properties)を継承する。@ref{Sticky Properties}を参照のこと。
@end deffn

@defun insert-buffer-substring from-buffer-or-name &optional start end
この関数は、カレントバッファーのポイント前に、バッファー@var{from-buffer-or-name}の一部を挿入する。挿入されるテキストは、@var{start}(を含む)から@var{end}(を含まない)の間のリージョン(これらの引数のデフォルトは、そのバッファーのアクセス可能範囲の先頭と終端)である。この関数は@code{nil}をリターンする。

以下の例では、バッファー@samp{bar}をカレントバッファーとしてフォームを実行する。バッファー@samp{bar}は、最初は空であるものとする。

@example
@group
---------- Buffer: foo ----------
We hold these truths to be self-evident, that all
---------- Buffer: foo ----------
@end group

@group
(insert-buffer-substring "foo" 1 20)
     @result{} nil

---------- Buffer: bar ----------
We hold these truth@point{}
---------- Buffer: bar ----------
@end group
@end example
@end defun

@defun insert-buffer-substring-no-properties from-buffer-or-name &optional start end
これは@code{insert-buffer-substring}と似ているが、テキストプロパティをコピーしない点が異なる。
@end defun

  テキスト挿入に加えて、隣接するテキストからテキストプロパティを継承する他の関数については、@ref{Sticky
Properties}を参照のこと。インデント関数により挿入された空白文字も、テキストプロパティを継承する。

@node Commands for Insertion
@section ユーザーレベルの挿入コマンド

  このセクションでは、テキスト挿入のための高レベルコマンド、ユーザーによる使用を意図しているがLispプログラムでも有用なコマンドについて説明します。

@deffn Command insert-buffer from-buffer-or-name
このコマンドは、@var{from-buffer-or-name}(存在しなければならない)のアクセス可能範囲全体を、カレントバッファーのポイントの後に挿入する。マークは挿入されたテキストの後に残される。値は@code{nil}。
@end deffn

@deffn Command self-insert-command count
@cindex character insertion
@cindex self-insertion
このコマンドは、タイプされた最後の文字を挿入する。これをポイント前で@var{count}回繰り返して、@code{nil}をリターンする。ほとんどのプリント文字が、このコマンドにバインドされる。通常の使用では、@code{self-insert-command}はEmacsでもっとも頻繁に呼び出される関数だが、Lispプログラムではそれをキーマップにインストールする場合を除き、使用されるのは稀である。

インタラクティブな呼び出しでは、@var{count}は数プレフィクス引数である。

@c FIXME: This variable is obsolete since 23.1.
自己挿入では、入力文字は@code{translation-table-for-input}を通じて変換される。@ref{Translation of
Characters}を参照のこと。

これは、入力文字がテーブル@code{auto-fill-chars}内にあり、@code{auto-fill-function}が非@code{nil}なら、常にそれを呼び出す(@ref{Auto
Filling}を参照)。

@c Cross refs reworded to prevent overfull hbox.  --rjc 15mar92
This command performs abbrev expansion if Abbrev mode is enabled and the
inserted character does not have word-constituent syntax.  (@xref{Abbrevs},
and @ref{Syntax Class Table}.)  It is also responsible for calling
@code{blink-paren-function} when the inserted character has close
parenthesis syntax (@pxref{Blinking}).

@vindex post-self-insert-hook
このコマンドは最後に、フック@code{post-self-insert-hook}を実行する。たとえば、タイプされたテキストにしたがい自動インデントするために、これを使用できる。

@code{self-insert-command}の標準的な定義にたいして、独自の定義による置き換えを試みてはならない。エディターコマンドループは、このコマンドを特別に扱うからだ。
@end deffn

@deffn Command newline &optional number-of-newlines
このコマンドは、カレントバッファーのポイントの前に、改行を挿入する。@var{number-of-newlines}が与えられた場合は、その個数の改行文字が挿入される。

@cindex newline and Auto Fill mode
この関数は、カレント列数が@code{fill-column}より大、かつ@var{number-of-newlines}が@code{nil}なら、@code{auto-fill-function}を呼び出す。@code{auto-fill-function}が通常行うのは改行の挿入ではり、最終的な結果としては、ポイント位置と、その行のより前方の位置という、2つの異なる箇所に改行を挿入する。@var{number-of-newlines}が非@code{nil}なら、@code{newline}はauto-fillを行わない。

このコマンドは、左マージンが0でなければ、左マージンにインデントする。@ref{Margins}を参照のこと。

リターン値は@code{nil}。インタラクティブな呼び出しでは、@var{count}は数プレフィクス引数である。
@end deffn

@defvar overwrite-mode
この変数は、overwriteモードに効力をもつかどうかを制御する。値は@code{overwrite-mode-textual}、@code{overwrite-mode-binary}、または@code{nil}であること。@code{overwrite-mode-textual}はテキスト的なoverwriteモード(改行とタブを特別に扱う)、@code{overwrite-mode-binary}はバイナリーoverwriteモード(改行とタブを普通の文字と同様に扱う)を指定する。
@end defvar

@node Deletion
@section テキストの削除
@cindex text deletion

@cindex deleting text vs killing
  削除とは、バッファー内のテキストの一部を、killリングに保存せずに取り除くことを意味します。(@ref{The Kill
Ring}を参照)。削除されたテキストをyankすることはできませんが、undoメカニズム(@ref{Undo}を参照)を使用すれば再挿入が可能です。特別なケースにおいては、killリングにテキストの保存を行う削除関数がいくつかあります。

  削除関数はすべて、カレントバッファーにたいして処理を行います。

@deffn Command erase-buffer
この関数は、カレントバッファーのテキスト全体(アクセス可能範囲だけでは@emph{ない})を削除してバッファーが読み取り専用なら@code{buffer-read-only}、バッファー内の一部テキストが読み取り専用の場合は@code{text-read-only}をシグナルする。それ以外では、確認なしでテキストを削除する。リターン値は@code{nil}。

Normally, deleting a large amount of text from a buffer inhibits further
auto-saving of that buffer because it has shrunk.  However,
@code{erase-buffer} does not do this, the idea being that the future text is
not really related to the former text, and its size should not be compared
with that of the former text.
@end deffn

@deffn Command delete-region start end
このコマンドは、カレントバッファー内の位置@var{start}から@var{end}までの間のテキストを削除して、@code{nil}をリターンする。削除されるリージョン内にポイントがある場合、リージョン削除後のポイントの値は@var{start}になる。それ以外の場合は、マーカーが行うようにポイントはテキストを取り囲むように再配置される。
@end deffn

@defun delete-and-extract-region start end
この関数は、カレントバッファー内の位置@var{start}から@var{end}までの間のテキストを削除して、削除されたテキストを含む文字列をリターンする。

削除されるリージョン内にポイントがある場合、リージョン削除後のポイントの値は@var{start}になる。それ以外の場合は、マーカーが行うようにポイントはテキストを取り囲むように再配置される。
@end defun

@deffn Command delete-char count &optional killp
このコマンドは、ポイント直後の@var{count}文字、@var{count}が負なら直前の@var{count}文字を削除する。@var{killp}が非@code{nil}なら、削除した文字をkillリングに保存する。

インタラクティブな呼び出しでは、@var{count}は数プレフィクス引数、@var{killp}は未処理プレフィクス引数(unprocessed
prefix
argument)である。すなわち、プレフィクス引数が与えられた場合、そのテキストはkillリングに保存され、与えられなければ、1文字が削除され、それはkillリングに保存されない。

リターン値は常に@code{nil}である。
@end deffn

@deffn Command delete-backward-char count &optional killp
@cindex deleting previous char
このコマンドは、ポイント直前の@var{count}文字、@var{count}が負なら直後の@var{count}文字を削除する。@var{killp}が非@code{nil}なら、削除した文字をkillリングに保存する。

インタラクティブな呼び出しでは、@var{count}は数プレフィクス引数、@var{killp}は未処理プレフィクス引数(unprocessed
prefix
argument)である。すなわち、プレフィクス引数が与えられた場合、そのテキストはkillリングに保存され、与えられなければ、1文字が削除され、それはkillリングに保存されない。

リターン値は常に@code{nil}である。
@end deffn

@deffn Command backward-delete-char-untabify count &optional killp
@cindex tab deletion
このコマンドは、タブをスペースに変換しながら、後方に@var{count}文字を削除する。次に削除する文字がタブなら、まず適正な位置を保つような数のスペースに変換してから、それらのうちのスペース1つをタブのかわりに削除する。@var{killp}が非@code{nil}なら、このコマンドは削除した文字をkillリングに保存する。

タブからスペースへの変換は、@var{count}が正の場合のみ発生する。負の場合は、ポイント後の@minus{}@var{count}文字が、正確に削除される。

インタラクティブな呼び出しでは、@var{count}は数プレフィクス引数、@var{killp}は未処理プレフィクス引数(unprocessed
prefix
argument)である。すなわち、プレフィクス引数が与えられた場合、そのテキストはkillリングに保存され、与えられなければ、1文字が削除され、それはkillリングに保存されない。

リターン値は常に@code{nil}である。
@end deffn

@defopt backward-delete-char-untabify-method
このオプションは、@code{backward-delete-char-untabify}が空白文字を扱う方法を指定する。可能な値には@code{untabify}(タブを個数分のスペースに変換してスペースを1つ削。これがデフォルト除)、@code{hungry}(1コマンドでポイント前のタブとスペースすべてを削除する)、@code{all}(ポイント前のタブとスペース、および改行すべてを削除する)、@code{nil}(空白文字にたいして特に何もしない)。
@end defopt

@node User-Level Deletion
@section ユーザーレベルの削除コマンド

  このセクションでは、主にユーザーにたいして有用なものの、Lispプログラムでも有用な、テキストを削除するための高レベルんｑコマンドを説明します。

@deffn Command delete-horizontal-space &optional backward-only
@cindex deleting whitespace
この関数は、ポイント近辺のすべてのスペースとタブを削除する。リターン値は@code{nil}。

@var{backward-only}が非@code{nil}の場合、この関数はポイント前のスペースとタブを削除するがポイント後のスペースとタブは削除しない。

以下の例では、各行ごとに、2番目と3番目の間にポイントを置いて、@code{delete-horizontal-space}を4回呼び出している。

@example
@group
---------- Buffer: foo ----------
I @point{}thought
I @point{}     thought
We@point{} thought
Yo@point{}u thought
---------- Buffer: foo ----------
@end group

@group
(delete-horizontal-space)   ; @r{Four times.}
     @result{} nil

---------- Buffer: foo ----------
Ithought
Ithought
Wethought
You thought
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command delete-indentation &optional join-following-p
この関数は、ポイントのある行を、その前の行に結合(join)する。結合においては、すべての空白文字を削除、特定のケースにおいてはそれらを1つのスペースに置き換える。@var{join-following-p}が非@code{nil}なら、@code{delete-indentation}はかわりに後続行と結合を行う。この関数は@code{nil}をリターンする。

fillプレフィクスがあり、結合される2つ目の行もそのプレフィクスで始まる場合、行の結合前に@code{delete-indentation}はそのfillプレフィクスを削除する。@ref{Margins}を参照のこと。

以下の例では、@samp{events}で始まる行にポイントがあり、前の行の末尾に1つ以上のスペースが存在しても、違いは生じない。

@smallexample
@group
---------- Buffer: foo ----------
When in the course of human
@point{}    events, it becomes necessary
---------- Buffer: foo ----------
@end group

(delete-indentation)
     @result{} nil

@group
---------- Buffer: foo ----------
When in the course of human@point{} events, it becomes necessary
---------- Buffer: foo ----------
@end group
@end smallexample

行の結合後に、結合点に単一のスペースを残すか否かを決定するのは、関数@code{fixup-whitespace}の責任である。
@end deffn

@deffn Command fixup-whitespace
この関数は、ポイントを取り囲むすべての水平スペースを、コンテキストに応じて1つのスペースまたはスペースなしに置き換える。リターン値は@code{nil}。

行の先頭または末尾において、スペースの適正な数は0である。閉じカッコ構文(close parenthesis
syntax)の前の文字、開きカッコの後の文字、式プレフィクス構文(expression-prefix
syntax)においても、スペースの適正な数は0である。それ以外では、スペースの適正な数は1である。@ref{Syntax Class
Table}を参照のこと。

以下の例では、最初に1行目の単語@samp{spaces}の前にポイントがある状態で、@code{fixup-whitespace}を呼び出している。2回目の呼び出しでは、@samp{(}の直後にポイントがある。

@smallexample
@group
---------- Buffer: foo ----------
This has too many     @point{}spaces
This has too many spaces at the start of (@point{}   this list)
---------- Buffer: foo ----------
@end group

@group
(fixup-whitespace)
     @result{} nil
(fixup-whitespace)
     @result{} nil
@end group

@group
---------- Buffer: foo ----------
This has too many spaces
This has too many spaces at the start of (this list)
---------- Buffer: foo ----------
@end group
@end smallexample
@end deffn

@deffn Command just-one-space &optional n
@comment !!SourceFile simple.el
このコマンドは、ポイントを取り囲むすべてのスペースを1つのスペース、または@var{n}が指定された場合は@var{n}個のスペースで置き換える。リターン値は@code{nil}。
@end deffn

@c There is also cycle-spacing, but I cannot see it being useful in
@c Lisp programs, so it is not mentioned here.

@deffn Command delete-blank-lines
この関数は、ポイントを取り囲む空行を削除する。ポイントが前後に1行以上の空行がある空の行にある場合は、1行を除きそれらすべてを削除する。ポイントが孤立した空行にあるなら、その行を削除する。ポイントが空でない行にあるなら、その直後にあるすべての空白を削除する。

@c and the Newline character?
空行とは、タブまたはスペースのみを含む行として定義される。

@code{delete-blank-lines}は@code{nil}をリターンする。
@end deffn

@deffn Command delete-trailing-whitespace &optional start end
@var{start}と@var{end}で定義されるリージョン内の、末尾の空白文字を削除する。

このコマンドは、リージョン内の各行の最後の非空白文字後にある空白文字を削除する。

If this command acts on the entire buffer (i.e., if called interactively
with the mark inactive, or called from Lisp with @var{end} @code{nil}), it
also deletes all trailing lines at the end of the buffer if the variable
@code{delete-trailing-lines} is non-@code{nil}.
@end deffn

@node The Kill Ring
@section killリング
@cindex kill ring

  @dfn{Kill functions} delete text like the deletion functions, but save it so
that the user can reinsert it by @dfn{yanking}.  Most of these functions
have @samp{kill-} in their name.  By contrast, the functions whose names
start with @samp{delete-} normally do not save text for yanking (though they
can still be undone); these are deletion functions.

  ほとんどのkillコマンドは、主にインタラクティブな使用を意図しており、ここでは説明しません。ここで説明するのは、そのようなコマンドの記述に使用されるために提供される関数です。テキストをkillするために、これらのカを使用できます。Lisp関数の内部的な目的のためにテキストの削除を要するときは、killリング内のコンテンツに影響を与えないように、通常は削除関数を使用するべきでしょう。@ref{Deletion}を参照してください。

  killされたテキストは、後のyank用に@dfn{killリング(kill
ring)}内に保存されます。これは、直前のkillだけでなく直近のkillのいくつかを保持するリストです。yankがそれをサイクル順に要素をもつリストとして扱うので、これを``リング(ring)''と称しています。このリストは変数@code{kill-ring}に保持されており、リスト用の通常関数で操作可能です。このセクションで説明する、これをリングとして扱うために特化された関数も存在します。

  Some people think this use of the word ``kill'' is unfortunate, since it
refers to operations that specifically @emph{do not} destroy the entities
killed.  This is in sharp contrast to ordinary life, in which death is
permanent and killed entities do not come back to life.  Therefore, other
metaphors have been proposed.  For example, the term ``cut ring'' makes
sense to people who, in pre-computer days, used scissors and paste to cut up
and rearrange manuscripts.  However, it would be difficult to change the
terminology now.

@menu
* Kill Ring Concepts::       killリング内のテキストがどのように見えるか。
* Kill Functions::           テキストをkillする関数。
* Yanking::                  yankが行われる方法。
* Yank Commands::            killリングにアクセスするコマンド。
* Low-Level Kill Ring::      killリングアクセス用の関数および変数。
* Internals of Kill Ring::   killリングのデータを保持する変数。
@end menu

@node Kill Ring Concepts
@subsection killリングの概念

  killリングは、リスト内でもっとも最近にkillされたテキストが先頭になるように、killされたテキストを記録します。たとえば、短いkillリングは以下のようになるでしょう:

@example
("some text" "a different piece of text" "even older text")
@end example

@noindent
このリストのエントリー長が@code{kill-ring-max}に達すると、新たなエントリー追加により最後のエントリーが自動的に削除されます。

  killコマンドが他のコマンドと混ざり合っているときは、各killコマンドはkillリング内に新たなエントリーを作成します。連続する複数のkillコマンドは単一のkillリングエントリーを構成します。これは1つの単位としてyankされます。2つ目以降の連続するkillコマンドは、最初のkillにより作成されたエントリーにテキストを追加します。

  For yanking, one entry in the kill ring is designated the front of the
ring.  Some yank commands rotate the ring by designating a different element
as the front.  But this virtual rotation doesn't change the list
itself---the most recent entry always comes first in the list.

@node Kill Functions
@subsection killリングのための関数

  @code{kill-region} is the usual subroutine for killing text.  Any command
that calls this function is a kill command (and should probably have
@samp{kill} in its name).  @code{kill-region} puts the newly killed text in
a new element at the beginning of the kill ring or adds it to the most
recent element.  It determines automatically (using @code{last-command})
whether the previous command was a kill command, and if so appends the
killed text to the most recent entry.

@cindex filtering killed text
  The commands described below can filter the killed text before they save it
in the kill ring.  They call @code{filter-buffer-substring} (@pxref{Buffer
Contents}) to perform the filtering.  By default, there's no filtering, but
major and minor modes and hook functions can set up filtering, so that text
saved in the kill ring is different from what was in the buffer.

@deffn Command kill-region start end &optional region
This function kills the stretch of text between @var{start} and @var{end};
but if the optional argument @var{region} is non-@code{nil}, it ignores
@var{start} and @var{end}, and kills the text in the current region
instead.  The text is deleted but saved in the kill ring, along with its
text properties.  The value is always @code{nil}.

In an interactive call, @var{start} and @var{end} are point and the mark,
and @var{region} is always non-@code{nil}, so the command always kills the
text in the current region.

バッファーまたはテキストが読み取り専用の場合、@code{kill-region}は同じようにkillリングを変更後、バッファーを変更せずにエラーをシグナルする。これは、ユーザーが一連のkillコマンドで、読み取り専用バッファーからkillリングにテキストをコピーするのに有用である。
@end deffn

@defopt kill-read-only-ok
このオプションが非@code{nil}なら、バッファーやテキストが読み取り専用でも、@code{kill-region}はエラーをシグナルしない。かわりに、バッファーを変更せずにkillリングを更新して、単にリターンする。
@end defopt

@deffn Command copy-region-as-kill start end &optional region
This function saves the stretch of text between @var{start} and @var{end} on
the kill ring (including text properties), but does not delete the text from
the buffer.  However, if the optional argument @var{region} is
non-@code{nil}, the function ignores @var{start} and @var{end}, and saves
the current region instead.  It always returns @code{nil}.

In an interactive call, @var{start} and @var{end} are point and the mark,
and @var{region} is always non-@code{nil}, so the command always saves the
text in the current region.

このコマンドは、後続のkillコマンドが同一のkillリングエントリーに追加しないよう、@code{this-command}に@code{kill-region}をセットしない。
@end deffn

@node Yanking
@subsection yank

  yankとは、killリングからテキストを挿入するものの、単なる挿入ではないことを意味します。@code{yank}および関連するコマンドは、テキスト挿入前に特別な処理を施すために、@code{insert-for-yank}を使用します。

@defun insert-for-yank string
この関数は@code{insert}と同様に機能するが、結果をカレントバッファーに挿入する前に、テキストプロパティ@code{yank-handler}、同様に変数@code{yank-handled-properties}および@code{yank-excluded-properties}に応じて@var{string}内のテキストを処理する点が異なる。
@end defun

@defun insert-buffer-substring-as-yank buf &optional start end
この関数は@code{insert-buffer-substring}と似ているが、@code{yank-handled-properties}および@code{yank-excluded-properties}に応じてテキストを処理する点が異なる(これは@code{yank-handler}プロパティを処理しないが、いずれにせよバッファー内のテキストでは通常は発生しない)。
@end defun

@c FIXME: Add an index for yank-handler.
  文字列の一部またはすべてにテキストプロパティ@code{yank-handler}をputした場合、@code{insert-for-yank}が文字列を挿入する方法が変更されます。文字列の別の箇所が異なる@code{yank-handler}の値をもつ場合(比較は@code{eq}で行われる)、部分文字列はそれぞれ個別に処理されます。プロパティ値は以下の形式からなる1から4要素のリストでなければなりません(2番目以降の要素は省略されるかもしれない):

@example
(@var{function} @var{param} @var{noexclude} @var{undo})
@end example

  以下は、これらの要素が何を行うかです:

@table @var
@item function
@var{function}が非@code{nil}なら、@code{insert}のかわりに文字列を挿入するために、挿入する文字列を単一の引数として、その関数が呼び出される。

@item param
非@code{nil}の@var{param}が与えられた場合、それは@var{string}(または処理される@var{string}の部分文字列)を置き換えるオブジェクトとして@var{function}(または@code{insert})に渡される。たとえば@var{function}が@code{yank-rectangle}なら、@var{param}は矩形(rectangle)として挿入されるべき文字列のリストになる。

@item noexclude
非@code{nil}の@var{noexclude}が与えられた場合は、挿入される文字列にたいする@code{yank-handled-properties}および@code{yank-excluded-properties}の通常の動作を無効にする。

@item undo
非@code{nil}の@var{undo}が与えられた場合、それはカレントオブジェクトの挿入をundoするために@code{yank-pop}が呼び出す関数である。この関数は、カレントリージョンのstartとendの、2つの引数で呼び出される。@var{function}は@code{yank-undo-function}をセットすることにより、@var{undo}の値をオーバーライドできる。
@end table

@cindex yanking and text properties
@defopt yank-handled-properties
この変数は、yankされるテキストの状態を処理するスペシャルテキストプロパティを指定する。これは(通常の方法、または@code{yank-handler}を通じた)テキスト挿入後、@code{yank-excluded-properties}が効力をもつ前に効果を発揮する。

値は、要素が@code{(@var{prop}
.
@var{fun})}であるようなalistであること。alistの各要素は、順番に処理される。挿入されるテキストはテキスト範囲にたいして、テキストプロパティが@var{prop}と@code{eq}なものがスキャンされる。そのような範囲には、そのプロパティの値、そのテキストの開始と終了の位置という、3つの引数により@var{fun}が呼び出される。
@end defopt

@defopt yank-excluded-properties
この変数の値は、挿入されるテキストから削除するための、プロパティのリストである。デフォルト値には、マウスに応答したりキーバインディングの指定を引き起こすテキストのような、煩わしい結果をもたらすかもしれないプロパティが含まれる。これは、@code{yank-handled-properties}の後に効果を発揮する。
@end defopt


@node Yank Commands
@subsection yankのための関数

  このセクションでは、yank用の高レベルなコマンドを説明します。これらのコマンドは主にユーザー用に意図されたものですが、Lispプログラム内での使用にたいしても有用です。@code{yank}および@code{yank-pop}はどちらも、変数@code{yank-excluded-properties}およびテキストプロパティ@code{yank-handler}にしたがいます(@ref{Yanking}を参照)。

@deffn Command yank &optional arg
@cindex inserting killed text
このコマンドは、killリングの先頭にあるテキストを、ポイントの前に挿入する。これは@code{push-mark}(@ref{The
Mark}を参照)を使用して、そのテキストの先頭にマークをセットする。

@var{arg}が非@code{nil}のリスト(これはユーザーがインタラクティブに数字を指定せずに@kbd{C-u}をタイプ時に発生する)なら、@code{yank}は上述のようにテキストを挿入するが、ポイントはyankされたテキストの前、マークはyankされたテキストの後に置かれる。

@var{arg}が数字なら、@code{yank}は@var{arg}番目に最近killされたテキスト、すなわちkillリングリストの@var{arg}番目の要素を挿入する。この順番は、コマンドの目的にたいして1番目の要素としてみなされる、リスト先頭の要素から巡回的に数えられる。

@code{yank}は、それが他のプログラムから提供されるテキストを使用しないかぎり(使用する場合はそのテキストをkillリングにpushする)、killリングのコンテンツを変更しない。しかし、@var{arg}が非1の整数の場合は、killリングを転回(rotate)してyankされるテキストをリング先頭に置く。

@code{yank}は@code{nil}をリターンする。
@end deffn

@deffn Command yank-pop &optional arg
このコマンドは、killリング上の正にyankされたばかりのエントリーを、killリングの別エントリーで置き換える。

このコマンドは、@code{yank}または別の@code{yank-pop}の直後のみ許される。そのような際、そのリージョンにはyankにより正に挿入されたテキストが含まれる。@code{yank-pop}はそのテキストを削除して、killされた別のテキスト片をその位置に挿入する。そのテキスト片はすでにkillリング内のどこか別の箇所にあるので、これは削除されたテキストをkillリングに追加しない。しかし、新たにyankされたテキストが先頭になるよう、killリングの転回は行う。

@var{arg}が@code{nil}なら、置換テキストはkillリングの1つ前の要素である。@var{arg}が数字なら、置換テキストはkillリングの@var{arg}個前の要素である。@var{arg}が負の場合は、より最近のkillが置換される。

killリング内のkillされたエントリーの順序はラップする。すなわちもっとも古いkillの次にもっとも新しいkill、もっとも新しいkillの前はもっとも古いkillとなる。

リターン値は常に@code{nil}である。
@end deffn

@defvar yank-undo-function
この変数が非@code{nil}の場合、関数@code{yank-pop}は前の@code{yank}または@code{yank-pop}により挿入されたテキストを削除するために、@code{delete-region}のかわりにこの変数の値を使用する。値は、カレントリージョンの開始と終了という、2つの引数をとる関数でなければならない。

関数@code{insert-for-yank}は、テキストプロパティ@code{yank-handler}の要素@var{undo}に対応して、この変数を自動的にセットする。
@end defvar

@node Low-Level Kill Ring
@subsection 低レベルのkillリング

  以下の関数および変数は、killリングにたいして低レベルなアクセスを提供しますが、それらはウィンドウシステムの選択(@ref{Window System
Selections}を参照)との相互作用にも留意するので、Lispプログラム内での使用に関しても依然として有用です。

@defun current-kill n &optional do-not-move
The function @code{current-kill} rotates the yanking pointer, which
designates the front of the kill ring, by @var{n} places (from newer kills
to older ones), and returns the text at that place in the ring.

オプションの第2引数@var{do-not-move}が非@code{nil}なら、@code{current-kill}はyankポインターを変更しない。カレントyankポインターから、@var{n}個目のkillを単にリターンする。

@var{n}が0の場合、それは最新のkillの要求を意味しており、@code{current-kill}はkillリング照会前に@code{interprogram-paste-function}(以下参照)の値を呼び出す。その値が関数で、かつそれが文字列または複数の文字列からなるリストをリターンした場合、@code{current-kill}はその文字列をkillリング上にpushして、最初の文字列をリターンする。これは@var{do-not-move}の値に関わらず、@code{interprogram-paste-function}がリターンする最初の文字列のkillリングエントリーを指すように、yankポインターのセットも行う。それ以外では、@code{current-kill}は@var{n}にたいする0値を特別に扱うことはなく、yankポインターが指すエントリーをリターンし、yankポインターの移動は行わない。
@end defun

@defun kill-new string &optional replace
この関数は、テキスト@var{string}をkillリング上にpushして、yankポインターがそれを指すようにセットする。それが適切なら、もっとも古いエントリーを破棄する。@code{interprogram-cut-function}(以下参照)の呼び出しも行う。

@var{replace}が非@code{nil}なら、@code{kill-new}はkillリング上に@var{string}をpushせずに、killリングの1つ目の要素を@var{string}に置き換える。
@end defun

@defun kill-append string before-p
この関数は、killリング内の最初のエントリーにテキスト@var{string}を追加して、その結合されたエントリーを指すようにyankポインターをセットする。通常はそのエントリーの終端に@var{string}が追加されるが、@var{before-p}が非@code{nil}ならエントリーの先頭に追加される。この関数は、@code{interprogram-cut-function}(以下参照)の呼び出しも行う。
@end defun

@defvar interprogram-paste-function
この変数は、他のプログラムからkillリングへkillされたテキストを転送する方法を提供する。値は@code{nil}、または引数のない関数であること。

If the value is a function, @code{current-kill} calls it to get the most
recent kill.  If the function returns a non-@code{nil} value, then that
value is used as the most recent kill.  If it returns @code{nil}, then the
front of the kill ring is used.

To facilitate support for window systems that support multiple selections,
this function may also return a list of strings.  In that case, the first
string is used as the most recent kill, and all the other strings are pushed
onto the kill ring, for easy access by @code{yank-pop}.

この関数の通常の用途は、たとえそれが他アプリケーションに属する選択であっても、もっとも最近のkillとして、ウィンドウシステムのクリップボードからそれを取得することである。しかし、クリップボードのコンテンツがカレントEmacsセッション由来なら、この関数は@code{nil}をリターンする筈である。
@end defvar

@defvar interprogram-cut-function
この変数は、ウィンドウシステム使用時に、他のプログラムにkillされたテキストを転送する方法を提供する。値は@code{nil}、または1つの引数を要求する関数であること。

値が関数なら、@code{kill-new}および@code{kill-append}は、killリングの新たな1つ目要素を引数として、それを呼び出す。

この関数の通常の用途は、新たにkillされたテキストを、ウィンドウシステムのクリップボードに配すことである。@ref{Window System
Selections}を参照のこと。
@end defvar

@node Internals of Kill Ring
@subsection killリングの内部

  変数@code{kill-ring}は、文字列リスト形式でkillリングのコンテンツを保持します。もっとも最近のkillが、常にこのリストの先頭になります。

  The @code{kill-ring-yank-pointer} variable points to a link in the kill ring
list, whose @sc{car} is the text to yank next.  We say it identifies the
front of the ring.  Moving @code{kill-ring-yank-pointer} to a different link
is called @dfn{rotating the kill ring}.  We call the kill ring a ``ring''
because the functions that move the yank pointer wrap around from the end of
the list to the beginning, or vice-versa.  Rotation of the kill ring is
virtual; it does not change the value of @code{kill-ring}.

  @code{kill-ring}および@code{kill-ring-yank-pointer}はどちらも、通常は値がリストであるようなLisp変数です。@code{kill-ring-yank-pointer}の名前にある単語``pointer''は、その変数の目的が次回yankコマンドにより使用されるリストの最初の要素を指すことであるのを示します。

  @code{kill-ring-yank-pointer}の値は常にkillリングリスト内の1つのリンクと@code{eq}です。それが指す要素は、そのリンクの@sc{car}です。killリングを変更するkillコマンドも、この変数に@code{kill-ring}の値をセットします。その効果は、新たにkillされた先頭になるように、リングを転回することです。

  以下は、変数@code{kill-ring-yank-pointer}が、killリング@code{("some text" "a different
piece of text" "yet older text")}内の2番目のエントリーを指すことを表すダイアグラムです。

@example
@group
kill-ring                  ---- kill-ring-yank-pointer
  |                       |
  |                       v
  |     --- ---          --- ---      --- ---
   --> |   |   |------> |   |   |--> |   |   |--> nil
        --- ---          --- ---      --- ---
         |                |            |
         |                |            |
         |                |             -->"yet older text"
         |                |
         |                 --> "a different piece of text"
         |
          --> "some text"
@end group
@end example

@noindent
この状態は、@kbd{C-y}(@code{yank})の直後に@kbd{M-y}(@code{yank-pop})を行うことにより発生し得ます。

@defvar kill-ring
この変数は、もっとも最近にkillされたテキストが先頭になるように、killされたテキストのシーケンスのリストを保持する。
@end defvar

@defvar kill-ring-yank-pointer
This variable's value indicates which element of the kill ring is at the
front of the ring for yanking.  More precisely, the value is a tail of the
value of @code{kill-ring}, and its @sc{car} is the kill string that
@kbd{C-y} should yank.
@end defvar

@defopt kill-ring-max
この変数の値は、リング終端の要素を破棄する前に、killリングが成長し得る最大長である。@code{kill-ring-max}のデフォルト値は60。
@end defopt

@node Undo
@section アンドゥ
@cindex redo

  ほとんどのバッファーは、バッファーのテキストにたいして行われた変更をundoできるように、すべての変更を記録する@dfn{undoリスト(undo
list)}をもちます(undoリストをもたないバッファーとは通常、Emacsがundoを有用とみなさない特殊用途のバッファーである。特に、名前がスペースで始まるバッファーはすべて、undo記録がデフォルトでオフになっている。@ref{Buffer
Names}を参照されたい)。バッファー内でテキストを変更するすべてのプリミティブは、undoリストの先頭に自動的に要素を追加し、それは変数@code{buffer-undo-list}に格納されます。

@defvar buffer-undo-list
このバッファーローカル変数の値は、カレントバッファーのundoリストである。値が@code{t}なら、undo情報の記録を無効にする。
@end defvar

以下は、undoリストが保有可能な要素の種類です:

@table @code
@item @var{position}
この種の要素は、前のポイント値を記録する。この要素をundoすることにより、ポイントは@var{position}に移動する。通常のカーソル移動はどのような類のundo記録も作成しないが、削除操作はそのコマンド以前にポイントがあった場所を記録するために、このエントリーを使用する。

@item (@var{beg} . @var{end})
この種の要素は、挿入されたテキストを削除する方法を示す。挿入において、そのテキストはバッファー内の範囲@var{beg}から@var{end}を占める。

@item (@var{text} . @var{position})
この種の要素は、削除されたテキストを再度挿入する方法を示す。文字列@var{text}は、削除されたテキストそのものである。削除されたテキストを再挿入する位置は@code{(abs
@var{position})}である。@var{position}が正ならポイントがあったのは削除されたテキストの先頭、それ以外では末尾である。0個以上の(@var{marker}
. @var{adjustment})要素が、この要素の直後に続く。

@item (t . @var{time-flag})
この種の要素は、未変更のバッファーが変更されたことを示す。@code{(@var{sec-high} @var{sec-low}
@var{microsec}
@var{picosec})}という形式の@var{time-flag}は、visitされたファイルにたいして、それが以前にvisitまたは保存されたときの更新時刻(modification
time)を、@code{current-time}と同じ形式を用いて表す。@ref{Time of
Day}を参照のこと。@var{time-flag}が0ならそのバッファーに対応するファイルがないことを、@minus{}1ならvisitされたファイルは以前は存在しなかったことを意味する。@code{primitive-undo}は、バッファーを再度未変更とマークするかどうかを判断するために、これらの値を使用(ファイルの状態が@var{time-flag}のそれとマッチする場合のみ未変更とマーク)する。

@item (nil @var{property} @var{value} @var{beg} . @var{end})
この種の要素は、テキストプロパティの変更を記録する。変更をundoする方法は、以下のようになる:

@example
(put-text-property @var{beg} @var{end} @var{property} @var{value})
@end example

@item (@var{marker} . @var{adjustment})
この種の要素は、マーカー@var{marker}がそれを取り囲むテキストの削除により再配置されて、@var{adjustment}文字位置を移動したということを記録する。undoリスト内の前にある要素(@var{text}
. @var{position})とマーカーの位置が一致する場合、は、この要素をundoすることにより、@var{marker} @minus{}
@var{adjustment}文字移動する。

@item (apply @var{funname} . @var{args})
これは拡張可能なundoアイテムであり、引数@var{args}とともに@var{funname}を呼び出すことによりundoが行われる。

@item (apply @var{delta} @var{beg} @var{end} @var{funname} . @var{args})
これは拡張可能なundoアイテムであり、@var{beg}から@var{end}までに限定された範囲にたいして、そのバッファーのサイズを@var{delta}文字増加させる変更を記録する。これは、引数@var{args}とともに@var{funname}を呼び出すことによりundoが行われる。

この種の要素は、それがリージョンと関係するか否かを判断することにより、リージョンに限定されたundoを有効にする。

@item nil
この要素は境界(boundary)である。2つの境界の間にある要素を@dfn{変更グループ(change
group)}と呼び、それぞれの変更グループは通常1つのキーボードコマンドに対応するとともに、undoコマンドは通常、グループを1つの単位として全体をundoを行う。
@end table

@defun undo-boundary
この関数は、undoリスト内に境界を配置する。このような境界ごとにundoコマンドは停止し、連続するundoコマンドは、より以前の境界へとundoを行っていく。この関数は@code{nil}をリターンする。

この関数を明示的に呼び出すことは、あるコマンドの効果を複数単位に分割するために有用である。たとえば@code{query-replace}は、ユーザーが個別に置換をundoできるように、それぞれの置換後に@code{undo-boundary}を呼び出している。

Mostly, however, this function is called automatically at an appropriate
time.
@end defun

@defun undo-auto-amalgamate
@cindex amalgamating commands, and undo
The editor command loop automatically calls @code{undo-boundary} just before
executing each key sequence, so that each undo normally undoes the effects
of one command.  A few exceptional commands are @dfn{amalgamating}: these
commands generally cause small changes to buffers, so with these a boundary
is inserted only every 20th command, allowing the changes to be undone as a
group.  By default, the commands @code{self-insert-command}, which produces
self-inserting input characters (@pxref{Commands for Insertion}), and
@code{delete-char}, which deletes characters (@pxref{Deletion}), are
amalgamating.  Where a command affects the contents of several buffers, as
may happen, for example, when a function on the @code{post-command-hook}
affects a buffer other than the @code{current-buffer}, then
@code{undo-boundary} will be called in each of the affected buffers.
@end defun

@defvar undo-auto-current-boundary-timer
Some buffers, such as process buffers, can change even when no commands are
executing.  In these cases, @code{undo-boundary} is normally called
periodically by the timer in this variable.  Setting this variable to
non-@code{nil} prevents this behavior.
@end defvar

@defvar undo-in-progress
この変数は通常@code{nil}だが、undoコマンドはこれを@code{t}にバインドする。これにより、さまざまな種類の変更フックがundoにより呼び出された際、それを告げることが可能になる。
@end defvar

@defun primitive-undo count list
これは、undoリストの要素のundoにたいする基本的な関数である。これは@var{list}の最初の@var{count}要素をundoして、@var{list}の残りをリターンする。

@code{primitive-undo}はバッファー変更時、そのバッファーのundoリストに要素を追加する。undoコマンドは混乱を避けるために、undo操作シーケンス冒頭にundoリストの値を保存する。その後、undo操作は保存された値の使用および更新を行う。undoにより追加された新たな要素はこの保存値の一部でないので、継続するundoと干渉しない。

この関数は、@code{undo-in-progress}をバインドしない。
@end defun

@node Maintaining Undo
@section アンドゥリストの保守

  このセクションでは、与えられたバッファーにたいしてundo情報を有効、および無効にする方法を説明します。undoリストが巨大化しないように、undoリストを切り詰める方法も説明します。

  新たに作成されたバッファー内のundo情報記録は、開始とともに通常は有効になります。しかしバッファー名がスペースで始まる場合、undoの記録は初期状態では無効になっています。以下の2つの関数、または自身で@code{buffer-undo-list}をセットすることにより、undo記録の有効、または無効化を明示的に行うことができます。

@deffn Command buffer-enable-undo &optional buffer-or-name
このコマンドは、以降の変更をundo可能にするよう、バッファー@var{buffer-or-name}のundo情報記録を有効にする。引数が与えられない場合は、カレントバッファーを使用する。そのバッファー内のundo記録がすでに有効なら、この関数は何も行わない。リターン値は@code{nil}。

インタラクティブな呼び出しでは、@var{buffer-or-name}はカレントバッファーであり、他のバッファーを指定することはできない。
@end deffn

@deffn Command buffer-disable-undo &optional buffer-or-name
@cindex disabling undo
この関数は@var{buffer-or-name}のundoリストを破棄して、それ以上のundo情報記録を無効にする。結果として、以前の変更および以降のすべての変更にたいするそれ以上のundoは不可能になる。@var{buffer-or-name}のundoリストがすでに無効なら、この関数に効果はない。

インタラクティブな呼び出しでは、BUFFER-OR-NAMEはカレントバッファーとなる。他のバッファーを指定することはできない。リターン値は@code{nil}。
@end deffn

  As editing continues, undo lists get longer and longer.  To prevent them
from using up all available memory space, garbage collection trims them back
to size limits you can set.  (For this purpose, the size of an undo list
measures the cons cells that make up the list, plus the strings of deleted
text.)  Three variables control the range of acceptable sizes:
@code{undo-limit}, @code{undo-strong-limit} and @code{undo-outer-limit}.  In
these variables, size is counted as the number of bytes occupied, which
includes both saved text and other data.

@defopt undo-limit
これは、許容できるundoリストサイズのソフトリミットである。このサイズを超過した箇所の変更グループは、最新の変更グループ1つが保持される。
@end defopt

@defopt undo-strong-limit
これは、undoリストの許容できるサイズの上限である。このサイズを超過する箇所の変更グループは(その他すべてのより古い変更グループとともに)自身を破棄する。1つ例外があり、@code{undo-outer-limit}を超過した場合は、最新の変更グループだけが破棄される。
@end defopt

@defopt undo-outer-limit
ガベージコレクション時にカレントコマンドのundo情報がこの制限を超過したら、Emacsはその情報を破棄して、警告を表示する。これはメモリーオーバーフローを防ぐための、最後の回避用リミットである。
@end defopt

@defopt undo-ask-before-discard
この変数が非@code{nil}なら、undo情報の@code{undo-outer-limit}超過時、Emacsはその情報を破棄するかどうかを、エコーエリアで尋ねる。デフォルト値は@code{nil}で、これは自動的な破棄を意味する。

このオプションは、主にデバッグを意図している。これを尋ねる際、ガベージコレクションは抑制されており、もしユーザーがその問にたいして答えるのをあまりに長くかかるなら、Emacsがメモリーリークを起こすかもしれないことを意味する。
@end defopt

@node Filling
@section fill
@cindex filling text

  @dfn{フィル(fill:
充填)}とは、指定された最大幅付近(ただし超えず)に、(行ブレークを移動することにより)行の長さを調整することを意味します。加えて、複数行を@dfn{位置揃え(justify)}することもできます。位置揃えとは、スペースを挿入して左および/または右マージンを正確に整列させることを意味します。その幅は、変数@code{fill-column}により制御されます。読みやすくするために、行の長さは70列程度を超えないようにするべきです。

  テキストの挿入とともに自動的にテキストをフィルするAuto
Fillモードを使用できますが、既存テキストの変更では不適切にフィルされたままになるかもしれません。その場合は、テキストを明示的にフィルしなければなりません。

  このセクションのコマンドのほとんどは、有意な値をリターンしません。フィルを行うすべての関数は、カレント左マージン、カレント右マージン、カレント位置揃えスタイルに留意します(@ref{Margins}を参照)。カレント位置揃えスタイルが@code{none}の場合、フィル関数は実際には何も行いません。

  フィル関数のいくつかは、引数@var{justify}をもちます。これが非@code{nil}なら、それは何らかの類の位置揃えを要求します。特定の位置揃えスタイルを要求するために@code{left}、@code{right}、@code{full}、@code{center}を指定できます。これが@code{t}なら、それはそのテキスト部分にたいしてカレント位置揃えスタイルを使用することを意味します(以下の@code{current-justification}を参照)。その他すべての値は、@code{full}として扱われます。

  インタラクティブにフィル関数を呼び出す際、プレフィクス引数の使用は@var{justify}にたいして暗に値@code{full}を指定します。

@deffn Command fill-paragraph &optional justify region
このコマンドは、ポイント位置、またはその後のパラグラフ(paragraph:
段落)をフィルする。@var{justify}が非@code{nil}なら、同様に各行が位置揃えされる。これはパラグラフ境界を探すために、通常のパラグラフ移動コマンドを使用する。@ref{Paragraphs,,,
emacs, The GNU Emacs Manual}を参照のこと。

もし@var{region}が非@code{nil}で、Transient
Markモードが有効かつマークがアクティブなら、このコマンドはカレントパラグラフのみフィルするかわりに、リージョン内すべてのパラグラフをフィルするために、コマンド@code{fill-region}を呼び出す。このコマンドがインタラクティブに呼び出されたとき、@var{region}は@code{t}である。
@end deffn

@deffn Command fill-region start end &optional justify nosqueeze to-eop
このコマンドは、@var{start}から@var{end}のリージョン内のすべてのパラグラフをフィルする。@var{justify}が非@code{nil}なら、同様に位置揃えも行う。

@var{nosqueeze}が非@code{nil}なら、それは行ブレーク以外の空白文字を残すことを意味する。@var{to-eop}が非@code{nil}の場合、それはパラグラフ終端(以下の@code{use-hard-newlines}が有効なら次のhard改行)までのフィルを維持することを意味する

変数@code{paragraph-separate}は、パラグラフを分割する方法を制御する。@ref{Standard Regexps}を参照のこと。
@end deffn

@deffn Command fill-individual-paragraphs start end &optional justify citation-regexp
このコマンドは、リージョン内の各パラグラフを、それの固有なフィルプレフィクスに応じてフィルする。したがって、パラグラフの行がスペースでインデントされている場合、フィルされたパラグラフは同じ様式でインデントされた状態に保たれるだろう。

最初の2つの引数@var{start}と@var{end}は、フィルするリージョンの先頭と終端である。3つ目の引数@var{justify}、4つ目の引数@var{citation-regexp}はオプションである。@var{justify}が非@code{nil}なら、そのパラグラフはフィルと同様に位置揃えもされる。@var{citation-regexp}が非@code{nil}なら、それはこの関数がメールメッセージを処理しているので、ヘッダーラインをフィルするべきではないことを意味する。@var{citation-regexp}が文字列の場合、それは正規表現として扱われる。それが行の先頭にマッチすれば、その行は引用マーカー(citation
marker)として扱われる。

@c FIXME: "That mode" is confusing.  It isn't a major/minor mode.
@code{fill-individual-paragraphs}は通常、インデントの変更を新たなパラグラフの開始とみなす。@code{fill-individual-varying-indent}が非@code{nil}の場合は、セパレーターラインだけがパラグラフを分割する。その場合は、最初の行からさらにインデントが追加されたパラグラフを処理することが可能になる。
@end deffn

@defopt fill-individual-varying-indent
この変数は、上述のように@code{fill-individual-paragraphs}の動作を変更する。
@end defopt

@deffn Command fill-region-as-paragraph start end &optional justify nosqueeze squeeze-after
このコマンドは、テキストのリージョンを1つのパラグラフとみなして、それをフィルする。そのリージョンが多数のパラグラフから構成されていたら、パラグラフ間の空行は削除される。@var{justify}が非@code{nil}なら、フィルとともに位置揃えも行う。

@var{nosqueeze}が非@code{nil}なら、それは改行以外の空白に手を加えずに残すことを意味する。@var{squeeze-after}が非@code{nil}の場合、それはリージョン内の位置を指定し、その位置より前にあるスペースについては標準化を行わないことを意味する。

Adaptive
Fillモードでは、このコマンドはフィルプレフィクスを選択するために、デフォルトで@code{fill-context-prefix}を呼び出す。@ref{Adaptive
Fill}を参照のこと。
@end deffn

@deffn Command justify-current-line &optional how eop nosqueeze
このコマンドは、その行が正確に@code{fill-column}で終わるように、単語間にスペースを挿入する。リターン値は@code{nil}。

引数@var{how}が非@code{nil}なら、それは位置揃えスタイルを明示的に指定する。指定できる値は@code{left}、@code{right}、@code{full}、@code{center}、または@code{none}。値が@code{t}の場合、それは指定済みの位置揃えスタイル(以下の@code{current-justification}を参照)にしたがうことを意味する。@code{nil}は位置揃え@code{full}と同じ。

@var{eop}が非@code{nil}なら、それは@code{current-justification}がfull位置揃えを指定する場合にleft位置揃えだけを行うことを意味する。これは、パラグラフ最終行にたいして使用される。パラグラフ全体がfull位置揃えだったとしても、最終行はfull位置揃えであるべきではない。

@var{nosqueeze}が非@code{nil}なら、それは内部のスペースを変更しないことを意味する。
@end deffn

@defopt default-justification
この変数の値は、位置揃えに使用するスタイルをテキストプロパティで指定しないテキストにたいするスタイルを指定する。可能な値は@code{left}、@code{right}、@code{full}、@code{center}、または@code{none}。デフォルト値は@code{left}である。
@end defopt

@defun current-justification
この関数は、ポイント周辺のフィルに使用するための、適正な位置揃えスタイルをリターンする。

これは、ポイント位置のテキストプロパティ@code{justification}の値、そのようなテキストプロパティが存在しなければ変数@var{default-justification}の値をリターンする。しかし、``位置揃えなし''の場合は、@code{none}ではなく@code{nil}をリターンする。
@end defun

@defopt sentence-end-double-space
@anchor{Definition of sentence-end-double-space}
この変数が非@code{nil}の場合、ピリオドの後の単一のスペースをセンテンスの終わりとみなさず、フィル関数はそのような箇所でのラインブレークを行わない。
@end defopt

@defopt sentence-end-without-period
この変数が非@code{nil}なら、ピリオドなしでセンテンスは終了できる。これはたとえば、ピリオドなしの2連スペースでセンテンスが終わるタイ語な土に使用される。
@end defopt

@defopt sentence-end-without-space
この変数が非@code{nil}なら、それは後にスペースをともなうことなくセンテンスを終了させ得る文字列であること。
@end defopt

@defvar fill-paragraph-function
この変数は、パラグラフのフィルをオーバーライドする手段を提供する。この値が非@code{nil}なら、@code{fill-paragraph}はその処理を行うためにその関数を呼び出す。その関数が非@code{nil}値をリターンした場合、@code{fill-paragraph}は処理が終了したとみなして、即座にその値をリターンする。

この機能の通常の用途は、プログラミング言語のモードにおいてコメントをフィルすることである。通常の方法でその関数がパラグラフをフィルする必要がある場合は、以下のようにそれを行うことができる:

@example
(let ((fill-paragraph-function nil))
  (fill-paragraph arg))
@end example
@end defvar

@defvar fill-forward-paragraph-function
この変数は、@code{fill-region}や@code{fill-paragraph}のようなフィル関数が、次のパラグラフへ前方に移動する方法を、オーバーライドするための手段を提供する。値は、移動するパラグラフの数@var{n}を唯一の引数として呼び出される関数で、@var{n}と実際に移動したパラグラフ数の差をリターンするべきである。この変数のデフォルト値は@code{forward-paragraph}。@ref{Paragraphs,,,
emacs, The GNU Emacs Manual}を参照のこと。
@end defvar

@defvar use-hard-newlines
If this variable is non-@code{nil}, the filling functions do not delete
newlines that have the @code{hard} text property.  These hard newlines act
as paragraph separators.  @xref{Hard and Soft Newlines,, Hard and Soft
Newlines, emacs, The GNU Emacs Manual}.
@end defvar

@node Margins
@section fillのマージン
@cindex margins, filling

@defopt fill-prefix
このバッファーローカル変数が非@code{nil}なら、それは通常のテキスト行の先頭に出現そ、それらのテキスト行をフィルする際には無視されるべきテキスト文字列を指定する。そのフィルプレフィクスで始まらない行はパラグラフの開始とみなされ、フィルプレフィクスで始まる行は、その後にスペースが追加される。フィルプレフィクスで始まりその後に追加のスペースがない行は、フィル可能な通常のテキスト行である。結果となるフィル済みの行も、フィルプレフィクスで開始される。

もしあれば、フィルプレフィクスは左マージンのスペースの後になる。
@end defopt

@defopt fill-column
このバッファーローカル変数は、フィルされる行の最大幅を指定する。値は列数を表す整数であること。Auto Fillモード(@ref{Auto
Filling}を参照)を含む、フィル、位置揃え、センタリングを行うすべてのコマンドが、この変数の影響を受ける。

実際の問題として、他の人が読むためのテキストを記述する場合は、@code{fill-column}を70より大きくするべきではない。これにしたがわない場合、人が快適に読むには行が長くなり過ぎ、それは下手に記述されたテキストに見えてしまうだろう。

@code{fill-column}のデフォルト値は70である。
@end defopt

@deffn Command set-left-margin from to margin
これは、@var{from}から@var{to}のテキストの@code{left-margin}プロパティに、値@var{margin}をセットする。Auto
Fillモードが有効なら、このコマンドは新たなマージンにフィットするよう、リージョンの再フィルも行う。
@end deffn

@deffn Command set-right-margin from to margin
これは、@var{from}から@var{to}のテキストの@code{right-margin}プロパティに、値@var{margin}をセットする。Auto
Fillモードが有効なら、このコマンドは新たなマージンにフィットするよう、リージョンの再フィルも行う。
@end deffn

@defun current-left-margin
この関数は、ポイント周辺をフィルするために使用する、適切な左マージン値をリターンする。値はカレント行開始文字の@code{left-margin}プロパティの値(なければ0)と、変数@code{left-margin}の値の合計。
@end defun

@defun current-fill-column
この関数は、ポイント周辺のテキストをフィルするために使用する、適切なフィル列値をリターンする。値は、変数@code{fill-column}からポイント後の文字の@code{right-margin}プロパティの値を減じた値。
@end defun

@deffn Command move-to-left-margin &optional n force
この関数は、カレント行の左マージンにポイントを移動する。移動先の列は、関数@code{current-left-margin}により決定される。引数@var{n}が非@code{nil}なら、@code{move-to-left-margin}はまず@var{n}行前方に移動する。

@var{force}が非@code{nil}の場合、それは行のインデントが左マージン値とマッチしなければ、インデントを修正するよう指定する。
@end deffn

@defun delete-to-left-margin &optional from to
この関数は、@var{from}から@var{to}の間のテキストから、左マージンのインデントを取り除く。削除するインデントの量は、@code{current-left-margin}を呼び出すことにより決定される。この関数が、非空白文字を削除することはない。@var{from}と@var{to}が省略された場合のデフォルトは、そのバッファー全体である。
@end defun

@defun indent-to-left-margin
この関数は、カレント行の先頭のインデントを、変数@code{left-margin}に指定された値に調整する(これにより空白文字の挿入や削除が起こるかもしれない)。Paragraph-Indent
Textモード内の変数@code{indent-line-function}の値は、この関数である。
@end defun

@defopt left-margin
This variable specifies the base left margin column.  In Fundamental mode,
@key{RET} indents to this column.  This variable automatically becomes
buffer-local when set in any fashion.
@end defopt

@defopt fill-nobreak-predicate
この変数はメジャーモードにたいして、特定の箇所で行ブレークしないよう指定する手段を提供する。値は関数のリストであること。フィルがバッファー内の特定箇所で行ブレークすると判断されるときは常に、その箇所にポイントを置いた状態で、これらの関数を引数なしで呼び出す。これらの関数のいずれ可が非@code{nil}をリターンした場合は、その行のその箇所では行ブレークしない。
@end defopt

@node Adaptive Fill
@section Adaptive Fillモード
@c @cindex Adaptive Fill mode  "adaptive-fill-mode" is adjacent.

  @dfn{Adaptive
Fillモード}が有効なとき、Emacsは事前定義された値を使用するのではなく、フィルされる各パラグラフのテキストから自動的に、フィルプレフィクスを決定します。このフィルプレフィクスはフィルの間、@ref{Filling}と@ref{Auto
Filling}で説明されているように、そのパラグラフの2行目以降の行頭に挿入されます。

@defopt adaptive-fill-mode
この変数が非@code{nil}なら、Adaptive Fillモードは有効である。デフォルトは@code{t}。
@end defopt

@defun fill-context-prefix from to
@c The optional argument first-line-regexp is not documented
@c because it exists for internal purposes and might be eliminated
@c in the future.
この関数は、Adaptive
Fillモードの肝を実装する。これは@var{from}から@var{to}、通常はパラグラフの開始から終了にあるテキストにもとづいて、フィルプレフィクスを選択する。これは、以下で説明する変数にもとづき、そのパラグラフの最初の2行を調べることにより、これを行う。

この関数は通常、文字列としてフィルプレフィクスをリターンする。しかしこれを行う前に、この関数はそのプレフィクスで始まる行がパラグラフの開始とは見えないだろうか、最終チェックを行う(以降では特に明記しない)。これが発生した場合、この関数はかわりに@code{nil}をリターンすることにより、異常を通知する。

以下が、@code{fill-context-prefix}が行う詳細である:

@enumerate
@item
1行目からフィルプレフィクス候補を取得するために、(もしあれば)まず@code{adaptive-fill-function}内の関数、次に@code{adaptive-fill-regexp}(以下参照)の正規表現を試みる。これらの非@code{nil}の最初の結果、いずれも@code{nil}なら空文字列が1行目の候補となる。
@item
そのパラグラフが1行だけなら、関数は見つかったプレフィクス候補の妥当性をテストする。その後、この関数はそれが妥当ならその候補を、それ以外はスペース文字列をリターンする(以下の@code{adaptive-fill-first-line-regexp}の説明を参照)。
@item
すでにそのパラグラフが2行以上なら、この関数は次に1行目にたいして行なったのとまったく同じ方法で、2行目でプレフィクス候補を探す。見つからなければ@code{nil}をリターンする。
@item
ここで、この関数は発見的手法により2つのプレフィクス候補を比較する。2行目の候補の非空白文字の並びが1行目の候補と同じなら、この関数は2行目の候補をリターンする。それ以外では、2つの候補に共通するもっとも長い先頭の部分文字列(これは空文字列かもしれない)をリターンする。
@end enumerate
@end defun

@defopt adaptive-fill-regexp
Adaptive
Fillモードは、(もしあれば)行の左マージン空白文字の後から開始されるテキストにたいして、この正規表現をマッチする。マッチする文字列が、その行のフィルプレフィクス候補である。

デフォルト値は、空白文字と特定の句読点文字が混在した文字列にマッチする。
@end defopt

@defopt adaptive-fill-first-line-regexp
Used only in one-line paragraphs, this regular expression acts as an
additional check of the validity of the one available candidate fill prefix:
the candidate must match this regular expression, or match
@code{comment-start-skip}.  If it doesn't, @code{fill-context-prefix}
replaces the candidate with a string of spaces of the same width as it.

この変数のデフォルト値は @w{@code{"\\`[
\t]*\\'"}}で、これは空白文字列だけにマッチする。このデフォルトの効果は、1行パラグラフで見つかったフィルプレフィクスが、常に純粋な空白文字となるよう強制することである。
@end defopt

@defopt adaptive-fill-function
You can specify more complex ways of choosing a fill prefix automatically by
setting this variable to a function.  The function is called with point
after the left margin (if any) of a line, and it must preserve point.  It
should return either that line's fill prefix or @code{nil}, meaning it has
failed to determine a prefix.
@end defopt

@node Auto Filling
@section オートfill
@cindex filling, automatic
@cindex Auto Fill mode

@c FIXME: I don't think any of the variables below is a/an normal/abnormal hook.
  Auto Fillモードは、テキスト挿入とともに自動的に行をフィルするマイナーモードです。このセクションでは、Auto
Fillモードにより使用されるフックを説明します。既存テキストを明示的にフィルしたり位置揃えすることができる関数の説明は、@ref{Filling}を参照してください。

  Auto
Fillモードでは、テキスの一部を再フィルするために、マージンや位置揃えを変更する関数も利用できます。@ref{Margins}を参照してください。

@defvar auto-fill-function
このバッファーローカル変数の値は、テーブル@code{auto-fill-chars}からの文字の自己挿入後に呼び出される関数(引数なし)であること。@code{nil}も可で、その場合は特に何もしない。

Auto-Fillモードが有効なら、@code{auto-fill-function}の値は@code{do-auto-fill}である。これは、行ブレークにたいする通常の戦略を実装することを唯一の目的とする関数である。
@end defvar

@defvar normal-auto-fill-function
この変数は、もしAuto Fillがオンのときは@code{auto-fill-function}にたいして使用する関数を指定する。Auto
Fillの動作方法を変更するために、メジャーモードはこの変数にバッファーローカル値をセットである。
@end defvar

@defvar auto-fill-chars
文字が自己挿入された際に@code{auto-fill-function}を呼び出す文字(ほとんどの言語環境においてはスペースと改行)からなる文字テーブル。
@end defvar

@node Sorting
@section テキストのソート
@cindex sorting text

  このセクションで説明するソート関数はすべて、バッファー内のテキストを再配置し。これはリスト要素を再配置する@code{sort}関数とは対照的です(@pxref{Rearrangement})。これらの関数がリターンする値に意味はありません。

@defun sort-subr reverse nextrecfun endrecfun &optional startkeyfun endkeyfun predicate
この関数はバッファーをレコードに細分してそれらをソートする、一般的なテキストソートルーチンである。このセクションのコマンドのほとんどは、この関数を使用する。

@code{sort-subr}が機能する方法を理解するためには、バッファーのアクセス可能範囲を@dfn{ソートレコード(sort
records)}と呼ばれる、分離された断片に分割すると考えればよい。レコードは連続、あるいは非連続かもしれないが、オーバーラップしてはならない。各ソートレコードの一部(全体かもしれない)は、ソートキーとして指定される。これらソートキーによるソートにより、レコードは再配置される。

通常、レコードはソートキー昇順で再配置される。@code{sort-subr}の1つ目の引数@var{reverse}が非@code{nil}なら、レコードはソートキー降順にソートされて再配置される。

@code{sort-subr}にたいする以下の4つの引数は、ソートレコード間でポイントを移動するために呼び出される。これらは@code{sort-subr}内で頻繁に呼び出される。

@enumerate
@item
@var{nextrecfun}は、レコード終端のポイントで呼び出される。この関数は次のレコードの先頭にポイントを移動する。@code{sort-subr}が呼び出された際は、ポイント位置が1つ目のレコードの開始とみなされる。したがって@code{sort-subr}を呼び出す前は、通常はそのバッファーの先頭にポイントを移動すること。

この関数はバッファー終端にポイントを残すことにより、それ以上のソートレコードがないことを示すことができるできる。

@item
@var{endrecfun}は、レコード内にあるポイントで呼び出される。これはレコード終端にポイントを移動する。

@item
@var{startkeyfun}は、ポイントをレコード先頭からソートキー先頭に移動する。この引数はオプションで、省略された場合はレコード全体がソートキーとなる。もし与えられた場合、その関数はソートキーとして使用する非@code{nil}値、または@code{nil}(ソートキーはそのバッファー内のポイント位置から始まることを示す)のいずれかをリターンすること。後者の場合は、ソートキー終端を見るけるために@var{endkeyfun}が呼び出される。

@item
@var{endkeyfun}は、ソートキー先頭からソートキー終端にポイントを移動するために呼び出される。引数はオプション。@var{startkeyfun}が@code{nil}をリターンし、かつこの引数が省略(または@code{nil})の場合、そのソートキーはレコード終端まで拡張される。@var{startkeyfun}が非@code{nil}値をリターンした場合、@var{endkeyfun}は不要。
@end enumerate

引数@var{predicate}は、キーを比較するために使用される関数である。キーが数字の場合のデフォルトは@code{<}、それ以外では@code{string<}がデフォルトである。

@code{sort-subr}の例として、以下は@code{sort-lines}関数の完全な定義である:

@example
@group
;; @r{ドキュメント文字列の冒頭2行は}
;; @r{ユーザー閲覧時には1行となることに注意}
(defun sort-lines (reverse beg end)
  "リージョン内の行をアルファベット順にソート;\
 引数は降順を意味する
プログラムから呼び出す場合は、以下の3つの引数がある:
@end group
@group
REVERSE(非nilは逆順の意)、\
およびBEGとEND(ソートするリージョン)
変数`sort-fold-case'は英字\
大文字小文字の違いが
ソート順に影響するかどうかを決定する"
@end group
@group
  (interactive "P\nr")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (goto-char (point-min))
      (let ((inhibit-field-text-motion t))
        (sort-subr reverse 'forward-line 'end-of-line)))))
@end group
@end example

ここで、@code{forward-line}は次のレコードの先頭にポイントを移動し、@code{end-of-line}はレコードの終端にポイントを移動する。レコード全体をソートキーとするため、引数@var{startkeyfun}および@var{endkeyfun}は渡していない。

@code{sort-paragraphs}はほとんど同じだが、@code{sort-subr}呼び出しが以下のようになる:

@example
@group
(sort-subr reverse
           (function
            (lambda ()
              (while (and (not (eobp))
                          (looking-at paragraph-separate))
                (forward-line 1))))
           'forward-paragraph)
@end group
@end example

ソートレコード内を指す任意のマーカーは、@code{sort-subr}リターン後は無意味なマーカー位置のまま取り残される。
@end defun

@defopt sort-fold-case
この変数が非@code{nil}なら@code{sort-subr}、およびその他のバッファーソート関数は、文字列比較時に大文字小文字の違いを無視する。
@end defopt

@deffn Command sort-regexp-fields reverse record-regexp key-regexp start end
このコマンドは、@var{start}から@var{end}の間のリージョンを、@var{record-regexp}および@var{key-regexp}で指定されたようにアルファベット順にソートする。@var{reverse}が負の整数なら、逆順にソートする。

アルファベット順のソートとは、2つのソートキーにたいして、それぞれの1つ目の文字同士、2つ目の文字同士といったように比較することにより、キーを比較することを意味する。文字が一致しなければ、それはソートキーが不等なことを意味する。最初の不一致箇所で文字が小さいソートキーが、小さいソートキーとなる。個別の文字は、Emacs文字セット内の文字コードの数値に応じて比較される。

引数@var{record-regexp}の値は、バッファーをソートレコードに分割する方法を指定する。各レコードの終端で、この正規表現にたいする検索は完了し、これにマッチするテキストが次のレコードとして採用される。たとえば、改行の前に少なくとも1つの文字がある行にマッチする正規表現@samp{^.+$}は、そのような行をソートレコードとするだろう。正規表現の構文と意味については、@ref{Regular
Expressions}を参照のこと。

引数@var{key-regexp}の値は、各レコードのどの部分がソートキーかを指定する。@var{key-regexp}はレコード全体、またはその一部にマッチすることができる。後者の場合、レコードの残りの部分はソート順に影響しないが、レコードが新たな位置に移動される際は、ともに移動される。

引数@var{key-regexp}は、@var{record-regexp}の部分式(subexpression)、またはその正規表現自体にマッチしたテキストを参照できる。

@var{key-regexp}は、以下を指定できる:

@table @asis
@item @samp{\@var{digit}}
@var{record-regexp}内で@var{digit}番目のカッコ@samp{\(...\)}でグループ化によりマッチしたテキストがソートキーになる。

@item @samp{\&}
レコード全体がソートキーとなる。

@item 正規表現
@code{sort-regexp-fields}は、そのレコード内で正規表現にたいするマッチを検索する。そのようなマッチがあれば、それがソートキーである。レコード内に@var{key-regexp}にたいするマッチがなければそのレコードは無視され、そのバッファー内でのレコードの位置は変更されないことを意味する(他のレコードがそのレコードを移動するかもしれない)。
@end table

たとえば、リージョン内のすべての行にたいして、最初の単語が文字@samp{f}で始まる行をソートすることを目論む場合は、@var{record-regexp}を@samp{^.*$}、@var{key-regexp}を@samp{\<f\w*\>}にセットするべきである。結果は、以下のような式になるだろう

@example
@group
(sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                    (region-beginning)
                    (region-end))
@end group
@end example

@code{sort-regexp-fields}をインタラクティブに呼び出した場合は、ミニバッファー内で@var{record-regexp}と@var{key-regexp}の入力を求める。
@end deffn

@deffn Command sort-lines reverse start end
このコマンドは、@var{start}と@var{end}の間のリージョン内の行を、アルファベット順にソートする。@var{reverse}が非@code{nil}なら、逆順にソートする。
@end deffn

@deffn Command sort-paragraphs reverse start end
このコマンドは、@var{start}と@var{end}の間のリージョン内のパラグラフを、アルファベット順にソートする。@var{reverse}が非@code{nil}なら、逆順にソートする。
@end deffn

@deffn Command sort-pages reverse start end
このコマンドは、@var{start}と@var{end}の間のリージョン内のページを、アルファベット順にソートする。@var{reverse}が非@code{nil}なら、逆順にソートする。
@end deffn

@deffn Command sort-fields field start end
このコマンドは、@var{start}と@var{end}の間のリージョン内の行にたいして、各行の@var{field}番目のフィールドをアルファベット順に比較することに、行をソートする。@var{field}は空白文字により区切られ、1から数えられる。@var{field}が負なら、行の終端から@w{@minus{}@var{field}}番目のフィールドでソートする。このコマンドは、テーブルのソートに有用である。
@end deffn

@deffn Command sort-numeric-fields field start end
このコマンドは、@var{start}と@var{end}の間のリージョン内の行にたいして、各行の@var{field}番目のフィールドを数値的に比較することにより、行をソートする。@var{field}は空白文字により区切られ、1から数えられる。リージョン内の各行の指定されたフィールドは、数字を含んでいなければならない。0で始まる数字は8進数、@samp{0x}で始まる数字は16進数として扱われる。

@var{field}が負なら、行の終端から@w{@minus{}@var{field}}番目のフィールドでソートする。このコマンドは、テーブルのソートに有用である。
@end deffn

@defopt sort-numeric-base
この変数は、@code{sort-numeric-fields}にたいして、数字を解析するための基本基数を指定する。
@end defopt

@deffn Command sort-columns reverse &optional beg end
このコマンドは、@var{beg}と@var{end}の間にある行にたいして、特定の列範囲をアルファベット順に比較することによりソートする。@var{beg}と@var{end}の列位置は、ソートが行われる列範囲にバインドされる。

@var{reverse}が非@code{nil}なら、逆順にソートする。

このコマンドが普通と異なるのは、位置@var{beg}を含む行全体と、位置@var{end}を含む行全体が、ソートされるリージョンに含まれることである。

タブは指定された列に分割される可能性があるので、@code{sort-columns}はタブを含むテキストを受け付けないことに注意。ソート前に@kbd{M-x
untabify}を使用して、タブをスペースに変換すること。

可能なら、ユーティリティプログラム@code{sort}を呼び出すことにより、このコマンドは実際に機能する。
@end deffn

@node Columns
@section 列を数える
@cindex columns
@cindex counting columns
@cindex horizontal position

  列関数は、文字位置(バッファー先頭から数えた文字数)と、列位置(行先頭から数えたスクリーン文字数)を変換する関数です。

  これら列関数は、スクリーン上占める列数に応じて、各文字を数えます。これはコントロール文字は@code{ctl-arrow}の値に応じて2列、または4列を、タブは@code{tab-width}の値と、タブが始まる列の位置に依存する列数を占めるものとして数えられることを意味します。@xref{Usual
Display}を参照してください。

  列数計算はウィンドウ幅と水平スクロール量を無視します。結果として、列値は任意に大きくなる可能性があります。最初(または左端)の列は0と数えられます。列値は不可視性を別として、オーバーレイとテキストプロパティを無視します。

@defun current-column
この関数は、左マージンを0として、列単位で数えたポイントの水平位置をリターンする。列の位置は、カレント行の開始からポイントまでの間の文字の表示上の表現すべての幅の和である。
@end defun

@deffn Command move-to-column column &optional force
この関数は、カレント行の@var{column}にポイントを移動する。@var{column}の計算には、行の開始からポイントまでの文字の表示上の表現の幅が考慮される。

インタラクティブに呼び出された際は、@var{column}はプレフィクス数引数の値である。@var{column}が整数でなければエラーがシグナルされる。

@c This behavior used to be documented until 2013/08.
@ignore
If column @var{column} is beyond the end of the line, point moves to
the end of the line.  If @var{column} is negative, point moves to the
beginning of the line.
@end ignore

列@var{column}が、タブのような複数列を占める文字の中間にあるために列を移動することが不可能な場合、ポイントはその文字の終端に移動される。しかし@var{force}が非@code{nil}、かつ@var{column}がタブの中間にあるなら、@code{move-to-column}はタブをスペースに変換して、正確に列@var{column}に移動することができる。それ以外の複数列文字については、それらを分割する手段がないので、@var{force}指定に関わらず、異常を引き起こす恐れがある。

その行が列@var{column}に達するほど長くない場合にも、引数@var{force}は効果をもつ。@var{column}が@code{t}なら、その列に達するよう行端に空白を追加することを意味する。

リターン値は、実際に移動した列である。
@end deffn

@node Indentation
@section インデント
@cindex indentation

  インデント関数は、行の先頭にある空白文字の調査、移動、変更に使用されます。行の他の箇所にある空白文字を変更できる関数も、いくつかあります。列およびインデントは、左マージンを0として数えられます。

@menu
* Primitive Indent::         インデントのカウントと挿入に使用される関数。
* Mode-Specific Indent::     異なるモード用にインデントをカスタマイズする。
* Region Indent::            リージョン内すべての行のインデント。
* Relative Indent::          前の行にもとづきカレント行をインデントする。
* Indent Tabs::              調整可能なタイプライター形式のタブストップ。
* Motion by Indent::         最初の非ブランク文字への移動。
@end menu

@node Primitive Indent
@subsection インデント用のプリミティブ

  このセクションでは、インデントのカウントと挿入に使用されるプリミティブ関数について説明します。以降のセクションの関数は、これらのプリミティブを使用します。関連する関数については、@ref{Size
of Displayed Text}を参照してください。

@defun current-indentation
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
この関数は、カレント行のインデント、すなわち最初の非ブランク文字の水平位置をリターンする。行のコンテンツ全体がブランクなら、それは行終端の水平位置である。
@end defun

@deffn Command indent-to column &optional minimum
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
この関数は、ポイントから@var{column}に達するまで、タブとスペースでインデントを行う。@var{minimum}が指定され、かつそれが非@code{nil}なら、たとえ@var{column}を超えることが要求される場合であっても、少なくともその個数のスペースが挿入される。それ以外では、ポイントがすでに@var{column}を超える場合、この関数は何も行わない。値は、挿入されたインデントの終端列である。

挿入される空白文字は、周囲のテキスト(通常は先行するテキストのみ)のテキストプロパティを継承する。@ref{Sticky
Properties}を参照のこと。
@end deffn

@defopt indent-tabs-mode
@comment !!SourceFile indent.c
この変数が非@code{nil}なら、インデント関数はスペースと同様、タブを挿入でき、それ以外ではスペースだけを挿入できる。この変数をセットすることにより、自動的にカレントバッファー内でバッファーローカルになる。
@end defopt

@node Mode-Specific Indent
@subsection メジャーモードが制御するインデント

  すべてのメジャーモードにとって重要な関数は、編集対象の言語にたいして正しくインデントを行うように、@key{TAB}キーをカスタマイズします。このセクションでは、@key{TAB}キーのメカニズムと、それを制御する方法について説明します。このセクションの関数は、予期せぬ値をリターンします。

@deffn Command indent-for-tab-command &optional rigid
これはほとんどの編集用モードで、@key{TAB}にバインドされるコマンドである。これの通常の動作はカレント行のインデントだが、かわりにタブ文字の挿入や、リージョンのインデントを行うこともできる。

これは以下のことを行う:

@itemize
@item
まずTransient
Markモードが有効か、そしてリージョンがアクティブかどうかをチェックする。もしそうなら、リージョン内のテキストすべてをインデントするために@code{indent-region}を呼び出す(@ref{Region
Indent}を参照)。

@item
それ以外なら、@code{indent-line-function}内のインデント関数が@code{indent-to-left-margin}の場合、または変数@code{tab-always-indent}が挿入する文字としてタブ文字を指定する場合(以下参照)は、タブ文字を挿入する。

@item
それ以外なら、カレント行をインデントする。これは@code{indent-line-function}内の関数を呼び出すことにより行われる。その行がすでにインデント済みで、かつ@code{tab-always-indent}の値が@code{complete}(以下参照)なら、ポイント位置のテキストの補完を試みる。
@end itemize

@var{rigid}が非@code{nil}(インタラクティブな場合はプレフィクス引数)の場合、このコマンドが行をインデントした後、あるいはタブを挿入後、新たなインデントを反映するために、このコマンドはカレント行先頭にあるバランスされた式全体も厳正にインデントする。この引数は、コマンドがリージョンをインデントする場合は無視される。
@end deffn

@defvar indent-line-function
この変数の値はカレント行をインデントするために@code{indent-for-tab-command}、およびその他種々のインデントコマンドにより使用される関数である。これは通常メジャーモードにより割り当てられ、たとえばLispモードはこれを@code{lisp-indent-line}、Cモードは@code{c-indent-line}、のようにセットする。デフォルト値は@code{indent-relative}。@ref{Auto-Indentation}を参照のこと。
@end defvar

@deffn Command indent-according-to-mode
このコマンドは、カレントのメジャーモードに適した方法でカレント行をインデントするために、@code{indent-line-function}内の関数を呼び出す。
@end deffn

@deffn Command newline-and-indent
この関数は改行を挿入後、メジャーモードに応じて新たな行(挿入した改行の次の行)をインデントする。これは@code{indent-according-to-mode}を呼び出すことによりインデントを行う。
@end deffn

@deffn Command reindent-then-newline-and-indent
このコマンドは、カレント行の再インデント、ポイント位置への改行の挿入、その後新たな行(挿入した改行の次の行)のインデントを行う。これは@code{indent-according-to-mode}を呼び出すことにより、両方の行をインデントする。
@end deffn

@defopt tab-always-indent
この変数は、@key{TAB}(@code{indent-for-tab-command})コマンドの挙動のカスタマイズに使用できる。値が@code{t}(デフォルト)なら、コマンドは通常カレント行だけをインデントする。値が@code{nil}なら、コマンドはポイントが左マージン、またはその行のインデント内ににあるときのみ、カレント行をインデントし、それ以外はタブ文字を挿入する。値が@code{complete}なら、コマンドはまずカレント行のインデントを試み、その行がすでにインデント済みならポイント位置のテキストを補完するために@code{completion-at-point}を呼び出す(@ref{Completion
in Buffers}を参照)。
@end defopt


@node Region Indent
@subsection リージョン全体のインデント

  このセクションでは、リージョン内すべての行をインデントするコマンドを説明します。これらは予期せぬ値をリターンします。

@deffn Command indent-region start end &optional to-column
このコマンドは、@var{start}(含む)から@var{end}(含まず)で始まる非ブランク行すべてをインデントする。@var{to-column}が@code{nil}なら、@code{indent-region}はカレントモードのインデント関数、すなわち@code{indent-line-function}の値を呼び出すことにより、非ブランク行すべてをインデントする。

@var{to-column}が非@code{nil}なら、それはインデントの列数を指定する整数であること。その場合、この関数は空白文字を追加もしくは削除することにより、正確にその量のインデントを各行に与える。

フィルプレフィクスがある場合、@code{indent-region}はそのフィルプレフィクスで開始されるように、各行をインデントする。
@end deffn

@defvar indent-region-function
この変数の値は、ショートカットとして@code{indent-region}により使用されるかもしれない関数である。その関数はリージョンの開始と終了という、2つの引数をとること。その関数はリージョンの行を1行ずつインデントするときと同じような結果を生成するようにデザインするべきだが、おそらくより高速になるであろう。

値が@code{nil}ならショートカットは存在せず、@code{indent-region}は実際に1行ずつ機能する。

ショートカット関数は、@code{indent-line-function}が関数定義先頭をスキャンしなければならない、CモードやLispモードのようなモードに有用で、それを各行に適用するためには行数の2乗に比例する時間を要するだろう。ショートカットは各行のインデントとともに移動してスキャン情報を更新でき、それは線形時間である。行を個別にインデントするのが高速なモードでは、ショートカットの必要性はない。

引数@var{to-column}が非@code{nil}の@code{indent-region}では意味は異なり、この変数は使用しない。
@end defvar

@deffn Command indent-rigidly start end count
This function indents all lines starting between @var{start} (inclusive) and
@var{end} (exclusive) sideways by @var{count} columns.  This preserves the
shape of the affected region, moving it as a rigid unit.

これはインデントされていないテキストリージョンのインデントだけでなく、フォーマット済みコードのリージョンにたいするインデントにも有用である。たとえば@var{count}が3なら、このコマンドは指定されたリージョン内で始まるすべての行のインデントに3を追加する。

プレフィクス引数なしでインタラクティブに呼び出された場合、このコマンドはインデントを厳密に調整するために、Transient
Markモードを呼び出す。@ref{Indentation Commands,,, emacs, The GNU Emacs
Manual}を参照のこと。
@end deffn

@deffn Command indent-code-rigidly start end columns &optional nochange-regexp
これは@code{indent-rigidly}と似ているが、文字列やコメントで始まる行を変更しない点が異なる。

加えて、(@var{nochange-regexp}が非@code{nil}の場合)@var{nochange-regexp}が行先頭にマッチすれば、その行を変更しない。
@end deffn

@node Relative Indent
@subsection 前行に相対的なインデント

  このセクションでは、前の行のコンテンツにもとづいてカレント行をインデントする、コマンドを2つ説明します。

@deffn Command indent-relative &optional unindented-ok
このコマンドは、前の非ブランク行の次の@dfn{インデントポイント(indent
point)}と同じ列に拡張されるように、ポイント位置に空白文字を挿入する。インデントポイントとは、後に空白文字をともなった非空白文字である。次のインデントポイントは、ポイントのカレント列より大きい、最初のインデントポイントになる。たとえばポイントがテキスト行の最初の非ブランク文字の下と左にある場合、空白文字を挿入してその列に移動する。

前の非ブランク行に次のインデントポイントがない(列の位置が十分大きくない)場合は、(@var{unindented-ok}が非@code{nil}なら)何もしないか、あるいは@code{tab-to-tab-stop}を呼び出す。したがって、ポイントが短いテキスト行の最後の列の下と右にある場合、このコマンドは通常は空白文字を挿入することにより、次のタブストップにポイントを移動する。

@code{indent-relative}のリターン値は予測できない。

以下の例では、ポイントは2行目の先頭にある:

@example
@group
            This line is indented twelve spaces.
@point{}The quick brown fox jumped.
@end group
@end example

@noindent
式@code{(indent-relative nil)}の評価により、以下が生成される:

@example
@group
            This line is indented twelve spaces.
            @point{}The quick brown fox jumped.
@end group
@end example

  次の例では、ポイントは@samp{jumped}の@samp{m}と@samp{p}の間にある:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum@point{}ped.
@end group
@end example

@noindent
式@code{(indent-relative nil)}の評価により、以下が生成される:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum  @point{}ped.
@end group
@end example
@end deffn

@deffn Command indent-relative-maybe
@comment !!SourceFile indent.el
このコマンドは、引数@var{unindented-ok}に@code{t}を指定して@code{indent-relative}を呼び出すことにより、前の非ブランク行に倣ってカレント行をインデントする。リターン値は予測できない。

カレント列より先のインデントポイントが前の非ブランク行に存在しなければ、このコマンドは何もしない。
@end deffn

@node Indent Tabs
@subsection Adjustable Tab Stops
@cindex tabs stops for indentation

  This section explains the mechanism for user-specified tab stops and the
mechanisms that use and set them.  The name ``tab stops'' is used because
the feature is similar to that of the tab stops on a typewriter.  The
feature works by inserting an appropriate number of spaces and tab
characters to reach the next tab stop column; it does not affect the display
of tab characters in the buffer (@pxref{Usual Display}).  Note that the
@key{TAB} character as input uses this tab stop feature only in a few major
modes, such as Text mode.  @xref{Tab Stops,,, emacs, The GNU Emacs Manual}.

@deffn Command tab-to-tab-stop
このコマンドは、@code{tab-stop-list}により定義される次のタブストップ列まで、ポイント前にスペースまたはタブを挿入する。
@end deffn

@defopt tab-stop-list
この変数は、@code{tab-to-tab-stop}により使用されるタブストップ列を定義する。これは@code{nil}、もしくは増加(均等に増加する必要はない)していく整数のリストであること。このリストは暗黙に、最後の要素と最後から2番目の要素の間隔(またはリストの要素が2未満なら@code{tab-width})を繰り返すことにより、無限に拡張される。値@code{nil}は、列@code{tab-width}ごとにタブストップすることを意味する。

インタラクティブにタブストップの位置を編集するには、@kbd{M-x edit-tab-stops}を使用すればよい。
@end defopt

@node Motion by Indent
@subsection インデントにもとづくモーションコマンド

  以下のコマンドは主にインタラクティブに使用され、テキスト内のインデントにもとづいて動作します。

@deffn Command back-to-indentation
@comment !!SourceFile simple.el
このコマンドは、カレント行(ポイントのある行のこと)の最初の非空白文字にポイントを移動する。リターン値は@code{nil}。
@end deffn

@deffn Command backward-to-indentation &optional arg
@comment !!SourceFile simple.el
このコマンドは、後方へ@var{arg}行ポイントを移動した後に、その行の最初の非ブランク文字にポイントを移動する。リターン値は@code{nil}。@var{arg}が省略または@code{nil}のときのデフォルトは1。
@end deffn

@deffn Command forward-to-indentation &optional arg
@comment !!SourceFile simple.el
このコマンドは、前方へ@var{arg}行ポイントを移動した後に、その行の最初の非ブランク文字にポイントを移動する。リターン値は@code{nil}。@var{arg}が省略または@code{nil}のときのデフォルトは1。
@end deffn

@node Case Changes
@section 大文字小文字の変更
@cindex case conversion in buffers

  ここで説明する大文字小文字変換コマンドは、カレントバッファー内のテキストに作用します。文字列と文字の大文字小文字変換コマンドは@ref{Case
Conversion}、大文字または小文字に変換する文字や、その変換方法のカスタマイズは@ref{Case Tables}を参照してください。

@deffn Command capitalize-region start end
この関数は@var{start}と@var{end}で定義されるリージョン内のすべての単語をcapitalizeする。capitalizeとは、各単語の最初の文字を大文字、残りの文字を小文字に変換することを意味する。この関数は@code{nil}をリターンする。

リージョンのいずれかの端が単語の中間にある場合は、リージョン内にある部分を単語全体として扱う。

インタラクティブに@code{capitalize-region}が呼び出された際は、@var{start}と@var{end}はポイントとマークになり、小さいほうが先になる。

@example
@group
---------- Buffer: foo ----------
This is the contents of the 5th foo.
---------- Buffer: foo ----------
@end group

@group
(capitalize-region 1 37)
@result{} nil

---------- Buffer: foo ----------
This Is The Contents Of The 5th Foo.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command downcase-region start end
この関数は、@var{start}と@var{end}で定義されるリージョン内のすべての英文字を小文字に変換する。この関数は@code{nil}をリターンする。

インタラクティブに@code{downcase-region}が呼び出された際は、@var{start}と@var{end}はポイントとマークになり、小さいほうが先になる。
@end deffn

@deffn Command upcase-region start end
この関数は、@var{start}と@var{end}で定義されるリージョン内のすべての英文字を大文字に変換する。この関数は@code{nil}をリターンする。

インタラクティブに@code{upcase-region}が呼び出された際は、@var{start}と@var{end}はポイントとマークになり、小さいほうが先になる。
@end deffn

@deffn Command capitalize-word count
この関数は、ポイントの後の@var{count}単語をcapitalizeして、変換後その後にポイントを移動する。capitalizeとは、各単語の先頭を大文字、残りを小文字に変換することを意味する。@var{count}が負なら、この関数は前の@minus{}@var{count}単語をcapitalizeするが、ポイントは移動しない。値は@code{nil}。

ポイントが単語の中間にある場合、ポイントの前にある単語部分は、前方に移動する際は無視される。そして残りの部分が単語全体として扱われる。

インタラクティブに@code{capitalize-word}が呼び出された際は、@var{count}に数プレフィクス引数がセットされる。
@end deffn

@deffn Command downcase-word count
この関数は、ポイントの後の@var{count}単語を小文字に変換して、変換後その後にポイントを移動する。@var{count}が負なら、この関数は前の@minus{}@var{count}単語を小文字に変換するが、ポイントは移動しない。値は@code{nil}。

インタラクティブに@code{downcase-word}が呼び出された際は、@var{count}に数プレフィクス引数がセットされる。
@end deffn

@deffn Command upcase-word count
この関数は、ポイントの後の@var{count}単語を大文字に変換して、変換後その後にポイントを移動する。@var{count}が負なら、この関数は前の@minus{}@var{count}単語を小文字に変換するが、ポイントは移動しない。値は@code{nil}。

インタラクティブに@code{upcase-word}が呼び出された際は、@var{count}に数プレフィクス引数がセットされる。
@end deffn

@node Text Properties
@section テキストのプロパティ
@cindex text properties
@cindex attributes of text
@cindex properties of text

  バッファーや文字列内の各文字位置は、シンボルにおけるプロパティリスト(@ref{Property
Lists}を参照)のように、@dfn{テキストプロパティリスト(text property
list)}をもつことができます。特定の位置の特定の文字に属するプロパティ、たとえばこのセンテンス先頭の文字@samp{T}(訳注:
翻訳前のセンテンスは"The properties belong to a
..."で始まる)、または@samp{foo}の最初の@samp{o}など、もし同じ文字が異なる2箇所に存在する場合、2つの文字は一般的に異なるプロパティをもちます。

  それぞれのプロパティには、名前と値があります。どちらも任意のLispオブジェクトをもつことができますが、名前は通常はシンボルです。典型的には、それぞれのプロパティ名シンボルは、特定の目的のために使用されます。たとえば、テキストプロパティ@code{face}は、文字を表示するためのフェイスを指定します(@ref{Special
Properties}を参照)。名前を指定してそれに対応する値を尋ねるのが、このプロパティリストにアクセスするための通常の方法です。

  ある文字が@code{category}プロパティをもつ場合は、それをその文字の@dfn{プロパティカテゴリー(property
category)}と呼びます。これはシンボルであるべきです。そのシンボルのプロパティは、その文字のプロパティにたいしてデフォルトとしての役割をもちます。

  文字列とバッファーの間でテキストをコピーには、文字とともにそのプロパティが保持されます。これには@code{substring}、@code{insert}、@code{buffer-substring}のようなさまざまな関数が含まれます。

@menu
* Examining Properties::     単一の文字のプロパティを調べる。
* Changing Properties::      テキスト範囲のプロパティをセットする。
* Property Search::          プロパティが値を変更する場所の検索。
* Special Properties::       特別な意味をもつ特定のプロパティ。
* Format Properties::        テキストのフォーマットを表すプロパティ。
* Sticky Properties::        挿入されたテキストが隣接するテキストからプロパティを取得する方法。
* Lazy Properties::          テキストが調べられる際のみ、ものぐさな方法でテキストプロパティを計算する。
* Clickable Text::           テキストプロパティを使用して、テキストリージョンがクリック時に何か行うようにする。
* Fields::                   バッファー内にフィールドを定義する@code{field}プロパティ。
* Not Intervals::            テキストプロパティがLispから可視なテキスト間隔をもたない理由。
@end menu

@node Examining Properties
@subsection テキストプロパティを調べる
@cindex examining text properties
@cindex text properties, examining

  テキストプロパティを調べるもっともシンプルな方法は、特定の文字の特定のプロパティの値を尋ねる方法です。これを行うには、@code{get-text-property}を使用します。ある文字のプロパティリスト全体を取得するには、@code{text-properties-at}を使用します。複数の文字のプロパティを一度に調べる関数については、@ref{Property
Search}を参照してください。

  以下の関数は、文字列とバッファーの両方を処理します。バッファー内の位置は1から始まりますが、文字列内の位置は0から始まることに留意してください。

@defun get-text-property pos prop &optional object
この関数は、@var{object}(バッファーまたは文字列)内の位置@var{pos}の後にある文字のプロパティ@var{prop}の値をリターンする。引数@var{object}はオプションで、デフォルトはカレントバッファー。

厳密な意味で@var{prop}プロパティが存在しないが、その文字がシンボルであるようなプロパティカテゴリーをもつなら、@code{get-text-property}はそのシンボルの@var{prop}プロパティをリターンする。
@end defun

@defun get-char-property position prop &optional object
この関数は@code{get-text-property}と似ているが、まずオーバーレイをチェックして、次にテキストプロパティをチェックする点が異なる。@ref{Overlays}を参照のこと。

引数@var{object}は文字列、バッファー、あるいはウィンドウかもしれない。ウィンドウならそのウィンドウ内に表示されているバッファーのテキストプロパティとオーバーレイが使用されるが、そのウィンドウにたいしてアクティブなオーバーレイだけが考慮される。@var{object}がバッファーなら、そのバッファー内のオーバーレイがまず優先順に考慮され、その後にテキストプロパティが考慮される。@var{object}が文字列の場合？文字列は決してオーバーレイをもたないので、テキストプロパティだけが考慮される。
@end defun

@defun get-pos-property position prop &optional object
This function is like @code{get-char-property}, except that it pays
attention to properties' stickiness and overlays' advancement settings
instead of the property of the character at (i.e., right after)
@var{position}.
@end defun

@defun get-char-property-and-overlay position prop &optional object
これは@code{get-char-property}と似ているが、そのプロパティ値が由来するオーバーレイについて追加情報を与える点が異なる。

その値は@sc{car}がプロパティ値であるようなコンスセルで、同じ引数により@code{get-char-property}がリターンするであろう値と同じである。@sc{cdr}はそのプロパティが見つかった箇所のオーバーレイ、またはテキストプロパティとして見つかった場合や見つからなかった場合は@code{nil}である。

@var{position}が@var{object}の終端なら、@sc{car}と@sc{cdr}の値はどちらも@code{nil}になる。
@end defun

@defvar char-property-alias-alist
この変数は、プロパティ名と代替となるプロパティ名リストをマップするalistを保持する。文字があるプロパティにたいして直接値を指定しなければ、順に代替プロパティ名が調べられ、最初の非@code{nil}値が使用される。この変数は@code{default-text-properties}より優先され、この変数より@code{category}プロパティが優先される。
@end defvar

@defun text-properties-at position &optional object
この関数は、文字列またはバッファー@var{object}内の位置@var{position}にある文字のプロパティリスト全体をリターンする。@var{object}が@code{nil}なら、デフォルトはカレントバッファーとなる。
@end defun

@defvar default-text-properties
この変数は、テキストプロパティにたいしてデフォルト値を与えるプロパティリストを保持する。あるプロパティにたいして文字が直接、あるいはカテゴリーシンボルまたは@code{char-property-alias-alist}を通じて値を指定しないときは常に、このリストに格納された値がかわりに使用される。以下は例である:

@example
(setq default-text-properties '(foo 69)
      char-property-alias-alist nil)
;; @r{文字1は自身のプロパティをもたない}
(set-text-properties 1 2 nil)
;; @r{取得される値はデフォルト値である}
(get-text-property 1 'foo)
     @result{} 69
@end example
@end defvar

@node Changing Properties
@subsection テキストプロパティの変更
@cindex changing text properties
@cindex text properties, changing

  プロパティを変更するプリミティブは、バッファーまたは文字列内の指定されたテキスト範囲に適用されます。関数@code{set-text-properties}(セクションの最後を参照)は、その範囲内のテキストのプロパティリスト全体をセットします。名前を指定することにより特定のプロパティだけを追加、変更、削除するのにも、より有用です。

  テキストプロパティはバッファー(または文字列)のコンテンツの一部とみなされ、かつスクリーン上でのバッファーの見栄えに影響を与えることができるので、バッファー内のテキストプロパティの変更はすべて、バッファーを変更済みとマークします。バッファーテキストプロパティの変更も、アンドゥできます(@ref{Undo}を参照)。バッファー内の位置は1から始まりますが、文字列内の位置は0から始まります。

@defun put-text-property start end prop value &optional object
この関数は、文字列またはバッファー@var{object}内の@var{start}と@var{end}の間のテキストにたいして、プロパティ@var{prop}に@var{value}をセットする。@var{object}が@code{nil}なら、デフォルトはカレントバッファーである。
@end defun

@defun add-text-properties start end props &optional object
この関数は、文字列またはバッファー@var{object}内の@var{start}と@var{end}の間のテキストにたいして、テキストプロパティを追加またはオーバーライドする。@var{object}が@code{nil}なら、デフォルトはカレントバッファーである。

引数@var{props}は、追加するプロパティを指定する。これはプロパティリストの形式(@ref{Property
Lists}を参照)、つまりプロパティ名と対応する値が交互に出現するような要素を含むリストであること。

関数が実際に何らかのプロパティの値を変更したら@code{t}、それ以外(@var{props}が@code{nil}、またはプロパティの値がテキスト内のプロパティの値と一致している場合)は@code{nil}がリターン値となる。

たとえば、以下はテキストの範囲に@code{comment}と@code{face}のプロパティをセットする例である:

@example
(add-text-properties @var{start} @var{end}
                     '(comment t face highlight))
@end example
@end defun

@defun remove-text-properties start end props &optional object
この関数は、文字列またはバッファー@var{object}内の@var{start}と@var{end}の間のテキストから、指定されたテキストプロパティを削除する。@var{object}が@code{nil}なら、デフォルトはカレントバッファーとなる。

引数@var{props}は、削除するプロパティを指定する。これはプロパティリストの形式(@ref{Property
Lists}を参照)、つまりプロパティ名と対応する値が交互に出現するような要素を含むリストであること。しかし問題となるのは名前であり、付随する値は無視される。たとえば@code{face}プロパティを削除するには、以下のようにすればよい。

@example
(remove-text-properties @var{start} @var{end} '(face nil))
@end example

関数が実際に何らかのプロパティの値を変更したら@code{t}、それ以外(@var{props}が@code{nil}、または指定されたテキスト内にそれらのプロパティをもつ文字がない場合)は@code{nil}がリターン値となる。

特定のテキストからすべてのテキストプロパティを削除するには、新たなプロパティリストに@code{nil}を指定して、@code{set-text-properties}を使用すればよい。
@end defun

@defun remove-list-of-text-properties start end list-of-properties &optional object
@code{remove-text-properties}と同様だが、@var{list-of-properties}がプロパティ名と値が交互になったリストではなく、プロパティ名だけのリストである点が異なる。
@end defun

@defun set-text-properties start end props &optional object
この関数は、文字列またはバッファー@var{object}内の@var{start}から@var{end}の間のテキストにたいするテキストプロパティリストを、完全に置き換える。@var{object}が@code{nil}なら、デフォルトはカレントバッファーとなる。

引数@var{props}は新たなプロパティリスト。これはプロパティメジャーと対応する値が交互となるような要素のリストであること。

@code{set-text-properties}のリターン後は、指定された範囲内のすべての文字は、等しいプロパティをもつ。

@var{props}が@code{nil}なら、指定されたテキスト範囲からすべてのプロパティを取り除く効果がある。以下は例である:

@example
(set-text-properties @var{start} @var{end} nil)
@end example

この関数のリターン値を信用してはならない。
@end defun

@defun add-face-text-property start end face &optional appendp object
この関数は@var{start}と@var{end}の間のテキストのテキストプロパティ@code{face}にフェイス@var{face}を追加するよう動作する。@var{face}はフェイス名もしくはanonymousフェイス(anonymous
face: 無名フェイス)のような、@code{face}プロパティ(@ref{Special
Properties}を参照)にたいして有効な値であること(@ref{Faces}を参照)。

リージョン内の任意のテキストがすでに非@code{nil}の@code{face}プロパティをもつ場合、それらのフェイスは保たれる。
If any text in the region already has a non-  property, those face(s) are
retained.
この関数は@code{face}プロパティに、最初の要素(デフォルト)が@var{face}、以前に存在していたフェイスが残りの要素であるような、フェイスのリストをセットする。オプション引数@var{append}が非@code{nil}なら、@var{face}はかわりにリストの最後に追加される。フェイスリスト内では、各属性にたいして最初に出現する値が優先されることに注意。

たとえば以下のコードでは、@var{start}と@var{end}の間のテキストに、グリーン斜体のフェイスを割り当てるだろう:

@example
(add-face-text-property @var{start} @var{end} 'italic)
(add-face-text-property @var{start} @var{end} '(:foreground "red"))
(add-face-text-property @var{start} @var{end} '(:foreground "green"))
@end example

オプション引数@var{object}が非@code{nil}なら、それはカレントバッファーではなく、動作するバッファーまたは文字列を指定する。@var{object}が文字列なら、@var{start}と@var{end}は0基準で文字列内をインデックス付けする。
@end defun

  文字列にテキストプロパティを付するもっとも簡単な方法は、@code{propertize}です:

@defun propertize string &rest properties
この関数は、テキストプロパティ@var{properties}を追加した、@var{string}のコピーをリターンする。これらのプロパティは、リターンされる文字列内のすべての文字に適用される。以下は、@code{face}プロパティと@code{mouse-face}プロパティとともに文字列を構築する例である:

@smallexample
(propertize "foo" 'face 'italic
            'mouse-face 'bold-italic)
     @result{} #("foo" 0 3 (mouse-face bold-italic face italic))
@end smallexample

文字列のさまざまな部分に異なるプロパティをputするんは、それぞれの部分を@code{propertize}で構築して、@code{concat}でそれらを結合すればよい:

@smallexample
(concat
 (propertize "foo" 'face 'italic
             'mouse-face 'bold-italic)
 " and "
 (propertize "bar" 'face 'italic
             'mouse-face 'bold-italic))
     @result{} #("foo and bar"
                 0 3 (face italic mouse-face bold-italic)
                 3 8 nil
                 8 11 (face italic mouse-face bold-italic))
@end smallexample
@end defun

  プロパティではなくバッファーからテキストをコピーする関数@code{buffer-substring-no-properties}については、@ref{Buffer
Contents}を参照してください。

@findex with-silent-modifications
  If you wish to add or remove text properties to a buffer without marking the
buffer as modified, you can wrap the calls above in the
@code{with-silent-modifications} macro.

@node Property Search
@subsection テキストプロパティの検索関数
@cindex searching text properties
@cindex text properties, searching

  テキストプロパティの通常の使用では、ほとんどの場合は複数または多くの連続する文字が、同じ値のプロパティをもちます。文字を1つずつ調べるプログラムを記述するよりも、同じプロパティ値をもつテキスト塊(chunks
of text)を処理するほうが、より高速です。

  以下は、これを行うことに使用できる関数です。これらは、プロパティ値の比較に@code{eq}を使用します。すべての関数において、@var{object}のデフォルトはカレントバッファーです。

  より良いパフォーマンスのためには、特に単一のプロパティを検索する関数においては、@var{limit}引数の使用が重要です。そうしないと、興味のあるプロパティが変化しない場合に、バッファー終端までのスキャンに長い時間を要するでしょう。

  これらの関数はポイントを移動しません。そのかわりに位置(または@code{nil})をリターンします。ポイントは常に文字と文字の間にあることを思い出してください。これらの関数によりリターンされる位置は、異なるプロパティをもつ、2つの文字の間にあります。

@defun next-property-change pos &optional object limit
この関数は文字列またはバッファー@var{object}内の位置@var{pos}から、何らかのテキストプロパティの変化が見つかるまで、テキストを前方にスキャンして、変化のあった位置をリターンする。言い換えると、@var{pos}の直後の文字とプロパティが等しくない、@var{pos}の先にある最初の文字の位置をリターンする。

@var{limit}が非@code{nil}なら、スキャンは位置@var{limit}で停止する。そのポイントより前にプロパティが変化しなければ、この関数は@var{limit}をリターンする。

プロパティが@var{object}終端まで変化せず、かつ@var{limit}が@code{nil}なら、値は@code{nil}となる。値が非@code{nil}なら、それは@var{pos}以上の位置である。@var{limit}が@var{pos}と等しいときのみ、値は@var{pos}になる。

以下は、すべてのプロパティが定数であるようなテキスト塊によりバッファーをスキャンする方法の例である:

@smallexample
(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    @r{ポイントから@var{next-change}へテキストを処理@dots{}}
    (goto-char next-change)))
@end smallexample
@end defun

@defun previous-property-change pos &optional object limit
これは@code{next-property-change}と似ているが、@var{pos}から前方ではなく後方にスキャンする点が異なる。値が非@code{nil}なら、それは@var{pos}以下の位置である。@var{limit}と@var{pos}が等しい場合のみ、@var{pos}をリターンする。
@end defun

@defun next-single-property-change pos prop &optional object limit
この関数はプロパティ@var{prop}内の変化についてテキストをスキャンして、変化があった位置をリターンする。このスキャンは、文字列またはバッファー@var{object}内の位置@var{pos}から、前方に行われる。言い換えると、@var{pos}の直後の文字とプロパティ@var{prop}が等しくない、@var{pos}の先にある最初の文字の位置をリターンする。

@var{limit}が非@code{nil}なら、スキャンは位置@var{limit}で終了する。そのポイントより前にプロパティの変化がなければ、@code{next-single-property-change}は@var{limit}をリターンする。

プロパティが@var{object}終端まで変化せず、かつ@var{limit}が@code{nil}なら、値は@code{nil}となる。値が非@code{nil}なら、それは@var{pos}以上の位置である。@var{limit}が@var{pos}と等しいときのみ、値は@var{pos}になる。
@end defun

@defun previous-single-property-change pos prop &optional object limit
これは@code{next-single-property-change}と似ているが、@var{pos}から前方ではなく後方にスキャンする点が異なる。値が非@code{nil}なら、それは@var{pos}以下の位置である。@var{limit}と@var{pos}が等しい場合のみ、@var{pos}をリターンする。
@end defun

@defun next-char-property-change pos &optional limit
@code{next-property-change}と似ているが、これはテキストプロパティと同様オーバーレイも考慮し、バッファー終端より前に変化が見つからなければ、@code{nil}ではなくバッファー位置の最大をリターンする点が異なる(この点では@code{next-property-change}よりも対応するオーバーレイ関数@code{next-overlay-change}と似る)。この関数はカレントバッファーだけを処理するので、@var{object}オペランドは存在しない。これは、いずれかの種類のプロパティが変化した、次のアドレスをリターンする。
@end defun

@defun previous-char-property-change pos &optional limit
これは@code{next-char-property-change}と似ているが、@var{pos}から前方ではなく後方へスキャンすること、および変化が見つからなければバッファー位置の最小をリターンする点が異なる。
@end defun

@defun next-single-char-property-change pos prop &optional object limit
@code{next-single-property-change}と似ているが、これはテキストプロパティと同様オーバーレイも考慮し、@var{object}終端より前に変化が見つからなければ、@code{nil}ではなく@var{object}内の有効な位置の最大をリターンする点が異なる。@code{next-char-property-change}と異なり、、この関数は@var{object}オペランドを@emph{もつ}。@var{object}が非バッファーなら、テキストプロパティだけが考慮される。
@end defun

@defun previous-single-char-property-change pos prop &optional object limit
これは@code{next-single-char-property-change}と似ているが、@var{pos}から前方ではなく後方へスキャンすること、および変化が見つからなければ@var{object}内の有効な位置の最小をリターンする点が異なる。
@end defun

@defun text-property-any start end prop value &optional object
この関数は、@var{start}と@var{end}の間に少なくともプロパティ@var{prop}に値@var{value}をもつ文字が1つあれば、非@code{nil}をリターンする。より正確には、これはそのような最初の文字の位置をリターンし、それ以外は@code{nil}をリターンする。

5つ目のオプション引数@var{object}は、スキャンする文字列またはバッファーを指定する。位置は@var{object}にたいして相対的である。@var{object}のデフォルトは、カレントバッファー。
@end defun

@defun text-property-not-all start end prop value &optional object
この関数は、@var{start}と@var{end}の間に少なくともプロパティ@var{prop}に値@var{value}をもたない文字が1つあれば、非@code{nil}をリターンする。より正確には、これはそのような最初の文字の位置をリターンし、それ以外は@code{nil}をリターンする。

5つ目のオプション引数@var{object}は、スキャンする文字列またはバッファーを指定する。位置は@var{object}にたいして相対的である。@var{object}のデフォルトは、カレントバッファー。
@end defun

@node Special Properties
@subsection 特殊な意味をもつプロパティ

  以下は、ビルトインで特別な意味をもつテキストプロパティ名のテーブルです。以降のセクションでは、フィルとプロパティ継承を制御する特別なプロパティ名をいくつか追加でリストしています。これ以外のすべての名前は特別な意味をもたず、自由に使用できます。

  注意:
プロパティ@code{composition}、@code{display}、@code{invisible}、@code{intangible}はすべてのEmacsコマンドの後に、好ましい箇所にポイントを移動させることもできます。@ref{Adjusting
Point}を参照してください。

@table @code
@cindex property category of text character
@c FIXME: Isn't @kindex for keyboard commands?
@kindex category @r{(text property)}
@item category
ある文字が@code{category}プロパティをもつ場合は、それをその文字の@dfn{プロパティカテゴリー(property
category)}と呼びます。これはシンボルであること。このシンボルのプロパティは、その文字のプロパティのデフォルトとしての役割をもつ。

@item face
@cindex face codes of text
@kindex face @r{(text property)}
@code{face}プロパティはその文字の外観を制御する(@ref{Faces}を参照)。このプロパティの値は、以下をとることができる:

@itemize @bullet
@item
フェイス名(シンボルか文字列)。

@item
anonymousフェイス: @code{(@var{keyword} @var{value}
@dots{})}形式のプロパティリスト。@var{keyword}はそれぞれフェイス属性名で、@var{value}はその属性の値。

@item
フェイスのリスト。各リスト要素はフェイス名かanonymousフェイスであること。これはリストされた各フェイス属性を集計したフェイスを指定する。このリスト内で最初にあるフェイスが、より高い優先度をもつ。

@item
@code{(foreground-color . @var{color-name})}または@code{(background-color
. @var{color-name})}形式のコンスセル。これは@code{(:foreground
@var{color-name})}や@code{(:background
@var{color-name})}と同じようにフォアグラウンドまたはバックグラウンドを指定する。この形式は後方互換のためだけにサポートされており、無視するべきである。
@end itemize

Font Lockモード(@ref{Font Lock
Mode}を参照)はほとんどのバッファーにおいて、コンテキストにもとづき文字の@code{face}プロパティを動的に更新することにより機能する。

@code{add-face-text-property}関数は、このプロパティをセットする便利な手段を提供する。@ref{Changing
Properties}を参照のこと。

@item font-lock-face
@kindex font-lock-face @r{(text property)}
このプロパティは、Font Lockモードが配下にあるテキストに適用すべき@code{face}プロパティにたいして値を指定する。これはFont
Lockモードに使用されるフォント表示手法の1つであり、独自のハイライトを実装する特別なモードにたいして有用である。@ref{Precalculated
Fontification}を参照のこと。Font Lockモードが無効なら、@code{font-lock-face}に効果はない。

@item mouse-face
@kindex mouse-face @r{(text property)}
このプロパティは、文字上または近傍にマウスがあるとき、@code{face}のかわりに使用される。この目的にたいして``近傍''とは、文字間のすべてのテキスト、およびマウスが同じ@code{mouse-face}プロパティの値をもつことを意味する。

Emacsはテキストサイズ(@code{:height}、@code{:weight}、@code{:slant})を変更する@code{mouse-face}プロパティ由来の属性すべてを無視する。これらの属性は、ハイライトされていないテキストと常に等しい。

@item fontified
@kindex fontified @r{(text property)}
This property says whether the text is ready for display.  If @code{nil},
Emacs's redisplay routine calls the functions in
@code{fontification-functions} (@pxref{Auto Faces}) to prepare this part of
the buffer before it is displayed.  It is used internally by the
just-in-time font locking code.

@item display
このプロパティは、テキストが表示される方法を変更する、さまざまな機能をアクティブ化する。たとえばこれによりテキスト外観を縦長(taller)または縦短(short)したり、高く(higher)または低く(lower)、太く(wider)または細く(narrower)したり、あるいはイメージに置き換えることができる。@ref{Display
Property}を参照のこと。

@item help-echo
@kindex help-echo @r{(text property)}
@cindex tooltip for help strings
@anchor{Text help-echo}
If text has a string as its @code{help-echo} property, then when you move
the mouse onto that text, Emacs displays that string in the echo area, or in
the tooltip window (@pxref{Tooltips}).

@code{help-echo}プロパティの値が関数なら、その関数は@var{window}、@var{object}、@var{pos}の3つの引数で呼び出され、ヘルプ文字列、または存在しない場合は@code{nil}をリターンすること。1つ目の引数@var{window}は、そのヘルプが見つかったウィンドウである。2つ目の引数@var{object}は、@code{help-echo}プロパティをもつバッファー、オーバーレイ、または文字列である。@var{pos}引数は以下のとおり:

@itemize @bullet{}
@item
@var{object}がバッファーなら、@var{pos}はそのバッファー内の位置。
@item
@var{object}がオーバーレイなら、そのオーバーレイは@code{help-echo}プロパティをもち、@var{pos}はそのオーバーレイのバッファー内の位置である。
@item
@var{object}が文字列(オーバーレイ文字列、または@code{display}プロパティにより表示された文字列)なら、@var{pos}はその文字列内の位置。
@end itemize

@code{help-echo}プロパティの値が関数と文字列のいずれでもない場合、それはヘルプ文字列を得るために評価される。

変数@code{show-help-function}をセットすることにより、ヘルプテキストが表示される方法を変更できる(@ref{Help
display}を参照)。

この機能はモードライン内、およびその他のアクティブテキストにたいして使用される。

@item keymap
@cindex keymap of character
@kindex keymap @r{(text property)}
@code{keymap}プロパティは、コマンドにたいして追加のキーマップを指定する。このキーマップを適用する際は、マイナーモードキーマップおよびバッファーのローカルマップの前に、キー照合にこのマップが使用される。@ref{Active
Keymaps}を参照のこと。プロパティ値がシンボルなら、そのシンボルの関数定義がキーマップとして使用される。

ポイントの前の文字のプロパティの値は、それが非@code{nil}でrear-stickyであり、かつポイントの後の文字のプロパティ値が非@code{nil}でfront-stickyなら適用される(マウスクリックではポイント位置のかわりにクリック位置が使用される)。

@item local-map
@kindex local-map @r{(text property)}
このプロパティは@code{keymap}と同じように機能するが、これはそのバッファーのローカルマップの@emph{かわりに}使用するキーマップを指定する点が異なる。ほとんど(もしかするとすべて)の目的にたいしては、@code{keymap}を使用するほうが良いだろう。

@item syntax-table
@code{syntax-table}プロパティは、特定の文字にたいして、どのシンタックステーブルがオーバーライドするかを告げる。@ref{Syntax
Properties}を参照のこと。

@item read-only
@cindex read-only character
@kindex read-only @r{(text property)}
ある文字がプロパティ@code{read-only}をもつなら、その文字の変更は許可されない。これを行おうとするすべてのコマンドは、@code{text-read-only}エラーを受け取る。プロパティの値が文字列なら、その文字列がエラーメッセージとして使用される。

read-only文字に隣接する箇所への挿入は、そこに通常のテキストの行うことがstickinessによる@code{read-only}プロパティを継承するなら、エラーとなる。つまりstickinessを制御することにより、read-onlyテキストに隣接する挿入の権限を制御することができる。@ref{Sticky
Properties}を参照のこと。

プロパティ変更はバッファー変更とみなされるので、特別なトリック(@code{inhibit-read-only}を非@code{nil}にバインドしてからプロパティを削除する)を知らないかぎり、@code{read-only}プロパティを取り除くことは不可能である。@ref{Read
Only Buffers}を参照のこと。

@item inhibit-read-only
@kindex inhibit-read-only @r{(text property)}
Characters that have the property @code{inhibit-read-only} can be edited
even in read-only buffers.  @xref{Read Only Buffers}.

@item invisible
@kindex invisible @r{(text property)}
非@code{nil}の@code{invisible}プロパティにより、スクリーン上で文字を不可視にできる。詳細は@ref{Invisible
Text}を参照されたい。

@item intangible
@kindex intangible @r{(text property)}
連続する文字のグループが非@code{nil}の等しい@code{intangible}プロパティをもつなら、それらの文字の間にポイントを置くことは不可能である。そのグループ内に前方へポイントの移動を試みると、ポイントは実際にはそのグループの終端に移動する。そのグループ内に後方へポイントの移動を試みると、ポイントは実際にはそのグループの先頭に移動する。

連続する文字のグループが非@code{nil}の等しくない@code{intangible}プロパティをもつなら、それらの文字は個別のグループに属し、各グループは上述のように別のグループとして扱われる。

When the variable @code{inhibit-point-motion-hooks} is non-@code{nil} (as it
is by default), the @code{intangible} property is ignored.

Beware: this property operates at a very low level, and affects a lot of
code in unexpected ways.  So use it with extreme caution.  A common misuse
is to put an intangible property on invisible text, which is actually
unnecessary since the command loop will move point outside of the invisible
text at the end of each command anyway.  @xref{Adjusting Point}.  For these
reasons, this property is obsolete; use the @code{cursor-intangible}
property instead.

@item cursor-intangible
@kindex cursor-intangible @r{(text property)}
@findex cursor-intangible-mode
When the minor mode @code{cursor-intangible-mode} is turned on, point is
moved away of any position that has a non-@code{nil}
@code{cursor-intangible} property, just before redisplay happens.

@item field
@kindex field @r{(text property)}
同じ@code{field}プロパティをもつ連続する文字は、@dfn{フィールド}を構成する。@code{forward-word}や@code{beginning-of-line}を含むいくつかの移動関数は、フィールド境界で移動を停止する。@ref{Fields}を参照のこと。

@item cursor
@kindex cursor @r{(text property)}
カーソルは通常、カレントバッファー位置にあるオーバーレイ、およびテキストプロパティ文字列の先頭か終端に表示される。文字に非@code{nil}の@code{cursor}テキストプロパティを与えることにより、それら文字列内の、任意の望む文字にカーソルを置くことができる。加えて@code{cursor}プロパティの値が整数なら、それはカーソルがその文字上に表示されるように、オーバーレイまたは@code{display}プロパティが始まる位置から数えたバッファーの文字位置の数字を指定する。特に、ある文字の@code{cursor}プロパティの値が数字@var{n}なら、カーソルは範囲@code{[@var{ovpos}..@var{ovpos}+@var{n})}内の任意のバッファー位置にあるその文字上に表示されるだろう。ここで@var{ovpos}は@code{overlay-start}(@ref{Managing
Overlays}を参照)により与えられるオーバーレイ開始位置、またはそのバッファー内で@code{display}プロパティが始まる位置である。

言い換えると、文字列の非@code{nil}値の@code{cursor}プロパティをもつ文字は、カーソルが表示される文字である。このプロパティの値は、カーソルを表示するバッファーの位置を告げる。値が整数なら、オーバーレイまたは@code{display}プロパティの始まりから@var{n}後ろの位置までの間にポイントがあるとき、カーソルはそこに表示される。値がそれ以外の非@code{nil}なら、ポイントが@code{display}プロパティの先頭、または@code{overlay-start}の位置だけに表示される。

@cindex cursor position for @code{display} properties and overlays
When the buffer has many overlay strings (e.g., @pxref{Overlay Properties,
before-string}) that conceal some of the buffer text or @code{display}
properties that are strings, it is a good idea to use the @code{cursor}
property on these strings to cue the Emacs display about the places where to
put the cursor while traversing these strings.  This directly communicates
to the display engine where the Lisp program wants to put the cursor, or
where the user would expect the cursor, when point is located on some buffer
position that is ``covered'' by the display or overlay string.

@item pointer
@kindex pointer @r{(text property)}
これはそのテキストやイメージ上にマウスポインターがあるときの、特定のマウスシェイプを指定する。利用できるポインターシェイプについては、@ref{Pointer
Shape}を参照されたい。

@item line-spacing
@kindex line-spacing @r{(text property)}
改行は、改行で終わるディスプレイ行の高さを制御するテキストプロパティまたはオーバーレイプロパティ@code{line-spacing}をもつことができる。このプロパティ値は、デフォルトのフレーム行スペーシングと、バッファーローカル変数@code{line-spacing}をオーバーライドする。@ref{Line
Height}を参照のこと。

@item line-height
@kindex line-height @r{(text property)}
改行は、改行で終わるディスプレイ行のトータル高さを制御するテキストプロパティ、またはオーバーレイプロパティ@code{line-height}をもつことができる。@ref{Line
Height}を参照のこと。

@item wrap-prefix
テキストが@code{wrap-prefix}プロパティをもつなら、それが定義するプレフィクスは、テキストラッピング(text wrapping:
テキスト折り返し)に由来するすべての継続行の先頭に、表示時に追加されるだろう(行が切り詰められた場合、wrap-prefixが使用されることはない)。これは文字列、イメージ(@ref{Other
Display
Specs}を参照)、あるいはディスプレイプロパティ@code{:width}または@code{:align-to}(@ref{Specified
Space}を参照)により指定されて空白文字範囲かもしれない。

wrap-prefixはバッファーローカル変数@code{wrap-prefix}を使用して、バッファー全体にも指定され得る(が、@code{wrap-prefix}テキストプロパティは@code{wrap-prefix}変数の値より優先される)。@ref{Truncation}を参照のこと。

@item line-prefix
テキストが@code{line-prefix}プロパティをもつなら、それが定義するプレフィクスは表示時に、すべての非継続行の先頭に追加されるだろう。これは文字列、イメージ(@ref{Other
Display
Specs}を参照)、あるいはディスプレイプロパティ@code{:width}または@code{:align-to}(@ref{Specified
Space}を参照)により指定されて空白文字範囲かもしれない。

line-prefixはバッファーローカル変数@code{line-prefix}を使用して、バッファー全体にも指定され得る(が、@code{line-prefix}テキストプロパティは@code{line-prefix}変数の値より優先される)。@ref{Truncation}を参照のこと。

@item modification-hooks
@cindex change hooks for a character
@cindex hooks for changing a character
@kindex modification-hooks @r{(text property)}
ある文字がプロパティ@code{modification-hooks}をもつなら、その値は関数のリストであること。その文字の変更により、実際の変更前にそれらの関数すべてが呼び出される。それぞれの関数は、変更されようとするバッファー部分の先頭と終端という、2つの引数を受け取る。特定のmodificationフック関数が、単一のプリミティブにより変更されつつある複数の文字に出現する場合は、その関数が呼び出される回数を予測することはできない。さらに挿入は既存の文字を変更しないので、このフックは文字の削除、他の文字への置換、またはそれらのテキストプロパティ変更時のみ実行されるだろう。

これらの関数がバッファーを変更する場合には、これらのフックを呼び出す内部的メカニズムの混乱を避けるために、それらの関数はそれを行う前後に@code{inhibit-modification-hooks}を@code{t}にバインドするべきである。

オーバーレイも@code{modification-hooks}プロパティをサポートするが、詳細は若干異なる(@ref{Overlay
Properties}を参照)。

@item insert-in-front-hooks
@itemx insert-behind-hooks
@kindex insert-in-front-hooks @r{(text property)}
@kindex insert-behind-hooks @r{(text property)}
あるバッファーへの挿入操作は、後続文字の@code{insert-in-front-hooks}プロパティ、および先行文字の@code{insert-behind-hooks}プロパティにリストされる関数も呼び出す。これらの関数は、挿入されるテキストの先頭と終端という、2つの引数を受け取る。関数は、優先される実際の挿入が行われた@emph{後に}呼び出される。

バッファー内のテキスト変更。に呼び出される他のフックについては、@ref{Change Hooks}も参照されたい。

@item point-entered
@itemx point-left
@cindex hooks for motion of point
@kindex point-entered @r{(text property)}
@kindex point-left @r{(text property)}
スペシャルプロパティ@code{point-entered}および@code{point-left}は、ポイント移動をリポートするフック関数を記録する。ポイントを移動するたびに、Emacsは以下の2つのプロパティ値を比較する:

@itemize @bullet
@item
古い位置の後の文字の@code{point-left}プロパティ。
@item
新しい位置の後の文字の@code{point-entered}プロパティ。
@end itemize

@noindent
これらの2つの値が異なる場合、(@code{nil}でなければ)古いポイント値と新しいポイント値という2つの引数とともにそれらそれぞれ呼び出される。

同じ比較は古い位置と新しい位置の前の文字にたいしても行われる。この結果、2つの@code{point-left}関数(同じ関数かもしれない)、および/または2つの@code{point-entered}関数(同じ関数かもしれない)が実行される可能性がある。ある場合においては、まずすべての@code{point-left}関数が呼び出されて、その後にすべての@code{point-entered}関数が呼び出される。

さまざまなバッファー位置にたいして、そこにポイントを移動することなく文字を調べるために、@code{char-after}を使用することができる。実際のポイント値変更だけが、これらのフック関数を呼び出す。

The variable @code{inhibit-point-motion-hooks} by default inhibits running
the @code{point-left} and @code{point-entered} hooks, see @ref{Inhibit point
motion hooks}.

These properties are obsolete; please use @code{cursor-sensor-functions}
instead.

@item cursor-sensor-functions
@kindex cursor-sensor-functions @r{(text property)}
@findex cursor-sensor-mode
This special property records a list of functions that react to cursor
motion.  Each function in the list is called, just before redisplay, with 3
arguments: the affected window, the previous known position of the cursor,
and one of the symbols @code{entered} or @code{left}, depending on whether
the cursor is entering the text that has this property or leaving it.  The
functions are called only when the minor mode @code{cursor-sensor-mode} is
turned on.

@item composition
@kindex composition @r{(text property)}
このテキストプロパティは、文字シーケンスをコンポーネントから構成される単一グリフ(single
glyph)として表示するために使用される。しかしこのプロパティの値自身は完全にEmacsの内部的なものであり、たとえば@code{put-text-property}などにより直接操作するべくではない。

@end table

@defvar inhibit-point-motion-hooks
@anchor{Inhibit point motion hooks} When this obsolete variable is non-@code{nil}, @code{point-left} and
@code{point-entered} hooks are not run, and the @code{intangible} property
has no effect.  Do not set this variable globally; bind it with @code{let}.
Since the affected properties are obsolete, this variable's default value is
@code{t}, to effectively disable them.
@end defvar

@defvar show-help-function
@anchor{Help display} If this variable is non-@code{nil}, it specifies a function called to
display help strings.  These may be @code{help-echo} properties, menu help
strings (@pxref{Simple Menu Items}, @pxref{Extended Menu Items}), or tool
bar help strings (@pxref{Tool Bar}).  The specified function is called with
one argument, the help string to display, which is passed through
@code{substitute-command-keys} before being given to the function; see
@ref{Keys in Documentation}.  Tooltip mode (@pxref{Tooltips,,, emacs, The
GNU Emacs Manual}) provides an example.
@end defvar

@node Format Properties
@subsection フォーマットされたテキストプロパティ

  以下のテキストプロパティは、フィルコマンドの挙動に影響を与えます。これらはフォーマットされたテキストを表すために使用されます。@ref{Filling}および@ref{Margins}を参照してください。

@table @code
@item hard
改行文字がこのプロパティをもつなら、それは``hard''改行である。フィルコマンドはhard改行を変更せず、それらを横断して単語を移動しない。しかしこのプロパティは、マイナーモード@code{use-hard-newlines}が有効な場合のみ影響を与える。@ref{Hard
and Soft Newlines,, Hard and Soft Newlines, emacs, The GNU Emacs
Manual}を参照のこと。

@item right-margin
このプロパティは、その部分のテキストのフィルにたいして、余分な右マージンを指定する。

@item left-margin
このプロパティは、その部分のテキストのフィルにたいして、余分な左マージンを指定する。

@item justification
このプロパティは、その部分のテキストのフィルにたいして、位置揃え(justification)のスタイルを指定する。
@end table

@node Sticky Properties
@subsection テキストプロパティの粘着性
@cindex sticky text properties
@cindex inheritance, text property

  Self-inserting characters, the ones that get inserted into a buffer when the
user types them (@pxref{Commands for Insertion}), normally take on the same
properties as the preceding character.  This is called @dfn{inheritance} of
properties.

  By contrast, a Lisp program can do insertion with inheritance or without,
depending on the choice of insertion primitive.  The ordinary text insertion
functions, such as @code{insert}, do not inherit any properties.  They
insert text with precisely the properties of the string being inserted, and
no others.  This is correct for programs that copy text from one context to
another---for example, into or out of the kill ring.  To insert with
inheritance, use the special primitives described in this section.
Self-inserting characters inherit properties because they work using these
primitives.

  継承つきで挿入を行う際に、@emph{どの}プロパティがどこから継承されるかは、@dfn{sticky(スティッキー、粘着する)}に依存します。ある文字の後への挿入における、それらのモジノプロパティ継承は@dfn{rear-sticky(後方スティッキー)}です。ある文字の前への挿入における、それらのモジノプロパティ継承は@dfn{front-sticky(前方スティッキー)}です。これら両側のstickyが、同じプロパティにたいして異なるsticky値をもつ場合は、前の文字の値が優先します。

  デフォルトでは、テキストプロパティはfront-stickyではなく、rear-stickyです。したがってデフォルトでは、すべてのプロパティは前の文字から継承し、後の文字からは何も継承しません。

  さまざまなテキストプロパティのstickiness(スティッキネス、スティッキー性、粘着性、粘着度)はは、2つのテキストプロパティ@code{front-sticky}および@code{rear-nonsticky}と、変数@code{text-property-default-nonsticky}で制御できます。与えられたプロパティにたいして異なるデフォルトを指定するために、この変数を使用できます。テキストの任意の特定部分に特定のプロパティsticky、または非stickyを指定するために、これら2つのテキストプロパティを使用できます。

  ある文字の@code{front-sticky}プロパティが@code{t}なら、その文字のすべてのプロパティはfront-stickyです。@code{front-sticky}プロパティがリストなら、その文字のstickyなプロパティは、名前がそのリスト内にあるプロパティです。たとえばある文字が値が@code{(face
read-only)}であるような@code{front-sticky}プロパティをもつなら、その文字の前への挿入ではその文字の@code{face}プロパティと@code{read-only}プロパティは継承できますが、他のプロパティはｐ継承できません。

  @code{rear-nonsticky}は逆の方法で機能します。ほとんどのプロパティはデフォルトでrear-stickyであり、@code{rear-nonsticky}プロパティはどのプロパティがrear-sticky@emph{ではない}かを告げますある文字の@code{rear-nosticky}プロパティが@code{t}なら、その文字のすべてのプロパティはrear-stickyではありません。@code{rear-nosticky}プロパティがリストなら、その文字のstickyなプロパティは、名前がそのリスト内に@emph{ない}プロパティです。

@defvar text-property-default-nonsticky
この変数は、さまざまなテキストプロパティのデフォルトのrear-stickinessを定義するalistである。各要素は@code{(@var{property}
.
@var{nonstickiness})}という形式をもち、これは特定のテキストプロパティ@var{property}のstickinessを定義する。

@var{nonstickiness}が非@code{nil}なら、それはプロパティ@var{property}がデフォルトでrear-nonstickyであることを意味する。すべてのプロパティはデフォルトでfront-nonstickyなので、これにより@var{property}は両方向にたいしてデフォルトでnonstickyになる。

テキストプロパティ@code{front-sticky}および@code{rear-nonsticky}が使用された際には、@code{text-property-default-nonsticky}内で指定されたデフォルトの@var{nonstickiness}より優先される。
@end defvar

  以下はプロパティ継承つきでテキストを挿入する関数です:

@defun insert-and-inherit &rest strings
関数@code{insert}と同じように文字列@var{strings}を挿入するが、隣接するテキストからすべてのstickyなプロパティを継承する。
@end defun

@defun insert-before-markers-and-inherit &rest strings
関数@code{insert-before-markers}と同じように文字列@var{strings}を挿入するが、隣接するテキストからすべてのstickyなプロパティを継承する。
@end defun

  継承を行わない通常の挿入関数については、@ref{Insertion}を参照してください。

@node Lazy Properties
@subsection テキストプロパティのlazyな計算

  バッファー内のすべてのテキストにたいしてテキストプロパティを計算するかわりに、何かがテキスト範囲に依存している場合、その際はテキストプロパティを計算するようにアレンジできます。

  プロパティとともにバッファーからテキストを抽出するプリミティブは、@code{buffer-substring}です。プロパティを調べる前に、この関数はアブノーマルフック@code{buffer-access-fontify-functions}を実行します。

@defvar buffer-access-fontify-functions
この変数は、テキストプロパティ計算用の関数のリストを保持する。@code{buffer-substring}がバッファーの一部のテキストとテキストプロパティをコピーする前に、このリスト内の関数すべてを呼び出す。各関数はアクセスされるバッファー範囲を指定する、2つの引数を受け取る(バッファーは常にカレントバッファーとなる)。
@end defvar

  関数@code{buffer-substring-no-properties}はいずれにせよテキストプロパティを無視するので、これらの関数を呼び出さない。

  同じバッファー部分にたいして複数回フック関数が呼び出されるのを防ぐには、変数@code{buffer-access-fontified-property}を使用できる。

@defvar buffer-access-fontified-property
If this variable's value is non-@code{nil}, it is a symbol which is used as
a text property name.  A non-@code{nil} value for that text property means
the other text properties for this character have already been computed.

@code{buffer-substring}にたいして指定された範囲内のすべての文字が、このプロパティにたいする値として非@code{nil}をもつなら、@code{buffer-substring}は@code{buffer-access-fontify-functions}の関数を呼び出さない。それらの文字がすでに正しいテキストプロパティをもつとみなし、それらがすでに所有するプロパティを単にコピーする。

@code{buffer-access-fontify-functions}の関数にこのプロパティ、同様に他のプロパティを処理対象の文字に追加させるのが、この機能の通常の用途である。この方法では、同じテキストにたいして、それらの関数が何度も呼び出されるのを防ぐことができる。
@end defvar

@node Clickable Text
@subsection クリック可能なテキストの定義
@cindex clickable text
@cindex follow links
@cindex mouse-1

  @dfn{クリック可能テキスト(clickable
text)}とは何らかの結果を生成するために、マウス、またはキーボードコマンドを通じてクリックできるテキストです。多くのメジャーモードがテキスト的なハイパーリンク、略して@dfn{リンク(link)}を実装するために、クリック可能テキストを使用しています。

  リンクを挿入および操作するもっとも簡単な方法は、@code{button}パッケージの使用です。@ref{Buttons}を参照してください。このセクションではテキストプロパティを使用して、バッファー内に手作業でクリック可能テキストをセットアップする方法を説明します。簡略にするために、クリック可能テキストを@dfn{リンク}と呼ぶことにします。

  Implementing a link involves three separate steps: (1) indicating
clickability when the mouse moves over the link; (2) making @key{RET} or
@kbd{mouse-2} on that link do something; and (3) setting up a
@code{follow-link} condition so that the link obeys
@code{mouse-1-click-follows-link}.

  クリック可能を示すためには、そのリンクのテキストに@code{mouse-face}プロパティを追加します。すると、以降Emacsはマウスがその上に移動した際にリンクをハイライトするでしょう。加えて@code{help-echo}テキストプロパティを使用して、ツールチップかエコーエリアメッセージを定義するべきです。@ref{Special
Properties}を参照してください。たとえば以下は、Diredがファイル名がクリック可能なことを示す方法です:

@smallexample
 (if (dired-move-to-filename)
     (add-text-properties
       (point)
       (save-excursion
         (dired-move-to-end-of-filename)
         (point))
       '(mouse-face highlight
         help-echo "mouse-2: visit this file in other window")))
@end smallexample

  To make the link clickable, bind @key{RET} and @kbd{mouse-2} to commands
that perform the desired action.  Each command should check to see whether
it was called on a link, and act accordingly.  For instance, Dired's major
mode keymap binds @kbd{mouse-2} to the following command:

@smallexample
(defun dired-mouse-find-file-other-window (event)
  "In Dired, visit the file or directory name you click on."
  (interactive "e")
  (let ((window (posn-window (event-end event)))
        (pos (posn-point (event-end event)))
        file)
    (if (not (windowp window))
        (error "No file chosen"))
    (with-current-buffer (window-buffer window)
      (goto-char pos)
      (setq file (dired-get-file-for-visit)))
    (if (file-directory-p file)
        (or (and (cdr dired-subdir-alist)
                 (dired-goto-subdir file))
            (progn
              (select-window window)
              (dired-other-window file)))
      (select-window window)
      (find-file-other-window (file-name-sans-versions file t)))))
@end smallexample

@noindent
このコマンドはクリックがどこで発生したかを判断するために、関数@code{posn-window}と@code{posn-point}、visitするファイルの判断に関数@code{dired-get-file-for-visit}を使用します。

  マウスコマンドをメジャーモードキーマップ内でバインドするかわりに、@code{keymap}プロパティ(@ref{Special
Properties}を参照)を使用して、リンクテキスト内でバインドできます。たとえば:

@example
(let ((map (make-sparse-keymap)))
  (define-key map [mouse-2] 'operate-this-button)
  (put-text-property link-start link-end 'keymap map))
@end example

@noindent
With this method, you can easily define different commands for different
links.  Furthermore, the global definition of @key{RET} and @kbd{mouse-2}
remain available for the rest of the text in the buffer.

@vindex mouse-1-click-follows-link
  The basic Emacs command for clicking on links is @kbd{mouse-2}.  However,
for compatibility with other graphical applications, Emacs also recognizes
@kbd{mouse-1} clicks on links, provided the user clicks on the link quickly
without moving the mouse.  This behavior is controlled by the user option
@code{mouse-1-click-follows-link}.  @xref{Mouse References,,, emacs, The GNU
Emacs Manual}.

@cindex follow-link (text or overlay property)
  To set up the link so that it obeys @code{mouse-1-click-follows-link}, you
must either (1) apply a @code{follow-link} text or overlay property to the
link text, or (2)  bind the @code{follow-link} event to a keymap (which can
be a major mode keymap or a local keymap specified via the @code{keymap}
text property).  The value of the @code{follow-link} property, or the
binding for the @code{follow-link} event, acts as a condition for the link
action.  This condition tells Emacs two things: the circumstances under
which a @kbd{mouse-1} click should be regarded as occurring inside the link,
and how to compute an action code that says what to translate the
@kbd{mouse-1} click into.  The link action condition can be one of the
following:

@table @asis
@item @code{mouse-face}
コンディションがシンボル@code{mouse-face}の場合、その位置に非@code{nil}の@code{mouse-face}プロパティがあれば、それはリンク内側の位置である。アクションコードは常に@code{t}。

For example, here is how Info mode handles @key{mouse-1}:

@smallexample
(define-key Info-mode-map [follow-link] 'mouse-face)
@end smallexample

@item 関数
コンディションが関数@var{func}の場合、@code{(@var{func}
@var{pos})}が非@code{nil}に評価されれば、位置@var{pos}はリンクの内側である。@var{func}がリターンする値は、アクションコードとして機能する。

For example, here is how pcvs enables @kbd{mouse-1} to follow links on file
names only:

@smallexample
(define-key map [follow-link]
  (lambda (pos)
    (eq (get-char-property pos 'face) 'cvs-filename-face)))
@end smallexample

@item その他
コンディション値がそれ以外の場合、その位置はリンク内側であり、そのコンディション自体がアクションコードである。(バッファー全体に適用されないように)リンクテキストのテキストプロパティまたはオーバーレイプロパティを通じてコンディションを適用するときのみ、この類のコンディションを指定すべきなのは明確である。
@end table

@noindent
The action code tells @kbd{mouse-1} how to follow the link:

@table @asis
@item 文字列またはベクター
If the action code is a string or vector, the @kbd{mouse-1} event is
translated into the first element of the string or vector; i.e., the action
of the @kbd{mouse-1} click is the local or global binding of that character
or symbol.  Thus, if the action code is @code{"foo"}, @kbd{mouse-1}
translates into @kbd{f}.  If it is @code{[foo]}, @kbd{mouse-1} translates
into @key{foo}.

@item その他
For any other non-@code{nil} action code, the @kbd{mouse-1} event is
translated into a @kbd{mouse-2} event at the same position.
@end table

  To define @kbd{mouse-1} to activate a button defined with
@code{define-button-type}, give the button a @code{follow-link} property.
The property value should be a link action condition, as described above.
@xref{Buttons}.  For example, here is how Help mode handles @kbd{mouse-1}:

@smallexample
(define-button-type 'help-xref
  'follow-link t
  'action #'help-button-action)
@end smallexample

  To define @kbd{mouse-1} on a widget defined with @code{define-widget}, give
the widget a @code{:follow-link} property.  The property value should be a
link action condition, as described above.  For example, here is how the
@code{link} widget specifies that a @key{mouse-1} click shall be translated
to @key{RET}:

@smallexample
(define-widget 'link 'item
  "An embedded link."
  :button-prefix 'widget-link-prefix
  :button-suffix 'widget-link-suffix
  :follow-link "\C-m"
  :help-echo "Follow the link."
  :format "%[%t%]")
@end smallexample

@defun mouse-on-link-p pos
この関数は、カレントバッファー内の位置@var{pos}がリンク上なら、非@code{nil}をリターンする。@var{pos}は@code{event-start}がリターンするようなマウスイベント位置でもよい(@ref{Accessing
Mouse}を参照)。
@end defun

@node Fields
@subsection フィールドの定義と使用
@cindex fields

  フィールドとはバッファー内にある連続する文字範囲であり、@code{field}プロパティ(テキストプロパティかオーバーレイプロパティ)に同じ値(@code{eq}で比較)をもつことにより識別されます。このセクションでは、フィールドの操作に利用できるスペシャル関数を説明します。

  フィールドは、バッファー位置@var{pos}で指定します。各フィールドはバッファー位置の範囲を含むと考えて、指定した位置はその位置を含むフィールドを表します。

  @var{pos}の前または後の文字は同じフィールドに属し、どのフィールドが@var{pos}を含むかという疑問はありません。それらの文字が属するフィールドが、そのフィールドです。@var{pos}がフィールド境界のときは、それがどのフィールドに属すかは、取り囲む2つの文字の@code{field}プロパティのstickinessに依存します(@ref{Sticky
Properties}を参照)。@var{pos}に挿入されたテキストからプロパティが継承されたフィールドが、@var{pos}を含むフィールドです。

  @var{pos}に新たに挿入されたテキストが、いずれの側からも@code{field}プロパティを継承しない、異常なケースがあります。これは前の文字の@code{field}プロパティがrear-stickyでなく、後の文字の@code{field}プロパティがfront-stickyでもない場合に発生します。このケースでは、@var{pos}は前のフィールドと後のフィールドいずれにも属しません。フィールド関数はそれを、開始と終了が@var{pos}の空フィールドに属するものとして扱います。

  これらすべての関数では、@var{pos}が省略または@code{nil}の場合は、ポイントの値がデフォルトとして使用されます。ナローイング(narrowing)が効力をもつ場合、@var{pos}はアクセス可能部分にあるはずです。@ref{Narrowing}を参照してください。

@defun field-beginning &optional pos escape-from-edge limit
この関数は、@var{pos}で指定されたフィールドの先頭をリターンする。

@var{pos}が自身のフィールド先頭にあり、かつ@var{escape-from-edge}が非@code{nil}なら、@var{pos}周辺の@code{field}プロパティのstickinessに関わらず、リターン値は常に@var{pos}が終端であるような前のフィールドの先頭になる。

@var{limit}が非@code{nil}なら、それはバッファーの位置である。そのフィールドの先頭が@var{limit}より前なら、かわりに@var{limit}がリターンされるだろう。
@end defun

@defun field-end &optional pos escape-from-edge limit
この関数は、@var{pos}で指定されるフィールドの終端をリターンする。

@var{pos}が自身のフィールド終端にあり、かつ@var{escape-from-edge}が非@code{nil}なら、@var{pos}周辺の@code{field}プロパティのstickinessに関わらず、リターン値は常に@var{pos}が@emph{先頭}であるような後のフィールドの終端になる。

@var{limit}が非@code{nil}なら、それはバッファーの位置である。そのフィールドの終端が@var{limit}より後なら、かわりに@var{limit}がリターンされるだろう。
@end defun

@defun field-string &optional pos
この関数は@var{pos}で指定されるフィールドのコンテンツを、文字列としてリターンする。
@end defun

@defun field-string-no-properties &optional pos
この関数は、@var{pos}で指定されるフィールドのコンテンツを、テキストプロパティを無視して、文字列としてリターンする。
@end defun

@defun delete-field &optional pos
この関数は、@var{pos}で指定されるフィールドのテキストを削除する。
@end defun

@defun constrain-to-field new-pos old-pos &optional escape-from-edge only-in-line inhibit-capture-property
This function constrains @var{new-pos} to the field that @var{old-pos}
belongs to---in other words, it returns the position closest to
@var{new-pos} that is in the same field as @var{old-pos}.

@var{new-pos}が@code{nil}なら、@code{constrain-to-field}はかわりにポイントの値を使用して、ポイントをリターンすることに加えて、その位置にポイントを移動する。

If @var{old-pos} is at the boundary of two fields, then the acceptable final
positions depend on the argument @var{escape-from-edge}.  If
@var{escape-from-edge} is @code{nil}, then @var{new-pos} must be in the
field whose @code{field} property equals what new characters inserted at
@var{old-pos} would inherit.  (This depends on the stickiness of the
@code{field} property for the characters before and after @var{old-pos}.)
If @var{escape-from-edge} is non-@code{nil}, @var{new-pos} can be anywhere
in the two adjacent fields.  Additionally, if two fields are separated by
another field with the special value @code{boundary}, then any point within
this special field is also considered to be on the boundary.

引数なしの@kbd{C-a}コマンドのように、特別な類の位置に後方へ移動して一度そこに留まるには、おそらく@var{escape-from-edge}にたいして@code{nil}を指定するべきであろう。フィールドをチェックする他の移動コマンドにたいしては、おそらく@code{t}を渡すべきである。

オプション引数@var{only-in-line}が非@code{nil}、かつ@var{new-pos}を通常の方法により拘束することにより異なる行へ移動するような場合、@var{new-pos}は非拘束でリターンされる。これは@code{next-line}や@code{beginning-of-line}のような行単位の移動コマンドで、それらのコマンドが正しい行へ移動できる場合だけフィールド境界を尊重するようにするために用いられる。

オプション引数@var{inhibit-capture-property}が非@code{nil}、かつ@var{old-pos}がその名前の非@code{nil}なプロパティをもつなら、すべてのフィールド境界は無視される。

変数@code{inhibit-field-text-motion}を非@code{nil}値にバインドすることにより、@code{constrain-to-field}にすべてのフィールド境界を無視(何者にも拘束されることがない)させることができる。
@end defun

@node Not Intervals
@subsection なぜテキストプロパティはインターバルではないのか
@cindex intervals

  Some editors that support adding attributes to text in the buffer do so by
letting the user specify intervals within the text, and adding the
properties to the intervals.  Those editors permit the user or the
programmer to determine where individual intervals start and end.  We
deliberately provided a different sort of interface in Emacs Lisp to avoid
certain paradoxical behavior associated with text modification.

  複数のインターバルに細分化することが実際に意味をもつなら、それは特定のプロパティをもつ単一のインターバルのバッファーと、同じテキストをもち、両方が同じプロパティをもつ2つのインターバルに分割されたバッファーを区別できることを意味します。

  インターバルを1つだけもつバッファーがあり、その一部をkillすることを考えてみてください。そのそのバッファーに残されるのは1つのインターバルであり、killリング(とundoリスト)内のコピーは別個のインターバルになります。そのkillされたテキストをyankで戻すと、同じプロパティをもつ2つのインターバルを得ることになります。したがって、編集では1つのインターバルと2つのインターバルの違いは保たれません。

  Suppose we attempt to fix this problem by coalescing the two intervals when
the text is inserted.  That works fine if the buffer originally was a single
interval.  But suppose instead that we have two adjacent intervals with the
same properties, and we kill the text of one interval and yank it back.  The
same interval-coalescence feature that rescues the other case causes trouble
in this one: after yanking, we have just one interval.  Once again, editing
does not preserve the distinction between one interval and two.

  インターバルの間の境界上へのテキスト挿入でも、満足できる回答かない問題が発生します。

  しかし、``バッファーにあるテキスト位置または文字列位置のプロパティは何?''という形式の問にたいして、編集が一貫した振る舞いをするようアレンジするのは簡単です。そこで、わたしたちはこれらが合理的な唯一の問いであると判断したのです。わたしたちはインターバルの開始と終了の場所を問うような実装をしませんでした。

  実際には、明白にインターバル境界であるような箇所では、通常はテキストプロパティ検索関数を使用できます。可能であるならインターバルは常に結合されるとみなすことにより、それらがインターバル境界を探すと考えることができます。@ref{Property
Search}を参照してください。

  Emacsはプレゼンテーション機能として、明示的なインターバルも提供します。@ref{Overlays}を参照してください。

@node Substitution
@section 文字コードの置き換え
@cindex replace characters in region
@cindex substitute characters

  以下の関数は、文字コードにもとづいて、指定されたリージョン内の文字を置き換えます。

@defun subst-char-in-region start end old-char new-char &optional noundo
@cindex replace characters
この関数は、@var{start}と@var{end}で定義されるカレントバッファーのリージョン内に出現する文字@var{old-char}を@var{new-char}に置き換える。

@cindex undo avoidance
@var{noundo}が非@code{nil}なら、@code{subst-char-in-region}はundo用に変更を記録せず、バッファーを変更済みとマークしない。これは、古い機能である選択的ディスプレイ(@ref{Selective
Display}を参照)にとって有用だった。

@code{subst-char-in-region}はポイントを移動せず、@code{nil}をリターンする。

@example
@group
---------- Buffer: foo ----------
This is the contents of the buffer before.
---------- Buffer: foo ----------
@end group

@group
(subst-char-in-region 1 20 ?i ?X)
     @result{} nil

---------- Buffer: foo ----------
ThXs Xs the contents of the buffer before.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@deffn Command translate-region start end table
この関数は、バッファー内の位置@var{start}と@var{end}の間の文字にたいして、変換テーブル(translation
table)を適用する。

変換テーブル@var{table}は、文字列、または文字テーブルである。@code{(aref @var{table}
@var{ochar})}は、@var{ochar}に対応した変換後の文字を与える。@var{table}が文字列なら、@var{table}の長さより大きいコードの文字は、この変更により変更されない。

@code{translate-region}のリターン値は、その変換により実際に変更された文字数である。変換テーブル内でその文字自身にマップされる文字は勘定に入らない。
@end deffn

@node Registers
@section レジスター
@cindex registers

  レジスター(register)とは、Emacs内の編集においてさまざまな異なる種類の値を保持できる、一種の変数のことです。レジスターはそれぞれ、1文字で命名されます。すべての@acronym{ASCII}文字、およびそれらのメタ修飾された変種(ただし@kbd{C-g}は例外)を、レジスターの命名に使用できます。したがって、利用可能なレジスター数は255になります。Emacs
Lispでは、レジスターは自身の名前である、その文字により指定されます。

@defvar register-alist
この変数は、要素が@code{(@var{name}
.@var{contents})}という形式のalistである。使用中のEmacsレジスターごとに、通常は1つの要素が存在する。

オブジェクト@var{name}は、レジスターを識別する文字(整数)である。
@end defvar

  レジスターの@var{contents}には、いくつかのタイプがある:

@table @asis
@item 数字
数字はそれ自身を意味する。@code{insert-register}はレジスター内の数字を探して、その数字を10進数に変換する。

@item マーカー
マーカーは、ジャンプ先のバッファー位置を表す。

@item 文字列
文字列の場合は、レジスター内に保存されたテキスト。

@item 矩形(rectangle)
矩形は、文字列のリストを表す。

@item @code{(@var{window-configuration} @var{position})}
これは1つのフレームにリストアされるウィンドウ構成、およびカレントバッファー内のジャンプ先の位置を表す。

@c FIXME: Mention frameset here.
@item @code{(@var{frame-configuration} @var{position})}
これは、リストア用のフレーム構成、およびカレントバッファー内のジャンプ先の位置である。

@item (file @var{filename})
これはvisitするファイルを表し、この値にジャンプすることによりファイル@var{filename}をvisitする。

@item (file-query @var{filename} @var{position})
これはvisitするファイル、およびそのファイル内の位置を表す。この値にジャンプすることによりファイル@var{filename}をvisitして、バッファー位置@var{position}に移動する。このタイプの位置をリストアすると、まずユーザーにたいして確認を求める。
@end table

  このセクションの関数は、特に記さない限り予期せぬ値をリターンします。

@defun get-register reg
この関数はレジスター@var{reg}のコンテンツ、コンテンツがなければ@code{nil}をリターンする。
@end defun

@defun set-register reg value
この関数は、レジスター@var{reg}のコンテンツに@var{value}をセットする。レジスターには任意の値をセットできるが、その他のレジスター関数は特定のデータ型を期待する。リターン値は@var{value}。
@end defun

@deffn Command view-register reg
このコマンドは、レジスター @var{reg}に何が含まれているかを表示する。
@end deffn

@deffn Command insert-register reg &optional beforep
このコマンドは、カレントバッファーにレジスター@var{reg}のコンテンツを挿入する。

Normally, this command puts point before the inserted text, and the mark
after it.  However, if the optional second argument @var{beforep} is
non-@code{nil}, it puts the mark before and point after.

When called interactively, the command defaults to putting point after text,
and a prefix argument inverts this behavior.

レジスターに矩形が含まれる場合、その矩形はポイントの左上隅に挿入される。これはそのテキストがカレント行と、その下に続く行に挿入されることを意味する。

レジスターが保存されたテキスト(文字列)または矩形(リスク)以外の何かを含む場合、現在のところは役に立つようなことは起きない。これは将来変更されるかもしれない。
@end deffn

@defun register-read-with-preview prompt
@cindex register preview
この関数は、@var{prompt}、およびもしかしたら既存レジスターとそのコンテンツをプレビューしてレジスターの名前を読み取り、レジスター名をリターンする。このプレビューは、ユーザーオプション@code{register-preview-delay}と@code{register-alist}がいずれも非@code{nil}なら、@code{register-preview-delay}で指定された遅延の後に、一時ウィンドウ内に表示される。このプレビューは、ユーザーが(たとえばヘルプ文字のタイプにより)ヘルプを要求した場合も表示される。レジスター名を読み取るスベインタラクティブな関数は、この関数の使用を推奨する。
@end defun

@node Transposition
@section テキストの交換

  以下の関数は、テキストの一部を置き換えるために使用できます:

@defun transpose-regions start1 end1 start2 end2 &optional leave-markers
この関数は、バッファーの重複しない2つの部分を交換する。引数@var{start1}と@var{end1}は一方の部分の両端、引数@var{start2}と@var{end2}はもう一方の部分の両端を指定する。

通常@code{transpose-regions}は、置き換えたテキストにともないマーカーを再配置する。以前は2つの置き換えたテキストのうちの一方の部分に位置していたマーカーは、しの部分とともに移動されるので、それを挟む2つの文字の新たな位置の間に留まることになる。しかし@var{leave-markers}が非@code{nil}なら、@code{transpose-regions}はこれを行わず、すべてのマーカーを再配置せずに残す。
@end defun

@node Decompression
@section 圧縮されたデータの処理

@code{auto-compression-mode}が有効なときは、圧縮されたファイルをvisitする際、Emacsはそれを自動的に解凍し、それを変更して保存する際は自動的に再圧縮します。@ref{Compressed
Files,,, emacs, The GNU Emacs Manual}を参照してください。

上記の機能は、外部の実行可能ファイル(例:
@command{gzip})を呼び出すことにより機能します。zlibライブラリーを使用したビルトインの解凍サポートつきでEmacsをコンパイルすることもでき、これは外部プログラムの実行に比べて高速です。

@defun zlib-available-p
この関数は、ビルトインzlib解凍が利用可能なら非@code{nil}をリターンする。
@end defun

@defun zlib-decompress-region start end
この関数はビルトインのzlib解凍を使用して、@var{start}と@var{end}の間のリージョンを解凍する。このリージョンには、gzipかzlibで圧縮されたデータが含まれていなければならない。成功した場合、この関数はリージョンのコンテンツを、解凍されたデータに置き換える。失敗すると、関数はリージョンを未変更のまま@code{nil}をリターンする。この関数は、ユニバイトバッファーでのみ呼び出すことができる。
@end defun


@node Base 64
@section Base 64エンコーディング
@cindex base 64 encoding

  Base64コードは、8ビットシーケンスをより長い@acronym{ASCII}グラフィック文字シーケンスにエンコードするために、email内で使用されます。これは、インターネットRFC2045で定義されます@footnote{RFC(@dfn{Request
for
Comments}の略)とは、ナンバーが付与された、標準を記述するインターネット情報提供ドキュメントです。RFCは通常、自身が先駆的に活動する技術エキスパートにより記述され、伝統として現実的で、経験主導で記述されます。}。このセクションでは、このコードへの変換および逆変換を行う関数について説明します。

@deffn Command base64-encode-region beg end &optional no-line-break
この関数は、@var{beg}から@var{end}のリージョンを、Base64コードに変換する。これはエンコードされたテキストの長さをリターンする。リージョン内の文字がマルチバイトの場合は、エラーをシグナルする(マルチバイトバッファーでは、リージョンには@code{ascii}、@code{eight-bit-control}、@code{eight-bit-graphic}の文字以外は含まれてはならない)。

通常この関数は行が長くなりすぎるのを防ぐために、エンコードされたテキストに改行を挿入する。しかしオプション引数@var{no-line-break}が非@code{nil}なら、これらの改行は追加されず、出力は長い単一の行となる。
@end deffn

@defun base64-encode-string string &optional no-line-break
この関数は、文字列@var{string}をBase64コードに変換する。これはエンコードされたテキストを含む文字列をリターンする。@code{base64-encode-region}と同様、文字列内の文字がマルチバイトならエラーをシグナルする。

通常この関数は行が長くなりすぎるのを防ぐために、エンコードされたテキストに改行を挿入する。しかしオプション引数@var{no-line-break}が非@code{nil}なら、これらの改行は追加されず、結果となる文字列は長い単一の行となる。
@end defun

@deffn Command base64-decode-region beg end
この関数は、@var{beg}から@var{end}のリージョンのBase64コードを、対応するデコードされたテキストに変換する。これはデコードされたテキストの長さをリターンする。

デコード関数は、エンコード済みテキスト内の改行文字を無視する。
@end deffn

@defun base64-decode-string string
この関数は、モジュール@var{string}を、Base64コードから、対応するデコード済みテキストに変換する。これは、デコード済みテキストを含むユニバイトをリターンする。

デコード関数は、エンコード済みテキスト内の改行文字を無視する。
@end defun

@node Checksum/Hash
@section チェックサムとハッシュ
@cindex MD5 checksum
@cindex SHA hash
@cindex hash, cryptographic
@cindex cryptographic hash

  Emacs has built-in support for computing @dfn{cryptographic hashes}.  A
cryptographic hash, or @dfn{checksum}, is a digital fingerprint of a piece
of data (e.g., a block of text) which can be used to check that you have an
unaltered copy of that data.

@cindex message digest
  Emacs supports several common cryptographic hash algorithms: MD5, SHA-1,
SHA-2, SHA-224, SHA-256, SHA-384 and SHA-512.  MD5 is the oldest of these
algorithms, and is commonly used in @dfn{message digests} to check the
integrity of messages transmitted over a network.  MD5 is not collision
resistant (i.e., it is possible to deliberately design different pieces of
data which have the same MD5 hash), so you should not used it for anything
security-related.  A similar theoretical weakness also exists in SHA-1.
Therefore, for security-related applications you should use the other hash
types, such as SHA-2.

@defun secure-hash algorithm object &optional start end binary
この関数は、@var{object}にたいするハッシュをリターンする。引数@var{algorithm}はどのハッシュを計算するかを示すシンボルで@code{md5}、@code{sha1}、@code{sha224}、@code{sha256}、@code{sha384}、@code{sha512}のいずれかである。引数@var{object}は、バッファーまたは文字列であること。

オプション引数@var{start}と@var{end}は、メッセージダイジェストを計算する、@var{object}部分を指定する文字位置である。これらが@code{nil}または省略された場合は、@var{object}全体にたいするハッシュを計算する。

引数@var{binary}が省略または@code{nil}なら、通常のLisp文字列として、そのハッシュの@dfn{テキスト形式(text
form)}をリターンする。@var{binary}が非@code{nil}なら、ユニバイト文字列に格納されたバイトシーケンスとして、そのハッシュの@dfn{バイナリー形式(binary
form)}をリターンする。

この関数は、@var{object}のテキストの内部表現(@ref{Text
Representations}を参照)からハッシュを直接計算しない。かわりにコーディングシステム(@ref{Coding
Systems}を参照)を使用してテキストをエンコードして、そのエンコード済みテキストからハッシュを計算する。@var{object}がバッファーなら、使用されているコーディングが、そのテキストをファイルに書き込むためのデフォルトとして選択される。@var{object}が文字列なら、ユーザーの好むコーディングシステムが使用される(@ref{Recognize
Coding,,, emacs, GNU Emacs Manual}を参照)。
@end defun

@defun md5 object &optional start end coding-system noerror
この関数はMD5ハッシュをリターンする。これはほとんどの目的において、@var{algorithm}引数に@code{md5}を指定して@code{secure-hash}を呼び出すのと等価であり、半ば時代遅れである。引数の@var{object}、@var{start}、@var{end}は@code{secure-hash}のときと同じ意味をもつ。

@var{coding-system}が非@code{nil}なら、それはテキストをエンコードするために使用する、コーディングシステムを指定する。if
omitted or , the default coding system is used, like in
@code{secure-hash}と同様にデフォルトコーディングシステムが使用される。

@code{md5}は通常、指定もしくは選択されたコーディングシステムを使用してテキストをエンコードできなければ、エラーをシグナルする。しかし@var{noerror}が非@code{nil}なら、かわりに黙って@code{raw-text}コーディングシステムを使用する。
@end defun

@node Parsing HTML/XML
@section HTMLとXMLの解析
@cindex parsing html

Emacsがlibxml2サポートつきでコンパイルされたときは、HTMLやXMLのテキストをLispオブジェクトツリーにパースするために、以下の関数が利用可能です。

@defun libxml-parse-html-region start end &optional base-url discard-comments
This function parses the text between @var{start} and @var{end} as HTML, and
returns a list representing the HTML @dfn{parse tree}.  It attempts to
handle real-world HTML by robustly coping with syntax mistakes.

オプション引数@var{base-url}が非@code{nil}なら、リンク内に出現する相対URLにたいする、ベースURLを指定する文字列であること。

If the optional argument @var{discard-comments} is non-@code{nil}, then the
parse tree is created without any comments.

パースツリー内では、各HTMLノードは1つ目の要素がノード名を表すシンボル2つ目の要素がノード属性のalist、残りの要素はサブノードであるようなリストにより表される。

以下の例でこれを示す。以下の(不正な)HTMLドキュメントを与えると:

@example
<html><head></head><body width=101><div class=thing>Foo<div>Yes
@end example

@noindent
A call to @code{libxml-parse-html-region} returns this @acronym{DOM}
(document object model):

@example
(html nil
 (head nil)
 (body ((width . "101"))
  (div ((class . "thing"))
   "Foo"
   (div nil
    "Yes"))))
@end example
@end defun

@cindex rendering html
@defun shr-insert-document dom
この関数は、@var{dom}内のパース済みHTMLを、カレントバッファー内に描画する。引数@var{dom}は、@code{libxml-parse-html-region}で整数されるようなｌリストであること。この関数はたとえば、@ref{Top,
EWW,, eww, The Emacs Web Wowser Manual}により使用される。
@end defun

@cindex parsing xml
@defun libxml-parse-xml-region start end &optional base-url discard-comments
この関数は@code{libxml-parse-html-region}と同様だが、HTMLではなく(構文についてより厳格な)XMLとしてテキストをパースする点が異なる。
@end defun

@menu
* Document Object Model::    Access, manipulate and search the 
                               @acronym{DOM}.
@end menu

@node Document Object Model
@subsection Document Object Model
@cindex HTML DOM
@cindex XML DOM
@cindex DOM
@cindex Document Object Model

The @acronym{DOM} returned by @code{libxml-parse-html-region} (and the other
@acronym{XML} parsing functions) is a tree structure where each node has a
node name (called a @dfn{tag}), and optional key/value @dfn{attribute} list,
and then a list of @dfn{child nodes}.  The child nodes are either strings or
@acronym{DOM} objects.

@example
(body ((width . "101"))
 (div ((class . "thing"))
  "Foo"
  (div nil
   "Yes")))
@end example

@defun dom-node tag &optional attributes &rest children
This function creates a @acronym{DOM} node of type @var{tag}.  If given,
@var{attributes} should be a key/value pair list.  If given, @var{children}
should be @acronym{DOM} nodes.
@end defun

The following functions can be used to work with this structure.  Each
function takes a @acronym{DOM} node, or a list of nodes.  In the latter
case, only the first node in the list is used.

Simple accessors:

@table @code
@item dom-tag @var{node}
Return the @dfn{tag} (also called ``node name'') of the node.

@item dom-attr @var{node} @var{attribute}
Return the value of @var{attribute} in the node.  A common usage would be:

@lisp
(dom-attr img 'href)
=> "http://fsf.org/logo.png"
@end lisp

@item dom-children @var{node}
Return all the children of the node.

@item dom-non-text-children @var{node}
Return all the non-string children of the node.

@item dom-attributes @var{node}
Return the key/value pair list of attributes of the node.

@item dom-text @var{node}
Return all the textual elements of the node as a concatenated string.

@item dom-texts @var{node}
Return all the textual elements of the node, as well as the textual elements
of all the children of the node, recursively, as a concatenated string.
This function also takes an optional separator to be inserted between the
textual elements.

@item dom-parent @var{dom} @var{node}
Return the parent of @var{node} in @var{dom}.
@end table

The following are functions for altering the @acronym{DOM}.

@table @code
@item dom-set-attribute @var{node} @var{attribute} @var{value}
Set the @var{attribute} of the node to @var{value}.

@item dom-append-child @var{node} @var{child}
Append @var{child} as the last child of @var{node}.

@item dom-add-child-before @var{node} @var{child} @var{before}
Add @var{child} to @var{node}'s child list before the @var{before} node.  If
@var{before} is @code{nil}, make @var{child} the first child.

@item dom-set-attributes @var{node} @var{attributes}
Replace all the attributes of the node with a new key/value list.
@end table

The following are functions for searching for elements in the
@acronym{DOM}.  They all return lists of matching nodes.

@table @code
@item dom-by-tag @var{dom} @var{tag}
Return all nodes in @var{dom} that are of type @var{tag}.  A typical use
would be:

@lisp
(dom-by-tag dom 'td)
=> '((td ...) (td ...) (td ...))
@end lisp

@item dom-by-class @var{dom} @var{match}
Return all nodes in @var{dom} that have class names that match @var{match},
which is a regular expression.

@item dom-by-style @var{dom} @var{style}
Return all nodes in @var{dom} that have styles that match @var{match}, which
is a regular expression.

@item dom-by-id @var{dom} @var{style}
Return all nodes in @var{dom} that have IDs that match @var{match}, which is
a regular expression.

@item dom-strings @var{dom}
Return all strings in @var{DOM}.

@end table

Utility functions:

@table @code
@item dom-pp @var{dom} &optional @var{remove-empty}
Pretty-print @var{dom} at point.  If @var{remove-empty}, don't print textual
nodes that just contain white-space.
@end table


@node Atomic Changes
@section グループのアトミックな変更
@cindex atomic changes

  データベース用語で@dfn{アトミック(atomic:
原子的、不可分な)}変更とは、全体として成功もしくは失敗することはできるが、部分的にはできない、個別の変更のことです。Lispプログラムは単一もしくは複数のバッファーにたいする一連の変更を@dfn{アトミック変更グループ(atomic
change
group)}にすることができます。これはその一連の変更全体が、それらのバッファーに適用されるか、またはエラーの場合は何も適用されないかの、いずれかであることを意味します。

  すでにカレントであるような単一のバッファーにたいしてこれを行うには、以下のように変更を行うこーの周りに、単に@code{atomic-change-group}の呼び出しを記述します:

@example
(atomic-change-group
  (insert foo)
  (delete-region x y))
@end example

@noindent
@code{atomic-change-group}のbody内部でエラー(またはその他の非ローカルexit)が発生した場合は、そのbody実行の間にそのバッファーでのすべての変更が行われなかったことになります。この類の変更グループは、他のバッファーには影響を与えず、それらのバッファーにたいする変更はそのまま残されます。

  さまざまなバッファー内で行った変更から1つのアトミックグループを構成する等、より複雑な何かを必要とする場合は、@code{atomic-change-group}が使用する、より低レベルな関数を直接呼び出さなければなりません。

@defun prepare-change-group &optional buffer
This function sets up a change group for buffer @var{buffer}, which defaults
to the current buffer.  It returns a handle that represents the change
group.  You must use this handle to activate the change group and
subsequently to finish it.
@end defun

  変更グループを使用するためには、それを@dfn{activate(アクティブ化)}しなければなりません。これは@var{buffer}のテキストを変更する前に行わなければなりません。

@defun activate-change-group handle
これは、@var{handle}が指定する変更グループをactiveにする。
@end defun

  変更グループをactivateした後は、そのバッファー内で行ったすべての変更は、その変更グループの一部となります。そのバッファー内で目論んでいたすべての変更を行ったら、その変更グループを@dfn{finish(完了)}しなければなりません。すべての変更を受け入れる(確定する)か、すべてをキャンセルするという2つの方法により、これを行うことができます。

@defun accept-change-group handle
この関数は@var{handle}により指定される変更グループ内のすべての変更にたいして、finalizeすることにより変更を受け入れる。
@end defun

@defun cancel-change-group handle
この関数は@var{handle}により指定される変更グループ内のすべての変更をキャンセルしてundoする。
@end defun

  グループが常に確実にfinishされるようにするために、コードでは@code{unwind-protect}を使用するべきです。@code{activate-change-group}の呼び出しは、実行直後にユーザーが@kbd{C-g}をタイプする場合に備え、@code{unwind-protect}内部にあるべきです(これが@code{prepare-change-group}と@code{activate-change-group}が別関数となっている1つの理由である。なぜなら通常は@code{unwind-protect}開始前に@code{prepare-change-group}を呼び出すであろうから)。グループを一度finishしたら、そのhandleを再度使用してはなりません。特に、同じ変更グループを2回finishしないでください。

  複数バッファー変更グループ(multibuffer change
group)を作成するためには、カバーしたいバッファーそれぞれで@code{prepare-change-group}を一度呼び出してから、以下のようにリターン値を結合するために、@code{nconc}を使用してください:

@example
(nconc (prepare-change-group buffer-1)
       (prepare-change-group buffer-2))
@end example

その後は1回の@code{activate-change-group}呼び出しで複数変更グループをアクティブにして、1回の@code{accept-change-group}または@code{cancel-change-group}呼び出しで、それをfinishしてください。

  同一バッファーにたいするネストされた複数の変更グループ使用は、あなたが期待するであろう通り機能します。同一バッファーにたいするネストされていない変更グループ使用により、Emacsが混乱した状態になるため、これが発生しないようにしてください。与えられた何らかのバッファーにたいして最初に開始した変更グループは、最後にfinishする変更グループです。

@node Change Hooks
@section フックの変更
@cindex change hooks
@cindex hooks for text changes

  These hook variables let you arrange to take notice of changes in buffers
(or in a particular buffer, if you make them buffer-local).  See also
@ref{Special Properties}, for how to detect changes to specific parts of the
text.

  これらのフック内で使用する関数は、もしそれらが正規表現を使用して何かを行う場合は、マッチしたデータの保存とリストアを行うべきです。さもないと、それらが呼び出す編集処理に、奇妙な方法で干渉するでしょう。

@defvar before-change-functions
This variable holds a list of functions to call when Emacs is about to
modify a buffer.  Each function gets two arguments, the beginning and end of
the region that is about to change, represented as integers.  The buffer
that is about to change is always the current buffer when the function is
called.
@end defvar

@defvar after-change-functions
This variable holds a list of functions to call after Emacs modifies a
buffer.  Each function receives three arguments: the beginning and end of
the region just changed, and the length of the text that existed before the
change.  All three arguments are integers.  The buffer that has been changed
is always the current buffer when the function is called.

古いテキストの長さは、変更される前のテキストでの、そのテキストの前後のバッファー位置の差である。変更されたテキストでは、その長さは単に最初の2つの引数の差である。
@end defvar

  Output of messages into the @file{*Messages*} buffer does not call these
functions, and neither do certain internal buffer changes, such as changes
in buffers created by Emacs internally for certain jobs, that should not be
visible to Lisp programs.

  Do @emph{not} expect the before-change hooks and the after-change hooks be
called in balanced pairs around each buffer change.  Also don't expect the
before-change hooks to be called for every chunk of text Emacs is about to
delete.  These hooks are provided on the assumption that Lisp programs will
use either before- or the after-change hooks, but not both, and the
boundaries of the region where the changes happen might include more than
just the actual changed text, or even lump together several changes done
piecemeal.

@defmac combine-after-change-calls body@dots{}
このマクロは普通に@var{body}を実行するが、もしそれが安全なように見えるなら、一連の複数の変更にたいして正に一度、after-change関数を呼び出すようにアレンジする。

そのバッファーの同じ領域内でプログラムが複数のテキスト変更を行う場合は、その部分のプログラムの周囲でマクロ@code{combine-after-change-calls}を使用することにより、after-changeフック使用中の実行がかなり高速になり得る。after-changeフックが最終的に呼び出される際、その引数は@code{combine-after-change-calls}のbody内で行われたすべての変更にたいして含むバッファーの範囲を指定する。

@strong{警告:}
フォーム@code{combine-after-change-calls}のbody内で、@code{after-change-functions}の値を変更してはならない。

@strong{警告:}
組み合わされた変更がバッファーの広い範囲にばらばらに発生する場合でも、これは依然として機能するものの、お勧めはできない。なぜならこれは、ある変更フック関数を、非効率的な挙動へと導くかもしれないからである。
@end defmac

@defvar first-change-hook
この変数は、以前は未変更の状態だったバッファーが変更された際は常に実行されるノーマルフックである。
@end defvar

@defvar inhibit-modification-hooks
この変数が非@code{nil}なら、すべての変更フックは無効になる。それらは何も実行されない。これはこのセクションで説明したすべてのフック変数、同様に特定のスペシャルテキストプロパティ(@ref{Special
Properties}を参照)とオーバーレイプロパティ(@ref{Overlay Properties}を参照)にアタッチされたフックに影響を与える。

これらの同じフック変数実行の間、バッファー変更によるデフォルトの変更フックが他の変更フック実行中に実行されないように、この変数は非@code{nil}にバインドされるそれ自体が変更フックから実行される特定のコード断片内で変更フックを実行したければ、ローカルに@code{inhibit-modification-hooks}を@code{nil}に再バインドすること。
@end defvar
