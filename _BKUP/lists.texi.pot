# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-10-14 22:48+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/lists.texi:6 original_texis/lists.texi:7
#, no-wrap
msgid "Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:8
#, no-wrap
msgid "lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:9
#, no-wrap
msgid "element (of list)"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:16
msgid ""
"A @dfn{list} represents a sequence of zero or more elements (which may be "
"any Lisp objects).  The important difference between lists and vectors is "
"that two or more lists can share part of their structure; in addition, you "
"can insert or delete elements in a list without copying the whole list."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:29
#, no-wrap
msgid "Cons Cells"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "How lists are made out of cons cells."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:85
#, no-wrap
msgid "List-related Predicates"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Is this object a list? Comparing two lists."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:157
#, no-wrap
msgid "List Elements"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Extracting the pieces of a list."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:379
#, no-wrap
msgid "Building Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Creating list structure."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:665
#, no-wrap
msgid "List Variables"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Modifying lists stored in variables."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:797
#, no-wrap
msgid "Modifying Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "Storing new pieces into an existing list."
msgstr ""

#. type: node
#: original_texis/lists.texi:27 original_texis/lists.texi:1134
#, no-wrap
msgid "Sets And Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list can represent a finite mathematical set."
msgstr ""

#. type: section
#: original_texis/lists.texi:27 original_texis/lists.texi:1409 original_texis/lists.texi:1410
#, no-wrap
msgid "Association Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list can represent a finite relation or mapping."
msgstr ""

#. type: section
#: original_texis/lists.texi:27 original_texis/lists.texi:1707 original_texis/lists.texi:1708
#, no-wrap
msgid "Property Lists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:27
msgid "A list of paired elements."
msgstr ""

#. type: section
#: original_texis/lists.texi:30
#, no-wrap
msgid "Lists and Cons Cells"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:31
#, no-wrap
msgid "lists and cons cells"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:40
msgid ""
"Lists in Lisp are not a primitive data type; they are built up from "
"@dfn{cons cells} (@pxref{Cons Cell Type}).  A cons cell is a data object "
"that represents an ordered pair.  That is, it has two slots, and each slot "
"@dfn{holds}, or @dfn{refers to}, some Lisp object.  One slot is known as the "
"@sc{car}, and the other is known as the @sc{cdr}.  (These names are "
"traditional; see @ref{Cons Cell Type}.)  @sc{cdr} is pronounced "
"``could-er''."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:43
msgid ""
"We say that ``the @sc{car} of this cons cell is'' whatever object its "
"@sc{car} slot currently holds, and likewise for the @sc{cdr}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:52
msgid ""
"A list is a series of cons cells chained together, so that each cell refers "
"to the next one.  There is one cons cell for each element of the list.  By "
"convention, the @sc{car}s of the cons cells hold the elements of the list, "
"and the @sc{cdr}s are used to chain the list (this asymmetry between "
"@sc{car} and @sc{cdr} is entirely a matter of convention; at the level of "
"cons cells, the @sc{car} and @sc{cdr} slots have similar properties).  "
"Hence, the @sc{cdr} slot of each cons cell in a list refers to the following "
"cons cell."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:53
#, no-wrap
msgid "true list"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:60
msgid ""
"Also by convention, the @sc{cdr} of the last cons cell in a list is "
"@code{nil}.  We call such a @code{nil}-terminated structure a @dfn{true "
"list}.  In Emacs Lisp, the symbol @code{nil} is both a symbol and a list "
"with no elements.  For convenience, the symbol @code{nil} is considered to "
"have @code{nil} as its @sc{cdr} (and also as its @sc{car})."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:64
msgid ""
"Hence, the @sc{cdr} of a true list is always a true list.  The @sc{cdr} of a "
"nonempty true list is a true list containing all the elements except the "
"first."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:65
#, no-wrap
msgid "dotted list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:66
#, no-wrap
msgid "circular list"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:73
msgid ""
"If the @sc{cdr} of a list's last cons cell is some value other than "
"@code{nil}, we call the structure a @dfn{dotted list}, since its printed "
"representation would use dotted pair notation (@pxref{Dotted Pair "
"Notation}).  There is one other possibility: some cons cell's @sc{cdr} could "
"point to one of the previous cons cells in the list.  We call that structure "
"a @dfn{circular list}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:80
msgid ""
"For some purposes, it does not matter whether a list is true, circular or "
"dotted.  If a program doesn't look far enough down the list to see the "
"@sc{cdr} of the final cons cell, it won't care.  However, some functions "
"that operate on lists demand true lists and signal errors if given a dotted "
"list.  Most functions that try to find the end of a list enter infinite "
"loops if given a circular list."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:81
#, no-wrap
msgid "list structure"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:84
msgid ""
"Because most cons cells are used as part of lists, we refer to any structure "
"made out of cons cells as a @dfn{list structure}."
msgstr ""

#. type: section
#: original_texis/lists.texi:86
#, no-wrap
msgid "Predicates on Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:87
#, no-wrap
msgid "predicates for lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:88
#, no-wrap
msgid "list predicates"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:95
msgid ""
"The following predicates test whether a Lisp object is an atom, whether it "
"is a cons cell or is a list, or whether it is the distinguished object "
"@code{nil}.  (Many of these predicates can be defined in terms of the "
"others, but they are used so often that it is worth having them.)"
msgstr ""

#. type: defun
#: original_texis/lists.texi:96
#, no-wrap
msgid "consp object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:99
msgid ""
"This function returns @code{t} if @var{object} is a cons cell, @code{nil} "
"otherwise.  @code{nil} is not a cons cell, although it @emph{is} a list."
msgstr ""

#. type: defun
#: original_texis/lists.texi:101
#, no-wrap
msgid "atom object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:106
msgid ""
"This function returns @code{t} if @var{object} is an atom, @code{nil} "
"otherwise.  All objects except cons cells are atoms.  The symbol @code{nil} "
"is an atom and is also a list; it is the only Lisp object that is both."
msgstr ""

#. type: example
#: original_texis/lists.texi:109
#, no-wrap
msgid "(atom @var{object}) @equiv{} (not (consp @var{object}))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:112
#, no-wrap
msgid "listp object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:115
msgid ""
"This function returns @code{t} if @var{object} is a cons cell or "
"@code{nil}.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:120
#, no-wrap
msgid ""
"(listp '(1))\n"
"     @result{} t\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:124
#, no-wrap
msgid ""
"(listp '())\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:128
#, no-wrap
msgid "nlistp object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:131
msgid ""
"This function is the opposite of @code{listp}: it returns @code{t} if "
"@var{object} is not a list.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: example
#: original_texis/lists.texi:134
#, no-wrap
msgid "(listp @var{object}) @equiv{} (not (nlistp @var{object}))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:137
#, no-wrap
msgid "null object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:143
msgid ""
"This function returns @code{t} if @var{object} is @code{nil}, and returns "
"@code{nil} otherwise.  This function is identical to @code{not}, but as a "
"matter of clarity we use @code{null} when @var{object} is considered a list "
"and @code{not} when it is considered a truth value (see @code{not} in "
"@ref{Combining Conditions})."
msgstr ""

#. type: group
#: original_texis/lists.texi:148
#, no-wrap
msgid ""
"(null '(1))\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:152
#, no-wrap
msgid ""
"(null '())\n"
"     @result{} t\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:158
#, no-wrap
msgid "Accessing Elements of Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:159
#, no-wrap
msgid "list elements"
msgstr ""

#. type: defun
#: original_texis/lists.texi:161
#, no-wrap
msgid "car cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:165
msgid ""
"This function returns the value referred to by the first slot of the cons "
"cell @var{cons-cell}.  In other words, it returns the @sc{car} of "
"@var{cons-cell}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:169
msgid ""
"As a special case, if @var{cons-cell} is @code{nil}, this function returns "
"@code{nil}.  Therefore, any list is a valid argument.  An error is signaled "
"if the argument is not a cons cell or @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:174
#, no-wrap
msgid ""
"(car '(a b c))\n"
"     @result{} a\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:178
#, no-wrap
msgid ""
"(car '())\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:182
#, no-wrap
msgid "cdr cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:186
msgid ""
"This function returns the value referred to by the second slot of the cons "
"cell @var{cons-cell}.  In other words, it returns the @sc{cdr} of "
"@var{cons-cell}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:190
msgid ""
"As a special case, if @var{cons-cell} is @code{nil}, this function returns "
"@code{nil}; therefore, any list is a valid argument.  An error is signaled "
"if the argument is not a cons cell or @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:195
#, no-wrap
msgid ""
"(cdr '(a b c))\n"
"     @result{} (b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:199
#, no-wrap
msgid ""
"(cdr '())\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:203
#, no-wrap
msgid "car-safe object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:208
msgid ""
"This function lets you take the @sc{car} of a cons cell while avoiding "
"errors for other data types.  It returns the @sc{car} of @var{object} if "
"@var{object} is a cons cell, @code{nil} otherwise.  This is in contrast to "
"@code{car}, which signals an error if @var{object} is not a list."
msgstr ""

#. type: group
#: original_texis/lists.texi:217
#, no-wrap
msgid ""
"(car-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (car x)\n"
"    nil))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:221
#, no-wrap
msgid "cdr-safe object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:227
msgid ""
"This function lets you take the @sc{cdr} of a cons cell while avoiding "
"errors for other data types.  It returns the @sc{cdr} of @var{object} if "
"@var{object} is a cons cell, @code{nil} otherwise.  This is in contrast to "
"@code{cdr}, which signals an error if @var{object} is not a list."
msgstr ""

#. type: group
#: original_texis/lists.texi:236
#, no-wrap
msgid ""
"(cdr-safe @var{object})\n"
"@equiv{}\n"
"(let ((x @var{object}))\n"
"  (if (consp x)\n"
"      (cdr x)\n"
"    nil))\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:240
#, no-wrap
msgid "pop listname"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:246
msgid ""
"This macro provides a convenient way to examine the @sc{car} of a list, and "
"take it off the list, all at once.  It operates on the list stored in "
"@var{listname}.  It removes the first element from the list, saves the "
"@sc{cdr} into @var{listname}, then returns the removed element."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:250
msgid ""
"In the simplest case, @var{listname} is an unquoted symbol naming a list; in "
"that case, this macro is equivalent to @w{@code{(prog1 (car listname) (setq "
"listname (cdr listname)))}}."
msgstr ""

#. type: example
#: original_texis/lists.texi:258
#, no-wrap
msgid ""
"x\n"
"     @result{} (a b c)\n"
"(pop x)\n"
"     @result{} a\n"
"x\n"
"     @result{} (b c)\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:263
msgid ""
"More generally, @var{listname} can be a generalized variable.  In that case, "
"this macro saves into @var{listname} using @code{setf}.  @xref{Generalized "
"Variables}."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:266
msgid ""
"For the @code{push} macro, which adds an element to a list, @xref{List "
"Variables}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:268
#, no-wrap
msgid "nth n list"
msgstr ""

#. type: anchor{#1}
#: original_texis/lists.texi:274
msgid "Definition of nth"
msgstr ""

#. type: defun
#: original_texis/lists.texi:274
msgid ""
"This function returns the @var{n}th element of @var{list}.  Elements are "
"numbered starting with zero, so the @sc{car} of @var{list} is element number "
"zero.  If the length of @var{list} is @var{n} or less, the value is "
"@code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:284
#, no-wrap
msgid ""
"(nth 2 '(1 2 3 4))\n"
"     @result{} 3\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:288
#, no-wrap
msgid ""
"(nth 10 '(1 2 3 4))\n"
"     @result{} nil\n"
"\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:290
#, no-wrap
msgid "(nth n x) @equiv{} (car (nthcdr n x))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:296
msgid ""
"The function @code{elt} is similar, but applies to any kind of sequence.  "
"For historical reasons, it takes its arguments in the opposite order.  "
"@xref{Sequence Functions}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:298
#, no-wrap
msgid "nthcdr n list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:302
msgid ""
"This function returns the @var{n}th @sc{cdr} of @var{list}.  In other words, "
"it skips past the first @var{n} links of @var{list} and returns what "
"follows."
msgstr ""

#. type: defun
#: original_texis/lists.texi:307
msgid ""
"If @var{n} is zero, @code{nthcdr} returns all of @var{list}.  If the length "
"of @var{list} is @var{n} or less, @code{nthcdr} returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:312
#, no-wrap
msgid ""
"(nthcdr 1 '(1 2 3 4))\n"
"     @result{} (2 3 4)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:316
#, no-wrap
msgid ""
"(nthcdr 10 '(1 2 3 4))\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:320
#, no-wrap
msgid ""
"(nthcdr 0 '(1 2 3 4))\n"
"     @result{} (1 2 3 4)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:324
#, no-wrap
msgid "last list &optional n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:330
msgid ""
"This function returns the last link of @var{list}.  The @code{car} of this "
"link is the list's last element.  If @var{list} is null, @code{nil} is "
"returned.  If @var{n} is non-@code{nil}, the @var{n}th-to-last link is "
"returned instead, or the whole of @var{list} if @var{n} is bigger than "
"@var{list}'s length."
msgstr ""

#. type: defun
#: original_texis/lists.texi:332
#, no-wrap
msgid "safe-length list"
msgstr ""

#. type: anchor{#1}
#: original_texis/lists.texi:338
msgid "Definition of safe-length"
msgstr ""

#. type: defun
#: original_texis/lists.texi:338
msgid ""
"This function returns the length of @var{list}, with no risk of either an "
"error or an infinite loop.  It generally returns the number of distinct cons "
"cells in the list.  However, for circular lists, the value is just an upper "
"bound; it is often too large."
msgstr ""

#. type: defun
#: original_texis/lists.texi:341
msgid ""
"If @var{list} is not @code{nil} or a cons cell, @code{safe-length} returns "
"0."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:346
msgid ""
"The most common way to compute the length of a list, when you are not "
"worried that it may be circular, is with @code{length}.  @xref{Sequence "
"Functions}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:347
#, no-wrap
msgid "caar cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:349
msgid "This is the same as @code{(car (car @var{cons-cell}))}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:351
#, no-wrap
msgid "cadr cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:354
msgid ""
"This is the same as @code{(car (cdr @var{cons-cell}))} or @code{(nth 1 "
"@var{cons-cell})}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:356
#, no-wrap
msgid "cdar cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:358
msgid "This is the same as @code{(cdr (car @var{cons-cell}))}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:360
#, no-wrap
msgid "cddr cons-cell"
msgstr ""

#. type: defun
#: original_texis/lists.texi:363
msgid ""
"This is the same as @code{(cdr (cdr @var{cons-cell}))} or @code{(nthcdr 2 "
"@var{cons-cell})}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:365
#, no-wrap
msgid "butlast x &optional n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:371
msgid ""
"This function returns the list @var{x} with the last element, or the last "
"@var{n} elements, removed.  If @var{n} is greater than zero it makes a copy "
"of the list so as not to damage the original list.  In general, "
"@code{(append (butlast @var{x} @var{n})  (last @var{x} @var{n}))} will "
"return a list equal to @var{x}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:373
#, no-wrap
msgid "nbutlast x &optional n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:377
msgid ""
"This is a version of @code{butlast} that works by destructively modifying "
"the @code{cdr} of the appropriate element, rather than making a copy of the "
"list."
msgstr ""

#. type: section
#: original_texis/lists.texi:380
#, no-wrap
msgid "Building Cons Cells and Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:381
#, no-wrap
msgid "cons cells"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:382
#, no-wrap
msgid "building lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:388
msgid ""
"Many functions build lists, as lists reside at the very heart of Lisp.  "
"@code{cons} is the fundamental list-building function; however, it is "
"interesting to note that @code{list} is used more times in the source code "
"for Emacs than @code{cons}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:389
#, no-wrap
msgid "cons object1 object2"
msgstr ""

#. type: defun
#: original_texis/lists.texi:395
msgid ""
"This function is the most basic function for building new list structure.  "
"It creates a new cons cell, making @var{object1} the @sc{car}, and "
"@var{object2} the @sc{cdr}.  It then returns the new cons cell.  The "
"arguments @var{object1} and @var{object2} may be any Lisp objects, but most "
"often @var{object2} is a list."
msgstr ""

#. type: group
#: original_texis/lists.texi:400
#, no-wrap
msgid ""
"(cons 1 '(2))\n"
"     @result{} (1 2)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:404
#, no-wrap
msgid ""
"(cons 1 '())\n"
"     @result{} (1)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:408
#, no-wrap
msgid ""
"(cons 1 2)\n"
"     @result{} (1 . 2)\n"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:411
#, no-wrap
msgid "consing"
msgstr ""

#. type: defun
#: original_texis/lists.texi:423
msgid ""
"@code{cons} is often used to add a single element to the front of a list.  "
"This is called @dfn{consing the element onto the list}.  @footnote{There is "
"no strictly equivalent way to add an element to the end of a list.  You can "
"use @code{(append @var{listname} (list @var{newelt}))}, which creates a "
"whole new list by copying @var{listname} and adding @var{newelt} to its "
"end.  Or you can use @code{(nconc @var{listname} (list @var{newelt}))}, "
"which modifies @var{listname} by following all the @sc{cdr}s and then "
"replacing the terminating @code{nil}.  Compare this to adding an element to "
"the beginning of a list with @code{cons}, which neither copies nor modifies "
"the list.} For example:"
msgstr ""

#. type: example
#: original_texis/lists.texi:426
#, no-wrap
msgid "(setq list (cons newelt list))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:431
msgid ""
"Note that there is no conflict between the variable named @code{list} used "
"in this example and the function named @code{list} described below; any "
"symbol can serve both purposes."
msgstr ""

#. type: defun
#: original_texis/lists.texi:433
#, no-wrap
msgid "list &rest objects"
msgstr ""

#. type: defun
#: original_texis/lists.texi:437
msgid ""
"This function creates a list with @var{objects} as its elements.  The "
"resulting list is always @code{nil}-terminated.  If no @var{objects} are "
"given, the empty list is returned."
msgstr ""

#. type: group
#: original_texis/lists.texi:442
#, no-wrap
msgid ""
"(list 1 2 3 4 5)\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:446
#, no-wrap
msgid ""
"(list 1 2 '(3 4 5) 'foo)\n"
"     @result{} (1 2 (3 4 5) foo)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:450
#, no-wrap
msgid ""
"(list)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:454
#, no-wrap
msgid "make-list length object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:458
msgid ""
"This function creates a list of @var{length} elements, in which each element "
"is @var{object}.  Compare @code{make-list} with @code{make-string} "
"(@pxref{Creating Strings})."
msgstr ""

#. type: group
#: original_texis/lists.texi:463
#, no-wrap
msgid ""
"(make-list 3 'pigs)\n"
"     @result{} (pigs pigs pigs)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:467
#, no-wrap
msgid ""
"(make-list 0 'pigs)\n"
"     @result{} nil\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:473
#, no-wrap
msgid ""
"(setq l (make-list 3 '(a b)))\n"
"     @result{} ((a b) (a b) (a b))\n"
"(eq (car l) (cadr l))\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:477
#, no-wrap
msgid "append &rest sequences"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:478
#, no-wrap
msgid "copying lists"
msgstr ""

#. type: defun
#: original_texis/lists.texi:485
msgid ""
"This function returns a list containing all the elements of "
"@var{sequences}.  The @var{sequences} may be lists, vectors, bool-vectors, "
"or strings, but the last one should usually be a list.  All arguments except "
"the last one are copied, so none of the arguments is altered.  (See "
"@code{nconc} in @ref{Rearrangement}, for a way to join lists with no "
"copying.)"
msgstr ""

#. type: defun
#: original_texis/lists.texi:493
msgid ""
"More generally, the final argument to @code{append} may be any Lisp object.  "
"The final argument is not copied or converted; it becomes the @sc{cdr} of "
"the last cons cell in the new list.  If the final argument is itself a list, "
"then its elements become in effect elements of the result list.  If the "
"final element is not a list, the result is a dotted list since its final "
"@sc{cdr} is not @code{nil} as required in a true list."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:496
msgid "Here is an example of using @code{append}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:503
#, no-wrap
msgid ""
"(setq trees '(pine oak))\n"
"     @result{} (pine oak)\n"
"(setq more-trees (append '(maple birch) trees))\n"
"     @result{} (maple birch pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:510
#, no-wrap
msgid ""
"trees\n"
"     @result{} (pine oak)\n"
"more-trees\n"
"     @result{} (maple birch pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:514
#, no-wrap
msgid ""
"(eq trees (cdr (cdr more-trees)))\n"
"     @result{} t\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:522
msgid ""
"You can see how @code{append} works by looking at a box diagram.  The "
"variable @code{trees} is set to the list @code{(pine oak)} and then the "
"variable @code{more-trees} is set to the list @code{(maple birch pine "
"oak)}.  However, the variable @code{trees} continues to refer to the "
"original list:"
msgstr ""

#. type: group
#: original_texis/lists.texi:533
#, no-wrap
msgid ""
"more-trees                trees\n"
"|                           |\n"
"|     --- ---      --- ---   -> --- ---      --- ---\n"
" --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil\n"
"      --- ---      --- ---      --- ---      --- ---\n"
"       |            |            |            |\n"
"       |            |            |            |\n"
"        --> maple    -->birch     --> pine     --> oak\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:539
msgid ""
"An empty sequence contributes nothing to the value returned by "
"@code{append}.  As a consequence of this, a final @code{nil} argument forces "
"a copy of the previous argument:"
msgstr ""

#. type: group
#: original_texis/lists.texi:544
#, no-wrap
msgid ""
"trees\n"
"     @result{} (pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:548
#, no-wrap
msgid ""
"(setq wood (append trees nil))\n"
"     @result{} (pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:552
#, no-wrap
msgid ""
"wood\n"
"     @result{} (pine oak)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:556
#, no-wrap
msgid ""
"(eq wood trees)\n"
"     @result{} nil\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:562
msgid ""
"This once was the usual way to copy a list, before the function "
"@code{copy-sequence} was invented.  @xref{Sequences Arrays Vectors}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:564
msgid "Here we show the use of vectors and strings as arguments to @code{append}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:569
#, no-wrap
msgid ""
"(append [a b] \"cd\" nil)\n"
"     @result{} (a b 99 100)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:574
msgid ""
"With the help of @code{apply} (@pxref{Calling Functions}), we can append all "
"the lists in a list of lists:"
msgstr ""

#. type: group
#: original_texis/lists.texi:579
#, no-wrap
msgid ""
"(apply 'append '((a b c) nil (x y z) nil))\n"
"     @result{} (a b c x y z)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:583
msgid "If no @var{sequences} are given, @code{nil} is returned:"
msgstr ""

#. type: group
#: original_texis/lists.texi:588
#, no-wrap
msgid ""
"(append)\n"
"     @result{} nil\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:592
msgid "Here are some examples where the final argument is not a list:"
msgstr ""

#. type: example
#: original_texis/lists.texi:598
#, no-wrap
msgid ""
"(append '(x y) 'z)\n"
"     @result{} (x y . z)\n"
"(append '(x y) [z])\n"
"     @result{} (x y . [z])\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:605
msgid ""
"The second example shows that when the final argument is a sequence but not "
"a list, the sequence's elements do not become elements of the resulting "
"list.  Instead, the sequence becomes the final @sc{cdr}, like any other "
"non-list final argument."
msgstr ""

#. type: defun
#: original_texis/lists.texi:606
#, no-wrap
msgid "copy-tree tree &optional vecp"
msgstr ""

#. type: defun
#: original_texis/lists.texi:611
msgid ""
"This function returns a copy of the tree @code{tree}.  If @var{tree} is a "
"cons cell, this makes a new cons cell with the same @sc{car} and @sc{cdr}, "
"then recursively copies the @sc{car} and @sc{cdr} in the same way."
msgstr ""

#. type: defun
#: original_texis/lists.texi:616
msgid ""
"Normally, when @var{tree} is anything other than a cons cell, "
"@code{copy-tree} simply returns @var{tree}.  However, if @var{vecp} is "
"non-@code{nil}, it copies vectors too (and operates recursively on their "
"elements)."
msgstr ""

#. type: defun
#: original_texis/lists.texi:618
#, no-wrap
msgid "number-sequence from &optional to separation"
msgstr ""

#. type: defun
#: original_texis/lists.texi:627
msgid ""
"This returns a list of numbers starting with @var{from} and incrementing by "
"@var{separation}, and ending at or just before @var{to}.  @var{separation} "
"can be positive or negative and defaults to 1.  If @var{to} is @code{nil} or "
"numerically equal to @var{from}, the value is the one-element list "
"@code{(@var{from})}.  If @var{to} is less than @var{from} with a positive "
"@var{separation}, or greater than @var{from} with a negative "
"@var{separation}, the value is @code{nil} because those arguments specify an "
"empty sequence."
msgstr ""

#. type: defun
#: original_texis/lists.texi:631
msgid ""
"If @var{separation} is 0 and @var{to} is neither @code{nil} nor numerically "
"equal to @var{from}, @code{number-sequence} signals an error, since those "
"arguments specify an infinite sequence."
msgstr ""

#. type: defun
#: original_texis/lists.texi:644
msgid ""
"All arguments are numbers.  Floating-point arguments can be tricky, because "
"floating-point arithmetic is inexact.  For instance, depending on the "
"machine, it may quite well happen that @code{(number-sequence 0.4 0.6 0.2)} "
"returns the one element list @code{(0.4)}, whereas @code{(number-sequence "
"0.4 0.8 0.2)} returns a list with three elements.  The @var{n}th element of "
"the list is computed by the exact formula @code{(+ @var{from} (* @var{n} "
"@var{separation}))}.  Thus, if one wants to make sure that @var{to} is "
"included in the list, one can pass an expression of this exact type for "
"@var{to}.  Alternatively, one can replace @var{to} with a slightly larger "
"value (or a slightly more negative value if @var{separation} is negative)."
msgstr ""

#. type: defun
#: original_texis/lists.texi:646
msgid "Some examples:"
msgstr ""

#. type: example
#: original_texis/lists.texi:662
#, no-wrap
msgid ""
"(number-sequence 4 9)\n"
"     @result{} (4 5 6 7 8 9)\n"
"(number-sequence 9 4 -1)\n"
"     @result{} (9 8 7 6 5 4)\n"
"(number-sequence 9 4 -2)\n"
"     @result{} (9 7 5)\n"
"(number-sequence 8)\n"
"     @result{} (8)\n"
"(number-sequence 8 5)\n"
"     @result{} nil\n"
"(number-sequence 5 8 -1)\n"
"     @result{} nil\n"
"(number-sequence 1.5 6 2)\n"
"     @result{} (1.5 3.5 5.5)\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:666
#, no-wrap
msgid "Modifying List Variables"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:667
#, no-wrap
msgid "modify a list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:668
#, no-wrap
msgid "list modification"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:672
msgid ""
"These functions, and one macro, provide convenient ways to modify a list "
"which is stored in a variable."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:673
#, no-wrap
msgid "push element listname"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:679
msgid ""
"This macro creates a new list whose @sc{car} is @var{element} and whose "
"@sc{cdr} is the list specified by @var{listname}, and saves that list in "
"@var{listname}.  In the simplest case, @var{listname} is an unquoted symbol "
"naming a list, and this macro is equivalent to @w{@code{(setq @var{listname} "
"(cons @var{element} @var{listname}))}}."
msgstr ""

#. type: example
#: original_texis/lists.texi:687
#, no-wrap
msgid ""
"(setq l '(a b))\n"
"     @result{} (a b)\n"
"(push 'c l)\n"
"     @result{} (c a b)\n"
"l\n"
"     @result{} (c a b)\n"
msgstr ""

#. type: defmac
#: original_texis/lists.texi:693
msgid ""
"More generally, @code{listname} can be a generalized variable.  In that "
"case, this macro does the equivalent of @w{@code{(setf @var{listname} (cons "
"@var{element} @var{listname}))}}.  @xref{Generalized Variables}."
msgstr ""

#. type: defmac
#: original_texis/lists.texi:696
msgid ""
"For the @code{pop} macro, which removes the first element from a list, "
"@xref{List Elements}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:699
msgid "Two functions modify lists that are the values of variables."
msgstr ""

#. type: defun
#: original_texis/lists.texi:700
#, no-wrap
msgid "add-to-list symbol element &optional append compare-fn"
msgstr ""

#. type: defun
#: original_texis/lists.texi:708
msgid ""
"This function sets the variable @var{symbol} by consing @var{element} onto "
"the old value, if @var{element} is not already a member of that value.  It "
"returns the resulting list, whether updated or not.  The value of "
"@var{symbol} had better be a list already before the call.  "
"@code{add-to-list} uses @var{compare-fn} to compare @var{element} against "
"existing list members; if @var{compare-fn} is @code{nil}, it uses "
"@code{equal}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:712
msgid ""
"Normally, if @var{element} is added, it is added to the front of "
"@var{symbol}, but if the optional argument @var{append} is non-@code{nil}, "
"it is added at the end."
msgstr ""

#. type: defun
#: original_texis/lists.texi:716
msgid ""
"The argument @var{symbol} is not implicitly quoted; @code{add-to-list} is an "
"ordinary function, like @code{set} and unlike @code{setq}.  Quote the "
"argument yourself if that is what you want."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:719
msgid "Here's a scenario showing how to use @code{add-to-list}:"
msgstr ""

#. type: example
#: original_texis/lists.texi:723
#, no-wrap
msgid ""
"(setq foo '(a b))\n"
"     @result{} (a b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:726
#, no-wrap
msgid ""
"(add-to-list 'foo 'c)     ;; @r{Add @code{c}.}\n"
"     @result{} (c a b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:729
#, no-wrap
msgid ""
"(add-to-list 'foo 'b)     ;; @r{No effect.}\n"
"     @result{} (c a b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:732
#, no-wrap
msgid ""
"foo                       ;; @r{@code{foo} was changed.}\n"
"     @result{} (c a b)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:736
msgid ""
"An equivalent expression for @code{(add-to-list '@var{var} @var{value})} is "
"this:"
msgstr ""

#. type: example
#: original_texis/lists.texi:740
#, no-wrap
msgid ""
"(or (member @var{value} @var{var})\n"
"    (setq @var{var} (cons @var{value} @var{var})))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:742
#, no-wrap
msgid "add-to-ordered-list symbol element &optional order"
msgstr ""

#. type: defun
#: original_texis/lists.texi:749
msgid ""
"This function sets the variable @var{symbol} by inserting @var{element} into "
"the old value, which must be a list, at the position specified by "
"@var{order}.  If @var{element} is already a member of the list, its position "
"in the list is adjusted according to @var{order}.  Membership is tested "
"using @code{eq}.  This function returns the resulting list, whether updated "
"or not."
msgstr ""

#. type: defun
#: original_texis/lists.texi:752
msgid ""
"The @var{order} is typically a number (integer or float), and the elements "
"of the list are sorted in non-decreasing numerical order."
msgstr ""

#. type: defun
#: original_texis/lists.texi:757
msgid ""
"@var{order} may also be omitted or @code{nil}.  Then the numeric order of "
"@var{element} stays unchanged if it already has one; otherwise, "
"@var{element} has no numeric order.  Elements without a numeric list order "
"are placed at the end of the list, in no particular order."
msgstr ""

#. type: defun
#: original_texis/lists.texi:760
msgid ""
"Any other value for @var{order} removes the numeric order of @var{element} "
"if it already has one; otherwise, it is equivalent to @code{nil}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:764
msgid ""
"The argument @var{symbol} is not implicitly quoted; "
"@code{add-to-ordered-list} is an ordinary function, like @code{set} and "
"unlike @code{setq}.  Quote the argument yourself if necessary."
msgstr ""

#. type: defun
#: original_texis/lists.texi:767
msgid ""
"The ordering information is stored in a hash table on @var{symbol}'s "
"@code{list-order} property."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:770
msgid "Here's a scenario showing how to use @code{add-to-ordered-list}:"
msgstr ""

#. type: example
#: original_texis/lists.texi:774
#, no-wrap
msgid ""
"(setq foo '())\n"
"     @result{} nil\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:777
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'a 1)     ;; @r{Add @code{a}.}\n"
"     @result{} (a)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:780
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'c 3)     ;; @r{Add @code{c}.}\n"
"     @result{} (a c)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:783
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'b 2)     ;; @r{Add @code{b}.}\n"
"     @result{} (a b c)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:786
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'b 4)     ;; @r{Move @code{b}.}\n"
"     @result{} (a c b)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:789
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'd)       ;; @r{Append @code{d}.}\n"
"     @result{} (a c b d)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:792
#, no-wrap
msgid ""
"(add-to-ordered-list 'foo 'e)       ;; @r{Add @code{e}}.\n"
"     @result{} (a c b e d)\n"
"\n"
msgstr ""

#. type: example
#: original_texis/lists.texi:795
#, no-wrap
msgid ""
"foo                       ;; @r{@code{foo} was changed.}\n"
"     @result{} (a c b e d)\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:798
#, no-wrap
msgid "Modifying Existing List Structure"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:799
#, no-wrap
msgid "destructive list operations"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:804
msgid ""
"You can modify the @sc{car} and @sc{cdr} contents of a cons cell with the "
"primitives @code{setcar} and @code{setcdr}.  These are destructive "
"operations because they change existing list structure."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:805
#, no-wrap
msgid "CL note---@code{rplaca} vs @code{setcar}"
msgstr ""

#. type: findex
#: original_texis/lists.texi:807
#, no-wrap
msgid "rplaca"
msgstr ""

#. type: findex
#: original_texis/lists.texi:808
#, no-wrap
msgid "rplacd"
msgstr ""

#. type: quotation
#: original_texis/lists.texi:814
msgid ""
"@b{Common Lisp note:} Common Lisp uses functions @code{rplaca} and "
"@code{rplacd} to alter list structure; they change structure the same way as "
"@code{setcar} and @code{setcdr}, but the Common Lisp functions return the "
"cons cell while @code{setcar} and @code{setcdr} return the new @sc{car} or "
"@sc{cdr}."
msgstr ""

#. type: node
#: original_texis/lists.texi:821 original_texis/lists.texi:823
#, no-wrap
msgid "Setcar"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:821
msgid "Replacing an element in a list."
msgstr ""

#. type: node
#: original_texis/lists.texi:821 original_texis/lists.texi:930
#, no-wrap
msgid "Setcdr"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:821
msgid ""
"Replacing part of the list backbone.  This can be used to remove or add "
"elements."
msgstr ""

#. type: node
#: original_texis/lists.texi:821 original_texis/lists.texi:1032
#, no-wrap
msgid "Rearrangement"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:821
msgid "Reordering the elements in a list; combining lists."
msgstr ""

#. type: subsection
#: original_texis/lists.texi:824
#, no-wrap
msgid "Altering List Elements with @code{setcar}"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:825
#, no-wrap
msgid "replace list element"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:826
#, no-wrap
msgid "list, replace element"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:831
msgid ""
"Changing the @sc{car} of a cons cell is done with @code{setcar}.  When used "
"on a list, @code{setcar} replaces one element of a list with a different "
"element."
msgstr ""

#. type: defun
#: original_texis/lists.texi:832
#, no-wrap
msgid "setcar cons object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:837
msgid ""
"This function stores @var{object} as the new @sc{car} of @var{cons}, "
"replacing its previous @sc{car}.  In other words, it changes the @sc{car} "
"slot of @var{cons} to refer to @var{object}.  It returns the value "
"@var{object}.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:842
#, no-wrap
msgid ""
"(setq x '(1 2))\n"
"     @result{} (1 2)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:846
#, no-wrap
msgid ""
"(setcar x 4)\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:850
#, no-wrap
msgid ""
"x\n"
"     @result{} (4 2)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:857
msgid ""
"When a cons cell is part of the shared structure of several lists, storing a "
"new @sc{car} into the cons changes one element of each of these lists.  Here "
"is an example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:865
#, no-wrap
msgid ""
";; @r{Create two lists that are partly shared.}\n"
"(setq x1 '(a b c))\n"
"     @result{} (a b c)\n"
"(setq x2 (cons 'z (cdr x1)))\n"
"     @result{} (z b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:875
#, no-wrap
msgid ""
";; @r{Replace the @sc{car} of a shared link.}\n"
"(setcar (cdr x1) 'foo)\n"
"     @result{} foo\n"
"x1                           ; @r{Both lists are changed.}\n"
"     @result{} (a foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:885
#, no-wrap
msgid ""
";; @r{Replace the @sc{car} of a link that is not shared.}\n"
"(setcar x1 'baz)\n"
"     @result{} baz\n"
"x1                           ; @r{Only one list is changed.}\n"
"     @result{} (baz foo c)\n"
"x2\n"
"     @result{} (z foo c)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:891
msgid ""
"Here is a graphical depiction of the shared structure of the two lists in "
"the variables @code{x1} and @code{x2}, showing why replacing @code{b} "
"changes them both:"
msgstr ""

#. type: group
#: original_texis/lists.texi:907
#, no-wrap
msgid ""
"        --- ---        --- ---      --- ---\n"
"x1---> |   |   |----> |   |   |--> |   |   |--> nil\n"
"        --- ---        --- ---      --- ---\n"
"         |        -->   |            |\n"
"         |       |      |            |\n"
"          --> a  |       --> b        --> c\n"
"                 |\n"
"       --- ---   |\n"
"x2--> |   |   |--\n"
"       --- ---\n"
"        |\n"
"        |\n"
"         --> z\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:911
msgid "Here is an alternative form of box diagram, showing the same relationship:"
msgstr ""

#. type: group
#: original_texis/lists.texi:927
#, no-wrap
msgid ""
"x1:\n"
" --------------       --------------       --------------\n"
"| car   | cdr  |     | car   | cdr  |     | car   | cdr  |\n"
"|   a   |   o------->|   b   |   o------->|   c   |  nil |\n"
"|       |      |  -->|       |      |     |       |      |\n"
" --------------  |    --------------       --------------\n"
"                 |\n"
"x2:              |\n"
" --------------  |\n"
"| car   | cdr  | |\n"
"|   z   |   o----\n"
"|       |      |\n"
" --------------\n"
msgstr ""

#. type: subsection
#: original_texis/lists.texi:931
#, no-wrap
msgid "Altering the CDR of a List"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:932
#, no-wrap
msgid "replace part of list"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:935
msgid "The lowest-level primitive for modifying a @sc{cdr} is @code{setcdr}:"
msgstr ""

#. type: defun
#: original_texis/lists.texi:936
#, no-wrap
msgid "setcdr cons object"
msgstr ""

#. type: defun
#: original_texis/lists.texi:941
msgid ""
"This function stores @var{object} as the new @sc{cdr} of @var{cons}, "
"replacing its previous @sc{cdr}.  In other words, it changes the @sc{cdr} "
"slot of @var{cons} to refer to @var{object}.  It returns the value "
"@var{object}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:948
msgid ""
"Here is an example of replacing the @sc{cdr} of a list with a different "
"list.  All but the first element of the list are removed in favor of a "
"different sequence of elements.  The first element is unchanged, because it "
"resides in the @sc{car} of the list, and is not reached via the @sc{cdr}."
msgstr ""

#. type: group
#: original_texis/lists.texi:953 original_texis/lists.texi:1066 original_texis/lists.texi:1086
#, no-wrap
msgid ""
"(setq x '(1 2 3))\n"
"     @result{} (1 2 3)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:957
#, no-wrap
msgid ""
"(setcdr x '(4))\n"
"     @result{} (4)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:961
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 4)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:968
msgid ""
"You can delete elements from the middle of a list by altering the @sc{cdr}s "
"of the cons cells in the list.  For example, here we delete the second "
"element, @code{b}, from the list @code{(a b c)}, by changing the @sc{cdr} of "
"the first cons cell:"
msgstr ""

#. type: group
#: original_texis/lists.texi:977
#, no-wrap
msgid ""
"(setq x1 '(a b c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cdr (cdr x1)))\n"
"     @result{} (c)\n"
"x1\n"
"     @result{} (a c)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:981
msgid "Here is the result in box notation:"
msgstr ""

#. type: group
#: original_texis/lists.texi:991
#, no-wrap
msgid ""
"                   --------------------\n"
"                  |                    |\n"
" --------------   |   --------------   |    --------------\n"
"| car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |\n"
"|   a   |   o-----   |   b   |   o-------->|   c   |  nil |\n"
"|       |      |     |       |      |      |       |      |\n"
" --------------       --------------        --------------\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:998
msgid ""
"The second cons cell, which previously held the element @code{b}, still "
"exists and its @sc{car} is still @code{b}, but it no longer forms part of "
"this list."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1000
msgid "It is equally easy to insert a new element by changing @sc{cdr}s:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1009
#, no-wrap
msgid ""
"(setq x1 '(a b c))\n"
"     @result{} (a b c)\n"
"(setcdr x1 (cons 'd (cdr x1)))\n"
"     @result{} (d b c)\n"
"x1\n"
"     @result{} (a d b c)\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1013
msgid "Here is this result in box notation:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1029
#, no-wrap
msgid ""
" --------------        -------------       -------------\n"
"| car  | cdr   |      | car  | cdr  |     | car  | cdr  |\n"
"|   a  |   o   |   -->|   b  |   o------->|   c  |  nil |\n"
"|      |   |   |  |   |      |      |     |      |      |\n"
" --------- | --   |    -------------       -------------\n"
"           |      |\n"
"     -----         --------\n"
"    |                      |\n"
"    |    ---------------   |\n"
"    |   | car   | cdr   |  |\n"
"     -->|   d   |   o------\n"
"        |       |       |\n"
"         ---------------\n"
msgstr ""

#. type: subsection
#: original_texis/lists.texi:1033
#, no-wrap
msgid "Functions that Rearrange Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1034
#, no-wrap
msgid "rearrangement of lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1035
#, no-wrap
msgid "reordering, of elements in lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1036
#, no-wrap
msgid "modification of lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1043
msgid ""
"Here are some functions that rearrange lists destructively by modifying the "
"@sc{cdr}s of their component cons cells.  These functions are destructive "
"because they chew up the original lists passed to them as arguments, "
"relinking their cons cells to form a new list that is the returned value."
msgstr ""

#. type: ifnottex
#: original_texis/lists.texi:1047
msgid ""
"See @code{delq}, in @ref{Sets And Lists}, for another function that modifies "
"cons cells."
msgstr ""

#. type: iftex
#: original_texis/lists.texi:1051
msgid ""
"The function @code{delq} in the following section is another example of "
"destructive list manipulation."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1053
#, no-wrap
msgid "nconc &rest lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1054
#, no-wrap
msgid "concatenating lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1055
#, no-wrap
msgid "joining lists"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1061
msgid ""
"This function returns a list containing all the elements of @var{lists}.  "
"Unlike @code{append} (@pxref{Building Lists}), the @var{lists} are "
"@emph{not} copied.  Instead, the last @sc{cdr} of each of the @var{lists} is "
"changed to refer to the following list.  The last of the @var{lists} is not "
"altered.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1070
#, no-wrap
msgid ""
"(nconc x '(4 5))\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1074
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 2 3 4 5)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1081
msgid ""
"Since the last argument of @code{nconc} is not itself modified, it is "
"reasonable to use a constant list, such as @code{'(4 5)}, as in the above "
"example.  For the same reason, the last argument need not be a list:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1090
#, no-wrap
msgid ""
"(nconc x 'z)\n"
"     @result{} (1 2 3 . z)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1094
#, no-wrap
msgid ""
"x\n"
"     @result{} (1 2 3 . z)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1098
msgid "However, the other arguments (all but the last) must be lists."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1102
msgid ""
"A common pitfall is to use a quoted constant list as a non-last argument to "
"@code{nconc}.  If you do this, your program will change each time you run "
"it! Here is what happens:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1107
#, no-wrap
msgid ""
"(defun add-foo (x)            ; @r{We want this function to add}\n"
"  (nconc '(foo) x))           ;   @r{@code{foo} to the front of its arg.}\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1112
#, no-wrap
msgid ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc (quote (foo)) x))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1117
#, no-wrap
msgid ""
"(setq xx (add-foo '(1 2)))    ; @r{It seems to work.}\n"
"     @result{} (foo 1 2)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1121
#, no-wrap
msgid ""
"(setq xy (add-foo '(3 4)))    ; @r{What happened?}\n"
"     @result{} (foo 1 2 3 4)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1125
#, no-wrap
msgid ""
"(eq xx xy)\n"
"     @result{} t\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1130
#, no-wrap
msgid ""
"(symbol-function 'add-foo)\n"
"     @result{} (lambda (x) (nconc (quote (foo 1 2 3 4) x)))\n"
msgstr ""

#. type: section
#: original_texis/lists.texi:1135
#, no-wrap
msgid "Using Lists as Sets"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1136
#, no-wrap
msgid "lists as sets"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1137
#, no-wrap
msgid "sets"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1146
msgid ""
"A list can represent an unordered mathematical set---simply consider a value "
"an element of a set if it appears in the list, and ignore the order of the "
"list.  To form the union of two sets, use @code{append} (as long as you "
"don't mind having duplicate elements).  You can remove @code{equal} "
"duplicates using @code{delete-dups}.  Other useful functions for sets "
"include @code{memq} and @code{delq}, and their @code{equal} versions, "
"@code{member} and @code{delete}."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1147
#, no-wrap
msgid "CL note---lack @code{union}, @code{intersection}"
msgstr ""

#. type: quotation
#: original_texis/lists.texi:1154
msgid ""
"@b{Common Lisp note:} Common Lisp has functions @code{union} (which avoids "
"duplicate elements) and @code{intersection} for set operations.  Although "
"standard GNU Emacs Lisp does not have them, the @file{cl-lib} library "
"provides versions.  @xref{Lists as Sets,,, cl, Common Lisp Extensions}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1156
#, no-wrap
msgid "memq object list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1157
#, no-wrap
msgid "membership in a list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1163
msgid ""
"This function tests to see whether @var{object} is a member of @var{list}.  "
"If it is, @code{memq} returns a list starting with the first occurrence of "
"@var{object}.  Otherwise, it returns @code{nil}.  The letter @samp{q} in "
"@code{memq} says that it uses @code{eq} to compare @var{object} against the "
"elements of the list.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1168
#, no-wrap
msgid ""
"(memq 'b '(a b c b a))\n"
"     @result{} (b c b a)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1172 original_texis/lists.texi:1314
#, no-wrap
msgid ""
"(memq '(2) '((1) (2)))    ; @r{@code{(2)} and @code{(2)} are not "
"@code{eq}.}\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1176
#, no-wrap
msgid "delq object list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1177
#, no-wrap
msgid "deleting list elements"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1183
msgid ""
"This function destructively removes all elements @code{eq} to @var{object} "
"from @var{list}, and returns the resulting list.  The letter @samp{q} in "
"@code{delq} says that it uses @code{eq} to compare @var{object} against the "
"elements of the list, like @code{memq} and @code{remq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1187
msgid ""
"Typically, when you invoke @code{delq}, you should use the return value by "
"assigning it to the variable which held the original list.  The reason for "
"this is explained below."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1192
msgid ""
"The @code{delq} function deletes elements from the front of the list by "
"simply advancing down the list, and returning a sublist that starts after "
"those elements.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1196
#, no-wrap
msgid "(delq 'a '(a b c)) @equiv{} (cdr '(a b c))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1202
msgid ""
"When an element to be deleted appears in the middle of the list, removing it "
"involves changing the @sc{cdr}s (@pxref{Setcdr})."
msgstr ""

#. type: group
#: original_texis/lists.texi:1207
#, no-wrap
msgid ""
"(setq sample-list '(a b c (4)))\n"
"     @result{} (a b c (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1211
#, no-wrap
msgid ""
"(delq 'a sample-list)\n"
"     @result{} (b c (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1215
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b c (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1219
#, no-wrap
msgid ""
"(delq 'c sample-list)\n"
"     @result{} (a b (4))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1223
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b (4))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1233
msgid ""
"Note that @code{(delq 'c sample-list)} modifies @code{sample-list} to splice "
"out the third element, but @code{(delq 'a sample-list)} does not splice "
"anything---it just returns a shorter list.  Don't assume that a variable "
"which formerly held the argument @var{list} now has fewer elements, or that "
"it still holds the original list! Instead, save the result of @code{delq} "
"and use that.  Most often we store the result back into the variable that "
"held the original list:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1236
#, no-wrap
msgid "(setq flowers (delq 'rose flowers))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1240
msgid ""
"In the following example, the @code{(4)} that @code{delq} attempts to match "
"and the @code{(4)} in the @code{sample-list} are not @code{eq}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1245
#, no-wrap
msgid ""
"(delq '(4) sample-list)\n"
"     @result{} (a c (4))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1250
msgid ""
"If you want to delete elements that are @code{equal} to a given value, use "
"@code{delete} (see below)."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1251
#, no-wrap
msgid "remq object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1256
msgid ""
"This function returns a copy of @var{list}, with all elements removed which "
"are @code{eq} to @var{object}.  The letter @samp{q} in @code{remq} says that "
"it uses @code{eq} to compare @var{object} against the elements of "
"@code{list}."
msgstr ""

#. type: group
#: original_texis/lists.texi:1261
#, no-wrap
msgid ""
"(setq sample-list '(a b c a b c))\n"
"     @result{} (a b c a b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1265
#, no-wrap
msgid ""
"(remq 'a sample-list)\n"
"     @result{} (b c b c)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1269
#, no-wrap
msgid ""
"sample-list\n"
"     @result{} (a b c a b c)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1273
#, no-wrap
msgid "memql object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1279
msgid ""
"The function @code{memql} tests to see whether @var{object} is a member of "
"@var{list}, comparing members with @var{object} using @code{eql}, so "
"floating-point elements are compared by value.  If @var{object} is a member, "
"@code{memql} returns a list starting with its first occurrence in "
"@var{list}.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1281 original_texis/lists.texi:1305
msgid "Compare this with @code{memq}:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1286
#, no-wrap
msgid ""
"(memql 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2} and @code{1.2} are "
"@code{eql}.}\n"
"     @result{} (1.2 1.3)\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1290
#, no-wrap
msgid ""
"(memq 1.2 '(1.1 1.2 1.3))  ; @r{@code{1.2} and @code{1.2} are not "
"@code{eq}.}\n"
"     @result{} nil\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1297
msgid ""
"The following three functions are like @code{memq}, @code{delq} and "
"@code{remq}, but use @code{equal} rather than @code{eq} to compare "
"elements.  @xref{Equality Predicates}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1298
#, no-wrap
msgid "member object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1303
msgid ""
"The function @code{member} tests to see whether @var{object} is a member of "
"@var{list}, comparing members with @var{object} using @code{equal}.  If "
"@var{object} is a member, @code{member} returns a list starting with its "
"first occurrence in @var{list}.  Otherwise, it returns @code{nil}."
msgstr ""

#. type: group
#: original_texis/lists.texi:1310
#, no-wrap
msgid ""
"(member '(2) '((1) (2)))  ; @r{@code{(2)} and @code{(2)} are "
"@code{equal}.}\n"
"     @result{} ((2))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1319
#, no-wrap
msgid ""
";; @r{Two strings with the same contents are @code{equal}.}\n"
"(member \"foo\" '(\"foo\" \"bar\"))\n"
"     @result{} (\"foo\" \"bar\")\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1323
#, no-wrap
msgid "delete object sequence"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1326
msgid ""
"This function removes all elements @code{equal} to @var{object} from "
"@var{sequence}, and returns the resulting sequence."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1333
msgid ""
"If @var{sequence} is a list, @code{delete} is to @code{delq} as "
"@code{member} is to @code{memq}: it uses @code{equal} to compare elements "
"with @var{object}, like @code{member}; when it finds an element that "
"matches, it cuts the element out just as @code{delq} would.  As with "
"@code{delq}, you should typically use the return value by assigning it to "
"the variable which held the original list."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1337
msgid ""
"If @code{sequence} is a vector or string, @code{delete} returns a copy of "
"@code{sequence} with all elements @code{equal} to @code{object} removed."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1339 original_texis/lists.texi:1581
msgid "For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1349
#, no-wrap
msgid ""
"(setq l '((2) (1) (2)))\n"
"(delete '(2) l)\n"
"     @result{} ((1))\n"
"l\n"
"     @result{} ((2) (1))\n"
";; @r{If you want to change @code{l} reliably,}\n"
";; @r{write @code{(setq l (delete '(2) l))}.}\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1358
#, no-wrap
msgid ""
"(setq l '((2) (1) (2)))\n"
"(delete '(1) l)\n"
"     @result{} ((2) (2))\n"
"l\n"
"     @result{} ((2) (2))\n"
";; @r{In this case, it makes no difference whether you set @code{l},}\n"
";; @r{but you should do so for the sake of the other case.}\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1362
#, no-wrap
msgid ""
"(delete '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1366
#, no-wrap
msgid "remove object sequence"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1370
msgid ""
"This function is the non-destructive counterpart of @code{delete}.  It "
"returns a copy of @code{sequence}, a list, vector, or string, with elements "
"@code{equal} to @code{object} removed.  For example:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1375
#, no-wrap
msgid ""
"(remove '(2) '((2) (1) (2)))\n"
"     @result{} ((1))\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1379
#, no-wrap
msgid ""
"(remove '(2) [(2) (1) (2)])\n"
"     @result{} [(1)]\n"
msgstr ""

#. type: quotation
#: original_texis/lists.texi:1388
msgid ""
"@b{Common Lisp note:} The functions @code{member}, @code{delete} and "
"@code{remove} in GNU Emacs Lisp are derived from Maclisp, not Common Lisp.  "
"The Common Lisp versions do not use @code{equal} to compare elements."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1390
#, no-wrap
msgid "member-ignore-case object list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1396
msgid ""
"This function is like @code{member}, except that @var{object} should be a "
"string and that it ignores differences in letter-case and text "
"representation: upper-case and lower-case letters are treated as equal, and "
"unibyte strings are converted to multibyte prior to comparison."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1398
#, no-wrap
msgid "delete-dups list"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1403
msgid ""
"This function destructively removes all @code{equal} duplicates from "
"@var{list}, stores the result in @var{list} and returns it.  Of several "
"@code{equal} occurrences of an element in @var{list}, @code{delete-dups} "
"keeps the first one."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1408
msgid ""
"See also the function @code{add-to-list}, in @ref{List Variables}, for a way "
"to add an element to a list stored in a variable and used as a set."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1411
#, no-wrap
msgid "association list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1412
#, no-wrap
msgid "alist"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1421
msgid ""
"An @dfn{association list}, or @dfn{alist} for short, records a mapping from "
"keys to values.  It is a list of cons cells called @dfn{associations}: the "
"@sc{car} of each cons cell is the @dfn{key}, and the @sc{cdr} is the "
"@dfn{associated value}.@footnote{This usage of ``key'' is not related to the "
"term ``key sequence''; it means a value used to look up an item in a table.  "
"In this case, the table is the alist, and the alist associations are the "
"items.}"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1425
msgid ""
"Here is an example of an alist.  The key @code{pine} is associated with the "
"value @code{cones}; the key @code{oak} is associated with @code{acorns}; and "
"the key @code{maple} is associated with @code{seeds}."
msgstr ""

#. type: group
#: original_texis/lists.texi:1431
#, no-wrap
msgid ""
"((pine . cones)\n"
" (oak . acorns)\n"
" (maple . seeds))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1439
msgid ""
"Both the values and the keys in an alist may be any Lisp objects.  For "
"example, in the following alist, the symbol @code{a} is associated with the "
"number @code{1}, and the string @code{\"b\"} is associated with the "
"@emph{list} @code{(2 3)}, which is the @sc{cdr} of the alist element:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1442
#, no-wrap
msgid "((a . 1) (\"b\" 2 3))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1447
msgid ""
"Sometimes it is better to design an alist to store the associated value in "
"the @sc{car} of the @sc{cdr} of the element.  Here is an example of such an "
"alist:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1450
#, no-wrap
msgid "((rose red) (lily white) (buttercup yellow))\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1460
msgid ""
"Here we regard @code{red} as the value associated with @code{rose}.  One "
"advantage of this kind of alist is that you can store other related "
"information---even a list of other items---in the @sc{cdr} of the @sc{cdr}.  "
"One disadvantage is that you cannot use @code{rassq} (see below) to find the "
"element containing a given value.  When neither of these considerations is "
"important, the choice is a matter of taste, as long as you are consistent "
"about it for any given alist."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1464
msgid ""
"The same alist shown above could be regarded as having the associated value "
"in the @sc{cdr} of the element; the value associated with @code{rose} would "
"be the list @code{(red)}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1470
msgid ""
"Association lists are often used to record information that you might "
"otherwise keep on a stack, since new associations may be added easily to the "
"front of the list.  When searching an association list for an association "
"with a given key, the first one found is returned, if there is more than "
"one."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1475
msgid ""
"In Emacs Lisp, it is @emph{not} an error if an element of an association "
"list is not a cons cell.  The alist search functions simply ignore such "
"elements.  Many other versions of Lisp signal errors in such cases."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1480
msgid ""
"Note that property lists are similar to association lists in several "
"respects.  A property list behaves like an association list in which each "
"key can occur only once.  @xref{Property Lists}, for a comparison of "
"property lists and association lists."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1481
#, no-wrap
msgid "assoc key alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1487
msgid ""
"This function returns the first association for @var{key} in @var{alist}, "
"comparing @var{key} against the alist elements using @code{equal} "
"(@pxref{Equality Predicates}).  It returns @code{nil} if no association in "
"@var{alist} has a @sc{car} @code{equal} to @var{key}.  For example:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1497
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assoc 'oak trees)\n"
"     @result{} (oak . acorns)\n"
"(cdr (assoc 'oak trees))\n"
"     @result{} acorns\n"
"(assoc 'birch trees)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1500
msgid "Here is another example, in which the keys and values are not symbols:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1506
#, no-wrap
msgid ""
"(setq needles-per-cluster\n"
"      '((2 \"Austrian Pine\" \"Red Pine\")\n"
"        (3 \"Pitch Pine\")\n"
"        (5 \"White Pine\")))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1511
#, no-wrap
msgid ""
"(cdr (assoc 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"
"(cdr (assoc 2 needles-per-cluster))\n"
"     @result{} (\"Austrian Pine\" \"Red Pine\")\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1517
msgid ""
"The function @code{assoc-string} is much like @code{assoc} except that it "
"ignores certain differences between strings.  @xref{Text Comparison}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1518
#, no-wrap
msgid "rassoc value alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1522
msgid ""
"This function returns the first association with value @var{value} in "
"@var{alist}.  It returns @code{nil} if no association in @var{alist} has a "
"@sc{cdr} @code{equal} to @var{value}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1526
msgid ""
"@code{rassoc} is like @code{assoc} except that it compares the @sc{cdr} of "
"each @var{alist} association instead of the @sc{car}.  You can think of this "
"as reverse @code{assoc}, finding the key for a given value."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1528
#, no-wrap
msgid "assq key alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1536
msgid ""
"This function is like @code{assoc} in that it returns the first association "
"for @var{key} in @var{alist}, but it makes the comparison using @code{eq} "
"instead of @code{equal}.  @code{assq} returns @code{nil} if no association "
"in @var{alist} has a @sc{car} @code{eq} to @var{key}.  This function is used "
"more often than @code{assoc}, since @code{eq} is faster than @code{equal} "
"and most alists use symbols as keys.  @xref{Equality Predicates}."
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1542
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"     @result{} ((pine . cones) (oak . acorns) (maple . seeds))\n"
"(assq 'pine trees)\n"
"     @result{} (pine . cones)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1546
msgid ""
"On the other hand, @code{assq} is not usually useful in alists where the "
"keys may not be symbols:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1551
#, no-wrap
msgid ""
"(setq leaves\n"
"      '((\"simple leaves\" . oak)\n"
"        (\"compound leaves\" . horsechestnut)))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1556
#, no-wrap
msgid ""
"(assq \"simple leaves\" leaves)\n"
"     @result{} nil\n"
"(assoc \"simple leaves\" leaves)\n"
"     @result{} (\"simple leaves\" . oak)\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1559
#, no-wrap
msgid "alist-get key value &optional default remove"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1564
msgid ""
"This function is like @code{assq}, but instead of returning the entire "
"association for @var{key}, @code{(@var{key} . @var{value})}, it returns just "
"the @var{value}.  If @var{key} is not found in @var{alist} it returns "
"@var{default}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1569
msgid ""
"This is a generalized variable (@pxref{Generalized Variables}) that can be "
"used to change a value with @code{setf}.  When using it to set a value, "
"optional argument @var{remove} non-nil means to remove @var{key} from "
"@var{alist} if the new value is @code{eql} to @var{default}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1571
#, no-wrap
msgid "rassq value alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1575
msgid ""
"This function returns the first association with value @var{value} in "
"@var{alist}.  It returns @code{nil} if no association in @var{alist} has a "
"@sc{cdr} @code{eq} to @var{value}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1579
msgid ""
"@code{rassq} is like @code{assq} except that it compares the @sc{cdr} of "
"each @var{alist} association instead of the @sc{car}.  You can think of this "
"as reverse @code{assq}, finding the key for a given value."
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1584
#, no-wrap
msgid ""
"(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1589
#, no-wrap
msgid ""
"(rassq 'acorns trees)\n"
"     @result{} (oak . acorns)\n"
"(rassq 'spores trees)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1593
msgid ""
"@code{rassq} cannot search for a value stored in the @sc{car} of the "
"@sc{cdr} of an element:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1596
#, no-wrap
msgid ""
"(setq colors '((rose red) (lily white) (buttercup yellow)))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1599
#, no-wrap
msgid ""
"(rassq 'white colors)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1604
msgid ""
"In this case, the @sc{cdr} of the association @code{(lily white)} is not the "
"symbol @code{white}, but rather the list @code{(white)}.  This becomes "
"clearer if the association is written in dotted pair notation:"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1607
#, no-wrap
msgid "(lily white) @equiv{} (lily . (white))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1610
#, no-wrap
msgid "assoc-default key alist &optional test default"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1619
msgid ""
"This function searches @var{alist} for a match for @var{key}.  For each "
"element of @var{alist}, it compares the element (if it is an atom) or the "
"element's @sc{car} (if it is a cons) against @var{key}, by calling "
"@var{test} with two arguments: the element or its @sc{car}, and @var{key}.  "
"The arguments are passed in that order so that you can get useful results "
"using @code{string-match} with an alist that contains regular expressions "
"(@pxref{Regexp Search}).  If @var{test} is omitted or @code{nil}, "
"@code{equal} is used for comparison."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1624
msgid ""
"If an alist element matches @var{key} by this criterion, then "
"@code{assoc-default} returns a value based on this element.  If the element "
"is a cons, then the value is the element's @sc{cdr}.  Otherwise, the return "
"value is @var{default}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1627
msgid ""
"If no alist element matches @var{key}, @code{assoc-default} returns "
"@code{nil}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1629
#, no-wrap
msgid "copy-alist alist"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1630
#, no-wrap
msgid "copying alists"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1634
msgid ""
"This function returns a two-level deep copy of @var{alist}: it creates a new "
"copy of each association, so that you can alter the associations of the new "
"alist without changing the old one."
msgstr ""

#. type: group
#: original_texis/lists.texi:1640
#, no-wrap
msgid ""
"(setq needles-per-cluster\n"
"      '((2 . (\"Austrian Pine\" \"Red Pine\"))\n"
"        (3 . (\"Pitch Pine\"))\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1646
#, no-wrap
msgid ""
"        (5 . (\"White Pine\"))))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1652
#, no-wrap
msgid ""
"(setq copy (copy-alist needles-per-cluster))\n"
"@result{}\n"
"((2 \"Austrian Pine\" \"Red Pine\")\n"
" (3 \"Pitch Pine\")\n"
" (5 \"White Pine\"))\n"
"\n"
msgstr ""

#. type: smallexample
#: original_texis/lists.texi:1661
#, no-wrap
msgid ""
"(eq needles-per-cluster copy)\n"
"     @result{} nil\n"
"(equal needles-per-cluster copy)\n"
"     @result{} t\n"
"(eq (car needles-per-cluster) (car copy))\n"
"     @result{} nil\n"
"(cdr (car (cdr needles-per-cluster)))\n"
"     @result{} (\"Pitch Pine\")\n"
msgstr ""

#. type: group
#: original_texis/lists.texi:1665
#, no-wrap
msgid ""
"(eq (cdr (car (cdr needles-per-cluster)))\n"
"    (cdr (car (cdr copy))))\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1670
msgid ""
"This example shows how @code{copy-alist} makes it possible to change the "
"associations of one copy without affecting the other:"
msgstr ""

#. type: group
#: original_texis/lists.texi:1676
#, no-wrap
msgid ""
"(setcdr (assq 3 copy) '(\"Martian Vacuum Pine\"))\n"
"(cdr (assq 3 needles-per-cluster))\n"
"     @result{} (\"Pitch Pine\")\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1680
#, no-wrap
msgid "assq-delete-all key alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1687
msgid ""
"This function deletes from @var{alist} all the elements whose @sc{car} is "
"@code{eq} to @var{key}, much as if you used @code{delq} to delete each such "
"element one by one.  It returns the shortened alist, and often modifies the "
"original list structure of @var{alist}.  For correct results, use the return "
"value of @code{assq-delete-all} rather than looking at the saved value of "
"@var{alist}."
msgstr ""

#. type: example
#: original_texis/lists.texi:1695
#, no-wrap
msgid ""
"(setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))\n"
"     @result{} ((foo 1) (bar 2) (foo 3) (lose 4))\n"
"(assq-delete-all 'foo alist)\n"
"     @result{} ((bar 2) (lose 4))\n"
"alist\n"
"     @result{} ((foo 1) (bar 2) (lose 4))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1698
#, no-wrap
msgid "rassq-delete-all value alist"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1705
msgid ""
"This function deletes from @var{alist} all the elements whose @sc{cdr} is "
"@code{eq} to @var{value}.  It returns the shortened alist, and often "
"modifies the original list structure of @var{alist}.  "
"@code{rassq-delete-all} is like @code{assq-delete-all} except that it "
"compares the @sc{cdr} of each @var{alist} association instead of the "
"@sc{car}."
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1709
#, no-wrap
msgid "property list"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1710
#, no-wrap
msgid "plist"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1716
msgid ""
"A @dfn{property list} (@dfn{plist} for short) is a list of paired elements.  "
"Each of the pairs associates a property name (usually a symbol) with a "
"property or value.  Here is an example of a property list:"
msgstr ""

#. type: example
#: original_texis/lists.texi:1719
#, no-wrap
msgid "(pine cones numbers (1 2 3) color \"blue\")\n"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1726
msgid ""
"This property list associates @code{pine} with @code{cones}, @code{numbers} "
"with @code{(1 2 3)}, and @code{color} with @code{\"blue\"}.  The property "
"names and values can be any Lisp objects, but the names are usually symbols "
"(as they are in this example)."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1732
msgid ""
"Property lists are used in several contexts.  For instance, the function "
"@code{put-text-property} takes an argument which is a property list, "
"specifying text properties and associated values which are to be applied to "
"text in a string or buffer.  @xref{Text Properties}."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1737
msgid ""
"Another prominent use of property lists is for storing symbol properties.  "
"Every symbol possesses a list of properties, used to record miscellaneous "
"information about the symbol; these properties are stored in the form of a "
"property list.  @xref{Symbol Properties}."
msgstr ""

#. type: node
#: original_texis/lists.texi:1742 original_texis/lists.texi:1744
#, no-wrap
msgid "Plists and Alists"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:1742
msgid "Comparison of the advantages of property lists and association lists."
msgstr ""

#. type: node
#: original_texis/lists.texi:1742 original_texis/lists.texi:1779
#, no-wrap
msgid "Plist Access"
msgstr ""

#. type: menuentry
#: original_texis/lists.texi:1742
msgid "Accessing property lists stored elsewhere."
msgstr ""

#. type: subsection
#: original_texis/lists.texi:1745
#, no-wrap
msgid "Property Lists and Association Lists"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1746
#, no-wrap
msgid "plist vs. alist"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1747
#, no-wrap
msgid "alist vs. plist"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1749
#, no-wrap
msgid "property lists vs association lists"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1754
msgid ""
"Association lists (@pxref{Association Lists}) are very similar to property "
"lists.  In contrast to association lists, the order of the pairs in the "
"property list is not significant, since the property names must be distinct."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1767
msgid ""
"Property lists are better than association lists for attaching information "
"to various Lisp function names or variables.  If your program keeps all such "
"information in one association list, it will typically need to search that "
"entire list each time it checks for an association for a particular Lisp "
"function name or variable, which could be slow.  By contrast, if you keep "
"the same information in the property lists of the function names or "
"variables themselves, each search will scan only the length of one property "
"list, which is usually short.  This is why the documentation for a variable "
"is recorded in a property named @code{variable-documentation}.  The byte "
"compiler likewise uses properties to record those functions needing special "
"treatment."
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1778
msgid ""
"However, association lists have their own advantages.  Depending on your "
"application, it may be faster to add an association to the front of an "
"association list than to update a property.  All properties for a symbol are "
"stored in the same property list, so there is a possibility of a conflict "
"between different uses of a property name.  (For this reason, it is a good "
"idea to choose property names that are probably unique, such as by beginning "
"the property name with the program's usual name-prefix for variables and "
"functions.)  An association list may be used like a stack where associations "
"are pushed on the front of the list and later discarded; this is not "
"possible with a property list."
msgstr ""

#. type: subsection
#: original_texis/lists.texi:1780
#, no-wrap
msgid "Property Lists Outside Symbols"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1781
#, no-wrap
msgid "plist access"
msgstr ""

#. type: cindex
#: original_texis/lists.texi:1782
#, no-wrap
msgid "accessing plist properties"
msgstr ""

#. type: Plain text
#: original_texis/lists.texi:1786
msgid ""
"The following functions can be used to manipulate property lists.  They all "
"compare property names using @code{eq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1787
#, no-wrap
msgid "plist-get plist property"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1792
msgid ""
"This returns the value of the @var{property} property stored in the property "
"list @var{plist}.  It accepts a malformed @var{plist} argument.  If "
"@var{property} is not found in the @var{plist}, it returns @code{nil}.  For "
"example,"
msgstr ""

#. type: example
#: original_texis/lists.texi:1802
#, no-wrap
msgid ""
"(plist-get '(foo 4) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'foo)\n"
"     @result{} 4\n"
"(plist-get '(foo 4 bad) 'bad)\n"
"     @result{} nil\n"
"(plist-get '(foo 4 bad) 'bar)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1805
#, no-wrap
msgid "plist-put plist property value"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1811
msgid ""
"This stores @var{value} as the value of the @var{property} property in the "
"property list @var{plist}.  It may modify @var{plist} destructively, or it "
"may construct a new list structure without altering the old.  The function "
"returns the modified property list, so you can store that back in the place "
"where you got @var{plist}.  For example,"
msgstr ""

#. type: example
#: original_texis/lists.texi:1819
#, no-wrap
msgid ""
"(setq my-plist '(bar t foo 4))\n"
"     @result{} (bar t foo 4)\n"
"(setq my-plist (plist-put my-plist 'foo 69))\n"
"     @result{} (bar t foo 69)\n"
"(setq my-plist (plist-put my-plist 'quux '(a)))\n"
"     @result{} (bar t foo 69 quux (a))\n"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1822
#, no-wrap
msgid "lax-plist-get plist property"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1825
msgid ""
"Like @code{plist-get} except that it compares properties using @code{equal} "
"instead of @code{eq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1827
#, no-wrap
msgid "lax-plist-put plist property value"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1830
msgid ""
"Like @code{plist-put} except that it compares properties using @code{equal} "
"instead of @code{eq}."
msgstr ""

#. type: defun
#: original_texis/lists.texi:1832
#, no-wrap
msgid "plist-member plist property"
msgstr ""

#. type: defun
#: original_texis/lists.texi:1838
msgid ""
"This returns non-@code{nil} if @var{plist} contains the given "
"@var{property}.  Unlike @code{plist-get}, this allows you to distinguish "
"between a missing property and a property with the value @code{nil}.  The "
"value is actually the tail of @var{plist} whose @code{car} is "
"@var{property}."
msgstr ""
