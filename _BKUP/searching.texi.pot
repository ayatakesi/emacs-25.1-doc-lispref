# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-10-14 22:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: chapter
#: original_texis/searching.texi:6 original_texis/searching.texi:7
#, no-wrap
msgid "Searching and Matching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:8
#, no-wrap
msgid "searching"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:15
msgid ""
"GNU Emacs provides two ways to search through a buffer for specified text: "
"exact string searches and regular expression searches.  After a regular "
"expression search, you can examine the @dfn{match data} to determine which "
"text matched the whole regular expression or various portions of it."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:32
#, no-wrap
msgid "String Search"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Search for an exact match."
msgstr ""

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:191 original_texis/searching.texi:192
#, no-wrap
msgid "Searching and Case"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Case-independent or case-significant searching."
msgstr ""

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:234 original_texis/searching.texi:235
#, no-wrap
msgid "Regular Expressions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Describing classes of strings."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1009
#, no-wrap
msgid "Regexp Search"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching for a match for a regexp."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1239
#, no-wrap
msgid "POSIX Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Searching POSIX-style for the longest match."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1284
#, no-wrap
msgid "Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Finding out which part of the text matched, after a string or regexp search."
msgstr ""

#. type: section
#: original_texis/searching.texi:26 original_texis/searching.texi:1694 original_texis/searching.texi:1695
#, no-wrap
msgid "Search and Replace"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Commands that loop, searching and replacing."
msgstr ""

#. type: node
#: original_texis/searching.texi:26 original_texis/searching.texi:1898
#, no-wrap
msgid "Standard Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:26
msgid "Useful regexps for finding sentences, pages,..."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:31
msgid ""
"The @samp{skip-chars@dots{}} functions also perform a kind of searching.  "
"@xref{Skipping Characters}.  To search for changes in character properties, "
"see @ref{Property Search}."
msgstr ""

#. type: section
#: original_texis/searching.texi:33
#, no-wrap
msgid "Searching for Strings"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:34
#, no-wrap
msgid "string search"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:42
msgid ""
"These are the primitive functions for searching through the text in a "
"buffer.  They are meant for use in programs, but you may call them "
"interactively.  If you do so, they prompt for the search string; the "
"arguments @var{limit} and @var{noerror} are @code{nil}, and @var{repeat} is "
"1.  For more details on interactive searching, @pxref{Search,, Searching and "
"Replacement, emacs, The GNU Emacs Manual}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:46
msgid ""
"These search functions convert the search string to multibyte if the buffer "
"is multibyte; they convert the search string to unibyte if the buffer is "
"unibyte.  @xref{Text Representations}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:47
#, no-wrap
msgid "Command search-forward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:52
msgid ""
"This function searches forward from point for an exact match for "
"@var{string}.  If successful, it sets point to the end of the occurrence "
"found, and returns the new value of point.  If no match is found, the value "
"and side effects depend on @var{noerror} (see below)."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:56
msgid ""
"In the following example, point is initially at the beginning of the line.  "
"Then @code{(search-forward \"fox\")} moves point after the last letter of "
"@samp{fox}:"
msgstr ""

#. type: group
#: original_texis/searching.texi:62
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}The quick brown fox jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:67
#, no-wrap
msgid ""
"(search-forward \"fox\")\n"
"     @result{} 20\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:71
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"The quick brown fox@point{} jumped over the lazy dog.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:78
msgid ""
"The argument @var{limit} specifies the bound to the search, and should be a "
"position in the current buffer.  No match extending after that position is "
"accepted.  If @var{limit} is omitted or @code{nil}, it defaults to the end "
"of the accessible portion of the buffer."
msgstr ""

#. type: kindex
#: original_texis/searching.texi:79
#, no-wrap
msgid "search-failed"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:88
msgid ""
"What happens when the search fails depends on the value of @var{noerror}.  "
"If @var{noerror} is @code{nil}, a @code{search-failed} error is signaled.  "
"If @var{noerror} is @code{t}, @code{search-forward} returns @code{nil} and "
"does nothing.  If @var{noerror} is neither @code{nil} nor @code{t}, then "
"@code{search-forward} moves point to the upper bound and returns @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:97 original_texis/searching.texi:1055
msgid ""
"The argument @var{noerror} only affects valid searches which fail to find a "
"match.  Invalid arguments cause errors regardless of @var{noerror}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:106 original_texis/searching.texi:1064
msgid ""
"If @var{count} is a positive number @var{n}, the search is done @var{n} "
"times; each successive search starts at the end of the previous match.  If "
"all these successive searches succeed, the function call succeeds, moving "
"point and returning its new value.  Otherwise the function call fails, with "
"results depending on the value of @var{noerror}, as described above.  If "
"@var{count} is a negative number -@var{n}, the search is done @var{n} times "
"in the opposite (backward) direction."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:108
#, no-wrap
msgid "Command search-backward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:113
msgid ""
"This function searches backward from point for @var{string}.  It is like "
"@code{search-forward}, except that it searches backwards rather than "
"forwards.  Backward searches leave point at the beginning of the match."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:115
#, no-wrap
msgid "Command word-search-forward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:119
msgid ""
"This function searches forward from point for a word match for "
"@var{string}.  If it finds a match, it sets point to the end of the match "
"found, and returns the new value of point."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:126
msgid ""
"Word matching regards @var{string} as a sequence of words, disregarding "
"punctuation that separates them.  It searches the buffer for the same "
"sequence of words.  Each word must be distinct in the buffer (searching for "
"the word @samp{ball} does not match the word @samp{balls}), but the details "
"of punctuation and spacing are ignored (searching for @samp{ball boy} does "
"match @samp{ball.  Boy!})."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:129
msgid ""
"In this example, point is initially at the beginning of the buffer; the "
"search leaves it between the @samp{y} and the @samp{!}."
msgstr ""

#. type: group
#: original_texis/searching.texi:136
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"@point{}He said \"Please!  Find\n"
"the ball boy!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:141
#, no-wrap
msgid ""
"(word-search-forward \"Please find the ball, boy.\")\n"
"     @result{} 39\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:146
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"He said \"Please!  Find\n"
"the ball boy@point{}!\"\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:152
msgid ""
"If @var{limit} is non-@code{nil}, it must be a position in the current "
"buffer; it specifies the upper bound to the search.  The match found must "
"not extend after that position."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:158
msgid ""
"If @var{noerror} is @code{nil}, then @code{word-search-forward} signals an "
"error if the search fails.  If @var{noerror} is @code{t}, then it returns "
"@code{nil} instead of signaling an error.  If @var{noerror} is neither "
"@code{nil} nor @code{t}, it moves point to @var{limit} (or the end of the "
"accessible portion of the buffer) and returns @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:163
msgid ""
"If @var{count} is a positive number, it specifies how many successive "
"occurrences to search for.  Point is positioned at the end of the last "
"match.  If @var{count} is a negative number, the search is backward and "
"point is positioned at the beginning of the last match."
msgstr ""

#. type: findex
#: original_texis/searching.texi:164
#, no-wrap
msgid "word-search-regexp"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:168
msgid ""
"Internally, @code{word-search-forward} and related functions use the "
"function @code{word-search-regexp} to convert @var{string} to a regular "
"expression that ignores punctuation."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:170
#, no-wrap
msgid "Command word-search-forward-lax string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:176
msgid ""
"This command is identical to @code{word-search-forward}, except that the "
"beginning or the end of @var{string} need not match a word boundary, unless "
"@var{string} begins or ends in whitespace.  For instance, searching for "
"@samp{ball boy} matches @samp{ball boyee}, but does not match @samp{balls "
"boy}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:178
#, no-wrap
msgid "Command word-search-backward string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:183
msgid ""
"This function searches backward from point for a word match to "
"@var{string}.  This function is just like @code{word-search-forward} except "
"that it searches backward and normally leaves point at the beginning of the "
"match."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:185
#, no-wrap
msgid "Command word-search-backward-lax string &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:189
msgid ""
"This command is identical to @code{word-search-backward}, except that the "
"beginning or the end of @var{string} need not match a word boundary, unless "
"@var{string} begins or ends in whitespace."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:193
#, no-wrap
msgid "searching and case"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:200
msgid ""
"By default, searches in Emacs ignore the case of the text they are searching "
"through; if you specify searching for @samp{FOO}, then @samp{Foo} or "
"@samp{foo} is also considered a match.  This applies to regular expressions, "
"too; thus, @samp{[aB]} would match @samp{a} or @samp{A} or @samp{b} or "
"@samp{B}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:208
msgid ""
"If you do not want this feature, set the variable @code{case-fold-search} to "
"@code{nil}.  Then all letters must match exactly, including case.  This is a "
"buffer-local variable; altering the variable affects only the current "
"buffer.  (@xref{Intro to Buffer-Local}.)  Alternatively, you may change the "
"default value.  In Lisp code, you will more typically use @code{let} to bind "
"@code{case-fold-search} to the desired value."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:216
msgid ""
"Note that the user-level incremental search feature handles case "
"distinctions differently.  When the search string contains only lower case "
"letters, the search ignores case, but when the search string contains one or "
"more upper case letters, the search becomes case-sensitive.  But this has "
"nothing to do with the searching functions used in Lisp code.  "
"@xref{Incremental Search,,, emacs, The GNU Emacs Manual}."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:217
#, no-wrap
msgid "case-fold-search"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:221
msgid ""
"This buffer-local variable determines whether searches should ignore case.  "
"If the variable is @code{nil} they do not ignore case; otherwise (and by "
"default) they do ignore case."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:223
#, no-wrap
msgid "case-replace"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:229
msgid ""
"This variable determines whether the higher-level replacement functions "
"should preserve case.  If the variable is @code{nil}, that means to use the "
"replacement text verbatim.  A non-@code{nil} value means to convert the case "
"of the replacement text according to the text being replaced."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:232
msgid ""
"This variable is used by passing it as an argument to the function "
"@code{replace-match}.  @xref{Replacing Match}."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:236
#, no-wrap
msgid "regular expression"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:237
#, no-wrap
msgid "regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:243
msgid ""
"A @dfn{regular expression}, or @dfn{regexp} for short, is a pattern that "
"denotes a (possibly infinite) set of strings.  Searching for matches for a "
"regexp is a very powerful operation.  This section explains how to write "
"regexps; the following section says how to search for them."
msgstr ""

#. type: findex
#: original_texis/searching.texi:244
#, no-wrap
msgid "re-builder"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:245
#, no-wrap
msgid "regular expressions, developing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:253
msgid ""
"For interactive development of regular expressions, you can use the @kbd{M-x "
"re-builder} command.  It provides a convenient interface for creating "
"regular expressions, by giving immediate visual feedback in a separate "
"buffer.  As you edit the regexp, all its matches in the target buffer are "
"highlighted.  Each parenthesized sub-expression of the regexp is shown in a "
"distinct face, which makes it easier to verify even very complex regexps."
msgstr ""

#. type: node
#: original_texis/searching.texi:258 original_texis/searching.texi:260
#, no-wrap
msgid "Syntax of Regexps"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:258
msgid "Rules for writing regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:258 original_texis/searching.texi:844
#, no-wrap
msgid "Regexp Example"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:258
msgid "Illustrates regular expression syntax."
msgstr ""

#. type: node
#: original_texis/searching.texi:258 original_texis/searching.texi:904
#, no-wrap
msgid "Regexp Functions"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:258
msgid "Functions for operating on regular expressions."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:261
#, no-wrap
msgid "Syntax of Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:262
#, no-wrap
msgid "regexp syntax"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:263
#, no-wrap
msgid "syntax of regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:276
msgid ""
"Regular expressions have a syntax in which a few characters are special "
"constructs and the rest are @dfn{ordinary}.  An ordinary character is a "
"simple regular expression that matches that character and nothing else.  The "
"special characters are @samp{.}, @samp{*}, @samp{+}, @samp{?}, @samp{[}, "
"@samp{^}, @samp{$}, and @samp{\\}; no new special characters will be defined "
"in the future.  The character @samp{]} is special if it ends a character "
"alternative (see later).  The character @samp{-} is special inside a "
"character alternative.  A @samp{[:} and balancing @samp{:]} enclose a "
"character class inside a character alternative.  Any other character "
"appearing in a regular expression is ordinary, unless a @samp{\\} precedes "
"it."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:282
msgid ""
"For example, @samp{f} is not a special character, so it is ordinary, and "
"therefore @samp{f} is a regular expression that matches the string @samp{f} "
"and no other string.  (It does @emph{not} match the string @samp{fg}, but it "
"does match a @emph{part} of that string.)  Likewise, @samp{o} is a regular "
"expression that matches only @samp{o}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:287
msgid ""
"Any two regular expressions @var{a} and @var{b} can be concatenated.  The "
"result is a regular expression that matches a string if @var{a} matches some "
"amount of the beginning of that string and @var{b} matches the rest of the "
"string."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:292
msgid ""
"As a simple example, we can concatenate the regular expressions @samp{f} and "
"@samp{o} to get the regular expression @samp{fo}, which matches only the "
"string @samp{fo}.  Still trivial.  To do something more powerful, you need "
"to use one of the special regular expression constructs."
msgstr ""

#. type: node
#: original_texis/searching.texi:297 original_texis/searching.texi:299
#, no-wrap
msgid "Regexp Special"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:297
msgid "Special characters in regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:297 original_texis/searching.texi:535
#, no-wrap
msgid "Char Classes"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:297
msgid "Character classes used in regular expressions."
msgstr ""

#. type: node
#: original_texis/searching.texi:297 original_texis/searching.texi:599
#, no-wrap
msgid "Regexp Backslash"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:297
msgid "Backslash-sequences in regular expressions."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:300
#, no-wrap
msgid "Special Characters in Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:301
#, no-wrap
msgid "regexp, special characters in"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:305
msgid "Here is a list of the characters that are special in a regular expression."
msgstr ""

#. type: item
#: original_texis/searching.texi:308
#, no-wrap
msgid "@samp{.}@: @r{(Period)}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:309
#, no-wrap
msgid "@samp{.} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:314
msgid ""
"is a special character that matches any single character except a newline.  "
"Using concatenation, we can make regular expressions like @samp{a.b}, which "
"matches any three-character string that begins with @samp{a} and ends with "
"@samp{b}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:315
#, no-wrap
msgid "*"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:316
#, no-wrap
msgid "@samp{*} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:321
msgid ""
"is not a construct by itself; it is a postfix operator that means to match "
"the preceding regular expression repetitively as many times as possible.  "
"Thus, @samp{o*} matches any number of @samp{o}s (including no @samp{o}s)."
msgstr ""

#. type: table
#: original_texis/searching.texi:325
msgid ""
"@samp{*} always applies to the @emph{smallest} possible preceding "
"expression.  Thus, @samp{fo*} has a repeating @samp{o}, not a repeating "
"@samp{fo}.  It matches @samp{f}, @samp{fo}, @samp{foo}, and so on."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:326
#, no-wrap
msgid "backtracking and regular expressions"
msgstr ""

#. type: table
#: original_texis/searching.texi:337
msgid ""
"The matcher processes a @samp{*} construct by matching, immediately, as many "
"repetitions as can be found.  Then it continues with the rest of the "
"pattern.  If that fails, backtracking occurs, discarding some of the matches "
"of the @samp{*}-modified construct in the hope that that will make it "
"possible to match the rest of the pattern.  For example, in matching "
"@samp{ca*ar} against the string @samp{caaar}, the @samp{a*} first tries to "
"match all three @samp{a}s; but the rest of the pattern is @samp{ar} and "
"there is only @samp{r} left to match, so this try fails.  The next "
"alternative is for @samp{a*} to match only two @samp{a}s.  With this choice, "
"the rest of the regexp matches successfully."
msgstr ""

#. type: table
#: original_texis/searching.texi:348
msgid ""
"@strong{Warning:} Nested repetition operators can run for an indefinitely "
"long time, if they lead to ambiguous matching.  For example, trying to match "
"the regular expression @samp{\\(x+y*\\)*a} against the string "
"@samp{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz} could take hours before it "
"ultimately fails.  Emacs must try each way of grouping the @samp{x}s before "
"concluding that none of them can work.  Even worse, @samp{\\(x*\\)*} can "
"match the null string in infinitely many ways, so it causes an infinite "
"loop.  To avoid these problems, check nested repetitions carefully, to make "
"sure that they do not cause combinatorial explosions in backtracking."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:349
#, no-wrap
msgid "+"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:350
#, no-wrap
msgid "@samp{+} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:355
msgid ""
"is a postfix operator, similar to @samp{*} except that it must match the "
"preceding expression at least once.  So, for example, @samp{ca+r} matches "
"the strings @samp{car} and @samp{caaaar} but not the string @samp{cr}, "
"whereas @samp{ca*r} matches all three strings."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:356
#, no-wrap
msgid "?"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:357
#, no-wrap
msgid "@samp{?} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:361
msgid ""
"is a postfix operator, similar to @samp{*} except that it must match the "
"preceding expression either once or not at all.  For example, @samp{ca?r} "
"matches @samp{car} or @samp{cr}; nothing else."
msgstr ""

#. type: item
#: original_texis/searching.texi:362
#, no-wrap
msgid "@samp{*?}, @samp{+?}, @samp{??}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:363
#, no-wrap
msgid "non-greedy repetition characters in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:369
msgid ""
"These are @dfn{non-greedy} variants of the operators @samp{*}, @samp{+} and "
"@samp{?}.  Where those operators match the largest possible substring "
"(consistent with matching the entire containing expression), the non-greedy "
"variants match the smallest possible substring (consistent with matching the "
"entire containing expression)."
msgstr ""

#. type: table
#: original_texis/searching.texi:375
msgid ""
"For example, the regular expression @samp{c[ad]*a} when applied to the "
"string @samp{cdaaada} matches the whole string; but the regular expression "
"@samp{c[ad]*?a}, applied to that same string, matches just @samp{cda}.  (The "
"smallest possible match here for @samp{[ad]*?} that permits the whole "
"expression to match is @samp{d}.)"
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:376
#, no-wrap
msgid "[ @dots{} ]"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:377
#, no-wrap
msgid "character alternative (in regexp)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:378
#, no-wrap
msgid "@samp{[} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:379
#, no-wrap
msgid "@samp{]} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:383
msgid ""
"is a @dfn{character alternative}, which begins with @samp{[} and is "
"terminated by @samp{]}.  In the simplest case, the characters between the "
"two brackets are what this character alternative can match."
msgstr ""

#. type: table
#: original_texis/searching.texi:388
msgid ""
"Thus, @samp{[ad]} matches either one @samp{a} or one @samp{d}, and "
"@samp{[ad]*} matches any string composed of just @samp{a}s and @samp{d}s "
"(including the empty string).  It follows that @samp{c[ad]*r} matches "
"@samp{cr}, @samp{car}, @samp{cdr}, @samp{caddaar}, etc."
msgstr ""

#. type: table
#: original_texis/searching.texi:395
msgid ""
"You can also include character ranges in a character alternative, by writing "
"the starting and ending characters with a @samp{-} between them.  Thus, "
"@samp{[a-z]} matches any lower-case @acronym{ASCII} letter.  Ranges may be "
"intermixed freely with individual characters, as in @samp{[a-z$%.]}, which "
"matches any lower case @acronym{ASCII} letter or @samp{$}, @samp{%} or "
"period."
msgstr ""

#. type: table
#: original_texis/searching.texi:404
msgid ""
"If @code{case-fold-search} is non-@code{nil}, @samp{[a-z]} also matches "
"upper-case letters.  Note that a range like @samp{[a-z]} is not affected by "
"the locale's collation sequence, it always represents a sequence in "
"@acronym{ASCII} order."
msgstr ""

#. type: table
#: original_texis/searching.texi:408
msgid ""
"Note also that the usual regexp special characters are not special inside a "
"character alternative.  A completely different set of characters is special "
"inside character alternatives: @samp{]}, @samp{-} and @samp{^}."
msgstr ""

#. type: table
#: original_texis/searching.texi:416
msgid ""
"To include a @samp{]} in a character alternative, you must make it the first "
"character.  For example, @samp{[]a]} matches @samp{]} or @samp{a}.  To "
"include a @samp{-}, write @samp{-} as the first or last character of the "
"character alternative, or put it after a range.  Thus, @samp{[]-]} matches "
"both @samp{]} and @samp{-}.  (As explained below, you cannot use @samp{\\]} "
"to include a @samp{]} inside a character alternative, since @samp{\\} is not "
"special there.)"
msgstr ""

#. type: table
#: original_texis/searching.texi:419
msgid ""
"To include @samp{^} in a character alternative, put it anywhere but at the "
"beginning."
msgstr ""

#. type: table
#: original_texis/searching.texi:427
msgid ""
"If a range starts with a unibyte character @var{c} and ends with a multibyte "
"character @var{c2}, the range is divided into two parts: one spans the "
"unibyte characters @samp{@var{c}..?\\377}, the other the multibyte "
"characters @samp{@var{c1}..@var{c2}}, where @var{c1} is the first character "
"of the charset to which @var{c2} belongs."
msgstr ""

#. type: table
#: original_texis/searching.texi:434
msgid ""
"A character alternative can also specify named character classes "
"(@pxref{Char Classes}).  This is a POSIX feature.  For example, "
"@samp{[[:ascii:]]} matches any @acronym{ASCII} character.  Using a character "
"class is equivalent to mentioning each of the characters in that class; but "
"the latter is not feasible in practice, since some classes include thousands "
"of different characters."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:435
#, no-wrap
msgid "[^ @dots{} ]"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:436
#, no-wrap
msgid "@samp{^} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:441
msgid ""
"@samp{[^} begins a @dfn{complemented character alternative}.  This matches "
"any character except the ones specified.  Thus, @samp{[^a-z0-9A-Z]} matches "
"all characters @emph{except} letters and digits."
msgstr ""

#. type: table
#: original_texis/searching.texi:445
msgid ""
"@samp{^} is not special in a character alternative unless it is the first "
"character.  The character following the @samp{^} is treated as if it were "
"first (in other words, @samp{-} and @samp{]} are not special there)."
msgstr ""

#. type: table
#: original_texis/searching.texi:449
msgid ""
"A complemented character alternative can match a newline, unless newline is "
"mentioned as one of the characters not to match.  This is in contrast to the "
"handling of regexps in programs such as @code{grep}."
msgstr ""

#. type: table
#: original_texis/searching.texi:453
msgid ""
"You can specify named character classes, just like in character "
"alternatives.  For instance, @samp{[^[:ascii:]]} matches any "
"non-@acronym{ASCII} character.  @xref{Char Classes}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:454
#, no-wrap
msgid "^"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:455
#, no-wrap
msgid "beginning of line in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:461
msgid ""
"When matching a buffer, @samp{^} matches the empty string, but only at the "
"beginning of a line in the text being matched (or the beginning of the "
"accessible portion of the buffer).  Otherwise it fails to match anything.  "
"Thus, @samp{^foo} matches a @samp{foo} that occurs at the beginning of a "
"line."
msgstr ""

#. type: table
#: original_texis/searching.texi:464
msgid ""
"When matching a string instead of a buffer, @samp{^} matches at the "
"beginning of the string or after a newline character."
msgstr ""

#. type: table
#: original_texis/searching.texi:468
msgid ""
"For historical compatibility reasons, @samp{^} can be used only at the "
"beginning of the regular expression, or after @samp{\\(}, @samp{\\(?:} or "
"@samp{\\|}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:469
#, no-wrap
msgid "$"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:470
#, no-wrap
msgid "@samp{$} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:471
#, no-wrap
msgid "end of line in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:475
msgid ""
"is similar to @samp{^} but matches only at the end of a line (or the end of "
"the accessible portion of the buffer).  Thus, @samp{x+$} matches a string of "
"one @samp{x} or more at the end of a line."
msgstr ""

#. type: table
#: original_texis/searching.texi:478
msgid ""
"When matching a string instead of a buffer, @samp{$} matches at the end of "
"the string or before a newline character."
msgstr ""

#. type: table
#: original_texis/searching.texi:481
msgid ""
"For historical compatibility reasons, @samp{$} can be used only at the end "
"of the regular expression, or before @samp{\\)} or @samp{\\|}."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:482
#, no-wrap
msgid "\\"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:483
#, no-wrap
msgid "@samp{\\} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:486
msgid ""
"has two functions: it quotes the special characters (including @samp{\\}), "
"and it introduces additional special constructs."
msgstr ""

#. type: table
#: original_texis/searching.texi:490
msgid ""
"Because @samp{\\} quotes special characters, @samp{\\$} is a regular "
"expression that matches only @samp{$}, and @samp{\\[} is a regular "
"expression that matches only @samp{[}, and so on."
msgstr ""

#. type: table
#: original_texis/searching.texi:498
msgid ""
"Note that @samp{\\} also has special meaning in the read syntax of Lisp "
"strings (@pxref{String Type}), and must be quoted with @samp{\\}.  For "
"example, the regular expression that matches the @samp{\\} character is "
"@samp{\\\\}.  To write a Lisp string that contains the characters "
"@samp{\\\\}, Lisp syntax requires you to quote each @samp{\\} with another "
"@samp{\\}.  Therefore, the read syntax for a regular expression matching "
"@samp{\\} is @code{\"\\\\\\\\\"}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:506
msgid ""
"@strong{Please note:} For historical compatibility, special characters are "
"treated as ordinary ones if they are in contexts where their special "
"meanings make no sense.  For example, @samp{*foo} treats @samp{*} as "
"ordinary since there is no preceding expression on which the @samp{*} can "
"act.  It is poor practice to depend on this behavior; quote the special "
"character anyway, regardless of where it appears."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:514
msgid ""
"As a @samp{\\} is not special inside a character alternative, it can never "
"remove the special meaning of @samp{-} or @samp{]}.  So you should not quote "
"these characters when they have no special meaning either.  This would not "
"clarify anything, since backslashes can legitimately precede these "
"characters where they @emph{have} special meaning, as in @samp{[^\\]} "
"(@code{\"[^\\\\]\"} for Lisp string syntax), which matches any single "
"character except a backslash."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:524
msgid ""
"In practice, most @samp{]} that occur in regular expressions close a "
"character alternative and hence are special.  However, occasionally a "
"regular expression may try to match a complex pattern of literal @samp{[} "
"and @samp{]}.  In such situations, it sometimes may be necessary to "
"carefully parse the regexp from the start to determine which square brackets "
"enclose a character alternative.  For example, @samp{[^][]]} consists of the "
"complemented character alternative @samp{[^][]} (which matches any single "
"character that is not a square bracket), followed by a literal @samp{]}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:534
msgid ""
"The exact rules are that at the beginning of a regexp, @samp{[} is special "
"and @samp{]} not.  This lasts until the first unquoted @samp{[}, after which "
"we are in a character alternative; @samp{[} is no longer special (except "
"when it starts a character class) but @samp{]} is special, unless it "
"immediately follows the special @samp{[} or that @samp{[} followed by a "
"@samp{^}.  This lasts until the next special @samp{]} that does not end a "
"character class.  This ends the character alternative and restores the "
"ordinary syntax of regular expressions; an unquoted @samp{[} is special "
"again and a @samp{]} not."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:536
#, no-wrap
msgid "Character Classes"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:537
#, no-wrap
msgid "character classes in regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:541
msgid ""
"Here is a table of the classes you can use in a character alternative, and "
"what they mean:"
msgstr ""

#. type: item
#: original_texis/searching.texi:543
#, no-wrap
msgid "[:ascii:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:545
msgid "This matches any @acronym{ASCII} character (codes 0--127)."
msgstr ""

#. type: item
#: original_texis/searching.texi:545
#, no-wrap
msgid "[:alnum:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:550
msgid ""
"This matches any letter or digit.  For multibyte characters, it matches "
"characters whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are alphabetic or decimal number characters."
msgstr ""

#. type: item
#: original_texis/searching.texi:550
#, no-wrap
msgid "[:alpha:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:555
msgid ""
"This matches any letter.  For multibyte characters, it matches characters "
"whose Unicode @samp{general-category} property (@pxref{Character "
"Properties}) indicates they are alphabetic characters."
msgstr ""

#. type: item
#: original_texis/searching.texi:555
#, no-wrap
msgid "[:blank:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:557
msgid "This matches space and tab only."
msgstr ""

#. type: item
#: original_texis/searching.texi:557
#, no-wrap
msgid "[:cntrl:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:559
msgid "This matches any @acronym{ASCII} control character."
msgstr ""

#. type: item
#: original_texis/searching.texi:559
#, no-wrap
msgid "[:digit:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:562
msgid ""
"This matches @samp{0} through @samp{9}.  Thus, @samp{[-+[:digit:]]} matches "
"any digit, as well as @samp{+} and @samp{-}."
msgstr ""

#. type: item
#: original_texis/searching.texi:562
#, no-wrap
msgid "[:graph:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:568
msgid ""
"This matches graphic characters---everything except whitespace, "
"@acronym{ASCII} and non-@acronym{ASCII} control characters, surrogates, and "
"codepoints unassigned by Unicode, as indicated by the Unicode "
"@samp{general-category} property (@pxref{Character Properties})."
msgstr ""

#. type: item
#: original_texis/searching.texi:568
#, no-wrap
msgid "[:lower:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:572
msgid ""
"This matches any lower-case letter, as determined by the current case table "
"(@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this "
"also matches any upper-case letter."
msgstr ""

#. type: item
#: original_texis/searching.texi:572
#, no-wrap
msgid "[:multibyte:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:574
msgid "This matches any multibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: original_texis/searching.texi:574
#, no-wrap
msgid "[:nonascii:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:576
msgid "This matches any non-@acronym{ASCII} character."
msgstr ""

#. type: item
#: original_texis/searching.texi:576
#, no-wrap
msgid "[:print:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:579
msgid ""
"This matches any printing character---either whitespace, or a graphic "
"character matched by @samp{[:graph:]}."
msgstr ""

#. type: item
#: original_texis/searching.texi:579
#, no-wrap
msgid "[:punct:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:582
msgid ""
"This matches any punctuation character.  (At present, for multibyte "
"characters, it matches anything that has non-word syntax.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:582
#, no-wrap
msgid "[:space:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:585
msgid ""
"This matches any character that has whitespace syntax (@pxref{Syntax Class "
"Table})."
msgstr ""

#. type: item
#: original_texis/searching.texi:585
#, no-wrap
msgid "[:unibyte:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:587
msgid "This matches any unibyte character (@pxref{Text Representations})."
msgstr ""

#. type: item
#: original_texis/searching.texi:587
#, no-wrap
msgid "[:upper:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:591
msgid ""
"This matches any upper-case letter, as determined by the current case table "
"(@pxref{Case Tables}).  If @code{case-fold-search} is non-@code{nil}, this "
"also matches any lower-case letter."
msgstr ""

#. type: item
#: original_texis/searching.texi:591
#, no-wrap
msgid "[:word:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:594
msgid ""
"This matches any character that has word syntax (@pxref{Syntax Class "
"Table})."
msgstr ""

#. type: item
#: original_texis/searching.texi:594
#, no-wrap
msgid "[:xdigit:]"
msgstr ""

#. type: table
#: original_texis/searching.texi:597
msgid ""
"This matches the hexadecimal digits: @samp{0} through @samp{9}, @samp{a} "
"through @samp{f} and @samp{A} through @samp{F}."
msgstr ""

#. type: subsubsection
#: original_texis/searching.texi:600
#, no-wrap
msgid "Backslash Constructs in Regular Expressions"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:601
#, no-wrap
msgid "backslash in regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:607
msgid ""
"For the most part, @samp{\\} followed by any character matches only that "
"character.  However, there are several exceptions: certain sequences "
"starting with @samp{\\} that have special meanings.  Here is a table of the "
"special @samp{\\} constructs."
msgstr ""

#. type: item
#: original_texis/searching.texi:609
#, no-wrap
msgid "\\|"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:610
#, no-wrap
msgid "@samp{|} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:611
#, no-wrap
msgid "regexp alternative"
msgstr ""

#. type: table
#: original_texis/searching.texi:616
msgid ""
"specifies an alternative.  Two regular expressions @var{a} and @var{b} with "
"@samp{\\|} in between form an expression that matches anything that either "
"@var{a} or @var{b} matches."
msgstr ""

#. type: table
#: original_texis/searching.texi:619
msgid ""
"Thus, @samp{foo\\|bar} matches either @samp{foo} or @samp{bar} but no other "
"string."
msgstr ""

#. type: table
#: original_texis/searching.texi:623
msgid ""
"@samp{\\|} applies to the largest possible surrounding expressions.  Only a "
"surrounding @samp{\\( @dots{} \\)} grouping can limit the grouping power of "
"@samp{\\|}."
msgstr ""

#. type: table
#: original_texis/searching.texi:627
msgid ""
"If you need full backtracking capability to handle multiple uses of "
"@samp{\\|}, use the POSIX regular expression functions (@pxref{POSIX "
"Regexps})."
msgstr ""

#. type: item
#: original_texis/searching.texi:628
#, no-wrap
msgid "\\@{@var{m}\\@}"
msgstr ""

#. type: table
#: original_texis/searching.texi:633
msgid ""
"is a postfix operator that repeats the previous pattern exactly @var{m} "
"times.  Thus, @samp{x\\@{5\\@}} matches the string @samp{xxxxx} and nothing "
"else.  @samp{c[ad]\\@{3\\@}r} matches string such as @samp{caaar}, "
"@samp{cdddr}, @samp{cadar}, and so on."
msgstr ""

#. type: item
#: original_texis/searching.texi:634
#, no-wrap
msgid "\\@{@var{m},@var{n}\\@}"
msgstr ""

#. type: table
#: original_texis/searching.texi:639
msgid ""
"is a more general postfix operator that specifies repetition with a minimum "
"of @var{m} repeats and a maximum of @var{n} repeats.  If @var{m} is omitted, "
"the minimum is 0; if @var{n} is omitted, there is no maximum."
msgstr ""

#. type: table
#: original_texis/searching.texi:646
msgid ""
"For example, @samp{c[ad]\\@{1,2\\@}r} matches the strings @samp{car}, "
"@samp{cdr}, @samp{caar}, @samp{cadr}, @samp{cdar}, and @samp{cddr}, and "
"nothing else.@* @samp{\\@{0,1\\@}} or @samp{\\@{,1\\@}} is equivalent to "
"@samp{?}.@* @samp{\\@{0,\\@}} or @samp{\\@{,\\@}} is equivalent to "
"@samp{*}.@* @samp{\\@{1,\\@}} is equivalent to @samp{+}."
msgstr ""

#. type: item
#: original_texis/searching.texi:647
#, no-wrap
msgid "\\( @dots{} \\)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:648
#, no-wrap
msgid "@samp{(} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:649
#, no-wrap
msgid "@samp{)} in regexp"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:650
#, no-wrap
msgid "regexp grouping"
msgstr ""

#. type: table
#: original_texis/searching.texi:652
msgid "is a grouping construct that serves three purposes:"
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:658
msgid ""
"To enclose a set of @samp{\\|} alternatives for other operations.  Thus, the "
"regular expression @samp{\\(foo\\|bar\\)x} matches either @samp{foox} or "
"@samp{barx}."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:664
msgid ""
"To enclose a complicated expression for the postfix operators @samp{*}, "
"@samp{+} and @samp{?} to operate on.  Thus, @samp{ba\\(na\\)*} matches "
"@samp{ba}, @samp{bana}, @samp{banana}, @samp{bananana}, etc., with any "
"number (zero or more) of @samp{na} strings."
msgstr ""

#. type: enumerate
#: original_texis/searching.texi:668
msgid ""
"To record a matched substring for future reference with @samp{\\@var{digit}} "
"(see below)."
msgstr ""

#. type: table
#: original_texis/searching.texi:676
msgid ""
"This last application is not a consequence of the idea of a parenthetical "
"grouping; it is a separate feature that was assigned as a second meaning to "
"the same @samp{\\( @dots{} \\)} construct because, in practice, there was "
"usually no conflict between the two meanings.  But occasionally there is a "
"conflict, and that led to the introduction of shy groups."
msgstr ""

#. type: item
#: original_texis/searching.texi:677
#, no-wrap
msgid "\\(?: @dots{} \\)"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:678
#, no-wrap
msgid "shy groups"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:679
#, no-wrap
msgid "non-capturing group"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:680
#, no-wrap
msgid "unnumbered group"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:681
#, no-wrap
msgid "@samp{(?:} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:689
msgid ""
"is the @dfn{shy group} construct.  A shy group serves the first two purposes "
"of an ordinary group (controlling the nesting of other operators), but it "
"does not get a number, so you cannot refer back to its value with "
"@samp{\\@var{digit}}.  Shy groups are particularly useful for "
"mechanically-constructed regular expressions, because they can be added "
"automatically without altering the numbering of ordinary, non-shy groups."
msgstr ""

#. type: table
#: original_texis/searching.texi:692
msgid "Shy groups are also called @dfn{non-capturing} or @dfn{unnumbered groups}."
msgstr ""

#. type: item
#: original_texis/searching.texi:693
#, no-wrap
msgid "\\(?@var{num}: @dots{} \\)"
msgstr ""

#. type: table
#: original_texis/searching.texi:702
msgid ""
"is the @dfn{explicitly numbered group} construct.  Normal groups get their "
"number implicitly, based on their position, which can be inconvenient.  This "
"construct allows you to force a particular group number.  There is no "
"particular restriction on the numbering, e.g., you can have several groups "
"with the same number in which case the last one to match (i.e., the "
"rightmost match) will win.  Implicitly numbered groups always get the "
"smallest integer larger than the one of any previous group."
msgstr ""

#. type: item
#: original_texis/searching.texi:703
#, no-wrap
msgid "\\@var{digit}"
msgstr ""

#. type: table
#: original_texis/searching.texi:706
msgid ""
"matches the same text that matched the @var{digit}th occurrence of a "
"grouping (@samp{\\( @dots{} \\)}) construct."
msgstr ""

#. type: table
#: original_texis/searching.texi:711
msgid ""
"In other words, after the end of a group, the matcher remembers the "
"beginning and end of the text matched by that group.  Later on in the "
"regular expression you can use @samp{\\} followed by @var{digit} to match "
"that same text, whatever it may have been."
msgstr ""

#. type: table
#: original_texis/searching.texi:718
msgid ""
"The strings matching the first nine grouping constructs appearing in the "
"entire regular expression passed to a search or matching function are "
"assigned numbers 1 through 9 in the order that the open parentheses appear "
"in the regular expression.  So you can use @samp{\\1} through @samp{\\9} to "
"refer to the text matched by the corresponding grouping constructs."
msgstr ""

#. type: table
#: original_texis/searching.texi:723
msgid ""
"For example, @samp{\\(.*\\)\\1} matches any newline-free string that is "
"composed of two identical halves.  The @samp{\\(.*\\)} matches the first "
"half, which may be anything, but the @samp{\\1} that follows must match the "
"same exact text."
msgstr ""

#. type: table
#: original_texis/searching.texi:727
msgid ""
"If a @samp{\\( @dots{} \\)} construct matches more than once (which can "
"happen, for instance, if it is followed by @samp{*}), only the last match is "
"recorded."
msgstr ""

#. type: table
#: original_texis/searching.texi:737
msgid ""
"If a particular grouping construct in the regular expression was never "
"matched---for instance, if it appears inside of an alternative that wasn't "
"used, or inside of a repetition that repeated zero times---then the "
"corresponding @samp{\\@var{digit}} construct never matches anything.  To use "
"an artificial example, @samp{\\(foo\\(b*\\)\\|lose\\)\\2} cannot match "
"@samp{lose}: the second alternative inside the larger group matches it, but "
"then @samp{\\2} is undefined and can't match anything.  But it can match "
"@samp{foobb}, because the first alternative matches @samp{foob} and "
"@samp{\\2} matches @samp{b}."
msgstr ""

#. type: item
#: original_texis/searching.texi:738
#, no-wrap
msgid "\\w"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:739
#, no-wrap
msgid "@samp{\\w} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:742
msgid ""
"matches any word-constituent character.  The editor syntax table determines "
"which characters these are.  @xref{Syntax Tables}."
msgstr ""

#. type: item
#: original_texis/searching.texi:743
#, no-wrap
msgid "\\W"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:744
#, no-wrap
msgid "@samp{\\W} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:746
msgid "matches any character that is not a word constituent."
msgstr ""

#. type: item
#: original_texis/searching.texi:747
#, no-wrap
msgid "\\s@var{code}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:748
#, no-wrap
msgid "@samp{\\s} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:755
msgid ""
"matches any character whose syntax is @var{code}.  Here @var{code} is a "
"character that represents a syntax code: thus, @samp{w} for word "
"constituent, @samp{-} for whitespace, @samp{(} for open parenthesis, etc.  "
"To represent whitespace syntax, use either @samp{-} or a space character.  "
"@xref{Syntax Class Table}, for a list of syntax codes and the characters "
"that stand for them."
msgstr ""

#. type: item
#: original_texis/searching.texi:756
#, no-wrap
msgid "\\S@var{code}"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:757
#, no-wrap
msgid "@samp{\\S} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:759
msgid "matches any character whose syntax is not @var{code}."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:760
#, no-wrap
msgid "category, regexp search for"
msgstr ""

#. type: item
#: original_texis/searching.texi:761
#, no-wrap
msgid "\\c@var{c}"
msgstr ""

#. type: table
#: original_texis/searching.texi:769
msgid ""
"matches any character whose category is @var{c}.  Here @var{c} is a "
"character that represents a category: thus, @samp{c} for Chinese characters "
"or @samp{g} for Greek characters in the standard category table.  You can "
"see the list of all the currently defined categories with @kbd{M-x "
"describe-categories @key{RET}}.  You can also define your own categories in "
"addition to the standard ones using the @code{define-category} function "
"(@pxref{Categories})."
msgstr ""

#. type: item
#: original_texis/searching.texi:770
#, no-wrap
msgid "\\C@var{c}"
msgstr ""

#. type: table
#: original_texis/searching.texi:772
msgid "matches any character whose category is not @var{c}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:779
msgid ""
"The following regular expression constructs match the empty string---that "
"is, they don't use up any characters---but whether they match depends on the "
"context.  For all, the beginning and end of the accessible portion of the "
"buffer are treated as if they were the actual beginning and end of the "
"buffer."
msgstr ""

#. type: item
#: original_texis/searching.texi:781
#, no-wrap
msgid "\\`"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:782
#, no-wrap
msgid "@samp{\\`} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:785
msgid ""
"matches the empty string, but only at the beginning of the buffer or string "
"being matched against."
msgstr ""

#. type: item
#: original_texis/searching.texi:786
#, no-wrap
msgid "\\'"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:787
#, no-wrap
msgid "@samp{\\'} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:790
msgid ""
"matches the empty string, but only at the end of the buffer or string being "
"matched against."
msgstr ""

#. type: item
#: original_texis/searching.texi:791
#, no-wrap
msgid "\\="
msgstr ""

#. type: cindex
#: original_texis/searching.texi:792
#, no-wrap
msgid "@samp{\\=} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:795
msgid ""
"matches the empty string, but only at point.  (This construct is not defined "
"when matching against a string.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:796
#, no-wrap
msgid "\\b"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:797
#, no-wrap
msgid "@samp{\\b} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:802
msgid ""
"matches the empty string, but only at the beginning or end of a word.  Thus, "
"@samp{\\bfoo\\b} matches any occurrence of @samp{foo} as a separate word.  "
"@samp{\\bballs?\\b} matches @samp{ball} or @samp{balls} as a separate word."
msgstr ""

#. type: table
#: original_texis/searching.texi:805
msgid ""
"@samp{\\b} matches at the beginning or end of the buffer (or string)  "
"regardless of what text appears next to it."
msgstr ""

#. type: item
#: original_texis/searching.texi:806
#, no-wrap
msgid "\\B"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:807
#, no-wrap
msgid "@samp{\\B} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:810
msgid ""
"matches the empty string, but @emph{not} at the beginning or end of a word, "
"nor at the beginning or end of the buffer (or string)."
msgstr ""

#. type: item
#: original_texis/searching.texi:811
#, no-wrap
msgid "\\<"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:812
#, no-wrap
msgid "@samp{\\<} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:816
msgid ""
"matches the empty string, but only at the beginning of a word.  @samp{\\<} "
"matches at the beginning of the buffer (or string) only if a "
"word-constituent character follows."
msgstr ""

#. type: item
#: original_texis/searching.texi:817
#, no-wrap
msgid "\\>"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:818
#, no-wrap
msgid "@samp{\\>} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:822
msgid ""
"matches the empty string, but only at the end of a word.  @samp{\\>} matches "
"at the end of the buffer (or string) only if the contents end with a "
"word-constituent character."
msgstr ""

#. type: item
#: original_texis/searching.texi:823
#, no-wrap
msgid "\\_<"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:824
#, no-wrap
msgid "@samp{\\_<} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:829
msgid ""
"matches the empty string, but only at the beginning of a symbol.  A symbol "
"is a sequence of one or more word or symbol constituent characters.  "
"@samp{\\_<} matches at the beginning of the buffer (or string) only if a "
"symbol-constituent character follows."
msgstr ""

#. type: item
#: original_texis/searching.texi:830
#, no-wrap
msgid "\\_>"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:831
#, no-wrap
msgid "@samp{\\_>} in regexp"
msgstr ""

#. type: table
#: original_texis/searching.texi:835
msgid ""
"matches the empty string, but only at the end of a symbol.  @samp{\\_>} "
"matches at the end of the buffer (or string) only if the contents end with a "
"symbol-constituent character."
msgstr ""

#. type: kindex
#: original_texis/searching.texi:837
#, no-wrap
msgid "invalid-regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:843
msgid ""
"Not every string is a valid regular expression.  For example, a string that "
"ends inside a character alternative without a terminating @samp{]} is "
"invalid, and so is a string that ends with a single @samp{\\}.  If an "
"invalid regular expression is passed to any of the search functions, an "
"@code{invalid-regexp} error is signaled."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:845
#, no-wrap
msgid "Complex Regexp Example"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:852
msgid ""
"Here is a complicated regexp which was formerly used by Emacs to recognize "
"the end of a sentence together with any whitespace that follows.  (Nowadays "
"Emacs uses a similar but more complex default regexp constructed by the "
"function @code{sentence-end}.  @xref{Standard Regexps}.)"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:859
msgid ""
"Below, we show first the regexp as a string in Lisp syntax (to distinguish "
"spaces from tab characters), and then the result of evaluating it.  The "
"string constant begins and ends with a double-quote.  @samp{\\\"} stands for "
"a double-quote as part of the string, @samp{\\\\} for a backslash as part of "
"the string, @samp{\\t} for a tab and @samp{\\n} for a newline."
msgstr ""

#. type: group
#: original_texis/searching.texi:865
#, no-wrap
msgid ""
"\"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|\\t\\\\|@ @ \\\\)[ \\t\\n]*\"\n"
"     @result{} \"[.?!][]\\\"')@}]*\\\\($\\\\| $\\\\|  \\\\|@ @ \\\\)[\n"
"]*\"\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:870
msgid "In the output, tab and newline appear as themselves."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:873
msgid ""
"This regular expression contains four parts in succession and can be "
"deciphered as follows:"
msgstr ""

#. type: item
#: original_texis/searching.texi:875
#, no-wrap
msgid "[.?!]"
msgstr ""

#. type: table
#: original_texis/searching.texi:882
msgid ""
"The first part of the pattern is a character alternative that matches any "
"one of three characters: period, question mark, and exclamation mark.  The "
"match must begin with one of these three characters.  (This is one point "
"where the new default regexp used by Emacs differs from the old.  The new "
"value also allows some non-@acronym{ASCII} characters that end a sentence "
"without any following whitespace.)"
msgstr ""

#. type: item
#: original_texis/searching.texi:883
#, no-wrap
msgid "[]\\\"')@}]*"
msgstr ""

#. type: table
#: original_texis/searching.texi:890
msgid ""
"The second part of the pattern matches any closing braces and quotation "
"marks, zero or more of them, that may follow the period, question mark or "
"exclamation mark.  The @code{\\\"} is Lisp syntax for a double-quote in a "
"string.  The @samp{*} at the end indicates that the immediately preceding "
"regular expression (a character alternative, in this case) may be repeated "
"zero or more times."
msgstr ""

#. type: item
#: original_texis/searching.texi:891
#, no-wrap
msgid "\\\\($\\\\|@ $\\\\|\\t\\\\|@ @ \\\\)"
msgstr ""

#. type: table
#: original_texis/searching.texi:898
msgid ""
"The third part of the pattern matches the whitespace that follows the end of "
"a sentence: the end of a line (optionally with a space), or a tab, or two "
"spaces.  The double backslashes mark the parentheses and vertical bars as "
"regular expression syntax; the parentheses delimit a group and the vertical "
"bars separate alternatives.  The dollar sign is used to match the end of a "
"line."
msgstr ""

#. type: item
#: original_texis/searching.texi:899
#, no-wrap
msgid "[ \\t\\n]*"
msgstr ""

#. type: table
#: original_texis/searching.texi:902
msgid ""
"Finally, the last part of the pattern matches any additional whitespace "
"beyond the minimum needed to end a sentence."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:905
#, no-wrap
msgid "Regular Expression Functions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:908
msgid "These functions operate on regular expressions."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:909
#, no-wrap
msgid "quote special characters in regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:910
#, no-wrap
msgid "regexp-quote string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:916
msgid ""
"This function returns a regular expression whose only exact match is "
"@var{string}.  Using this regular expression in @code{looking-at} will "
"succeed only if the next characters in the buffer are @var{string}; using it "
"in a search function will succeed if the text being searched contains "
"@var{string}.  @xref{Regexp Search}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:919
msgid ""
"This allows you to request an exact string match or search when calling a "
"function that wants a regular expression."
msgstr ""

#. type: group
#: original_texis/searching.texi:924
#, no-wrap
msgid ""
"(regexp-quote \"^The cat$\")\n"
"     @result{} \"\\\\^The cat\\\\$\"\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:931
msgid ""
"One use of @code{regexp-quote} is to combine an exact string match with "
"context described as a regular expression.  For example, this searches for "
"the string that is the value of @var{string}, surrounded by whitespace:"
msgstr ""

#. type: group
#: original_texis/searching.texi:936
#, no-wrap
msgid ""
"(re-search-forward\n"
" (concat \"\\\\s-\" (regexp-quote string) \"\\\\s-\"))\n"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:940
#, no-wrap
msgid "optimize regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:941
#, no-wrap
msgid "regexp-opt strings &optional paren"
msgstr ""

#. type: defun
#: original_texis/searching.texi:950
msgid ""
"This function returns an efficient regular expression that will match any of "
"the strings in the list @var{strings}.  This is useful when you need to make "
"matching or searching as fast as possible---for example, for Font Lock "
"mode@footnote{Note that @code{regexp-opt} does not guarantee that its result "
"is absolutely the most efficient form possible.  A hand-tuned regular "
"expression can sometimes be slightly more efficient, but is almost never "
"worth the effort.}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:952
msgid "The optional argument @var{paren} can be any of the following:"
msgstr ""

#. type: defun
#: original_texis/searching.texi:957
msgid ""
"a string the resulting regexp is preceded by @var{paren} and followed by "
"@samp{\\)}, e.g. use @samp{\"\\\\(?1:\"} to produce an explicitly numbered "
"group."
msgstr ""

#. type: defun
#: original_texis/searching.texi:960
msgid ""
"@code{words} the resulting regexp is surrounded by @samp{\\<\\(} and "
"@samp{\\)\\>}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:965
msgid ""
"@code{symbols} the resulting regexp is surrounded by @samp{\\_<\\(} and "
"@samp{\\)\\_>} (this is often appropriate when maching programming-language "
"keywords and the like)."
msgstr ""

#. type: defun
#: original_texis/searching.texi:968
msgid ""
"non-@code{nil} the resulting regexp is surrounded by @samp{\\(} and "
"@samp{\\)}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:973
msgid ""
"@code{nil} the resulting regexp is surrounded by @samp{\\(?:} and "
"@samp{\\)}, if it is necessary to ensure that a postfix operator appended to "
"it will apply to the whole expression."
msgstr ""

#. type: defun
#: original_texis/searching.texi:976
msgid ""
"The resulting regexp of @code{regexp-opt} is equivalent to but usually more "
"efficient than that of a simplified version:"
msgstr ""

#. type: example
#: original_texis/searching.texi:987
#, no-wrap
msgid ""
"(defun simplified-regexp-opt (strings &optional paren)\n"
" (let ((parens (cond ((stringp paren)       (cons paren \"\\\\)\"))\n"
"                     ((eq paren 'words)    '(\"\\\\<\\\\(\" "
". \"\\\\)\\\\>\"))\n"
"                     ((eq paren 'symbols) '(\"\\\\_<\\\\(\" "
". \"\\\\)\\\\_>\"))\n"
"                     ((null paren)          '(\"\\\\(?:\" . \"\\\\)\"))\n"
"                     (t                       '(\"\\\\(\" . \"\\\\)\")))))\n"
"   (concat (car paren)\n"
"           (mapconcat 'regexp-quote strings \"\\\\|\")\n"
"           (cdr paren))))\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:990
#, no-wrap
msgid "regexp-opt-depth regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:994
msgid ""
"This function returns the total number of grouping constructs (parenthesized "
"expressions) in @var{regexp}.  This does not include shy groups "
"(@pxref{Regexp Backslash})."
msgstr ""

#. type: defun
#: original_texis/searching.texi:997
#, no-wrap
msgid "regexp-opt-charset chars"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1000
msgid ""
"This function returns a regular expression matching a character in the list "
"of characters @var{chars}."
msgstr ""

#. type: example
#: original_texis/searching.texi:1004
#, no-wrap
msgid ""
"(regexp-opt-charset '(?a ?b ?c ?d ?e))\n"
"     @result{} \"[a-e]\"\n"
msgstr ""

#. type: section
#: original_texis/searching.texi:1010
#, no-wrap
msgid "Regular Expression Searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1011
#, no-wrap
msgid "regular expression searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1012
#, no-wrap
msgid "regexp searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1013
#, no-wrap
msgid "searching for regexp"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1021
msgid ""
"In GNU Emacs, you can search for the next match for a regular expression "
"(@pxref{Syntax of Regexps}) either incrementally or not.  For incremental "
"search commands, see @ref{Regexp Search, , Regular Expression Search, emacs, "
"The GNU Emacs Manual}.  Here we describe only the search functions useful in "
"programs.  The principal one is @code{re-search-forward}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1025
msgid ""
"These search functions convert the regular expression to multibyte if the "
"buffer is multibyte; they convert the regular expression to unibyte if the "
"buffer is unibyte.  @xref{Text Representations}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1026
#, no-wrap
msgid "Command re-search-forward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1032
msgid ""
"This function searches forward in the current buffer for a string of text "
"that is matched by the regular expression @var{regexp}.  The function skips "
"over any amount of text that is not matched by @var{regexp}, and leaves "
"point at the end of the first match found.  It returns the new value of "
"point."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1038
msgid ""
"If @var{limit} is non-@code{nil}, it must be a position in the current "
"buffer.  It specifies the upper bound to the search.  No match extending "
"after that position is accepted.  If @var{limit} is omitted or @code{nil}, "
"it defaults to the end of the accessible portion of the buffer."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1041
msgid ""
"What @code{re-search-forward} does when the search fails depends on the "
"value of @var{noerror}:"
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1043
#, no-wrap
msgid "nil"
msgstr ""

#. type: table
#: original_texis/searching.texi:1045
msgid "Signal a @code{search-failed} error."
msgstr ""

#. type: code{#1}
#: original_texis/searching.texi:1045
#, no-wrap
msgid "t"
msgstr ""

#. type: table
#: original_texis/searching.texi:1047
msgid "Do nothing and return @code{nil}."
msgstr ""

#. type: item
#: original_texis/searching.texi:1047
#, no-wrap
msgid "anything else"
msgstr ""

#. type: table
#: original_texis/searching.texi:1050
msgid ""
"Move point to @var{limit} (or the end of the accessible portion of the "
"buffer) and return @code{nil}."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1068
msgid ""
"In the following example, point is initially before the @samp{T}.  "
"Evaluating the search call moves point to the end of that line (between the "
"@samp{t} of @samp{hat} and the newline)."
msgstr ""

#. type: group
#: original_texis/searching.texi:1075
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1080
#, no-wrap
msgid ""
"(re-search-forward \"[a-z]+\" nil t 5)\n"
"     @result{} 27\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1085
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat in the hat@point{}\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1089
#, no-wrap
msgid "Command re-search-backward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1093
msgid ""
"This function searches backward in the current buffer for a string of text "
"that is matched by the regular expression @var{regexp}, leaving point at the "
"beginning of the first text found."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1103
msgid ""
"This function is analogous to @code{re-search-forward}, but they are not "
"simple mirror images.  @code{re-search-forward} finds the match whose "
"beginning is as close as possible to the starting point.  If "
"@code{re-search-backward} were a perfect mirror image, it would find the "
"match whose end is as close as possible.  However, in fact it finds the "
"match whose beginning is as close as possible (and yet ends before the "
"starting point).  The reason for this is that matching a regular expression "
"at a given spot always works from beginning to end, and starts at a "
"specified beginning position."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1107
msgid ""
"A true mirror-image of @code{re-search-forward} would require a special "
"feature for matching regular expressions from end to beginning.  It's not "
"worth the trouble of implementing that."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1109
#, no-wrap
msgid "string-match regexp string &optional start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1114
msgid ""
"This function returns the index of the start of the first match for the "
"regular expression @var{regexp} in @var{string}, or @code{nil} if there is "
"no match.  If @var{start} is non-@code{nil}, the search starts at that index "
"in @var{string}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1116
msgid "For example,"
msgstr ""

#. type: group
#: original_texis/searching.texi:1122
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\")\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1127 original_texis/searching.texi:1142
#, no-wrap
msgid ""
"(string-match\n"
" \"quick\" \"The quick brown fox jumped quickly.\" 8)\n"
"     @result{} 27\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1133
msgid ""
"The index of the first character of the string is 0, the index of the second "
"character is 1, and so on."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1136
msgid ""
"If this function finds a match, the index of the first character beyond the "
"match is available as @code{(match-end 0)}.  @xref{Match Data}."
msgstr ""

#. type: group
#: original_texis/searching.texi:1147
#, no-wrap
msgid ""
"(match-end 0)\n"
"     @result{} 32\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1151
#, no-wrap
msgid "string-match-p regexp string &optional start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1154
msgid ""
"This predicate function does what @code{string-match} does, but it avoids "
"modifying the match data."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1156
#, no-wrap
msgid "looking-at regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1162
msgid ""
"This function determines whether the text in the current buffer directly "
"following point matches the regular expression @var{regexp}.  ``Directly "
"following'' means precisely that: the search is ``anchored'' and it can "
"succeed only starting with the first character following point.  The result "
"is @code{t} if so, @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1166
msgid ""
"This function does not move point, but it does update the match data.  "
"@xref{Match Data}.  If you need to test for a match without modifying the "
"match data, use @code{looking-at-p}, described below."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1169
msgid ""
"In this example, point is located directly before the @samp{T}.  If it were "
"anywhere else, the result would be @code{nil}."
msgstr ""

#. type: group
#: original_texis/searching.texi:1176 original_texis/searching.texi:1201
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"@point{}The cat in the hat\n"
"comes back\" twice.\n"
"---------- Buffer: foo ----------\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1179
#, no-wrap
msgid ""
"(looking-at \"The cat in the hat$\")\n"
"     @result{} t\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1183
#, no-wrap
msgid "looking-back regexp limit &optional greedy"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1186
msgid ""
"This function returns @code{t} if @var{regexp} matches the text immediately "
"before point (i.e., ending at point), and @code{nil} otherwise."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1194
msgid ""
"Because regular expression matching works only going forward, this is "
"implemented by searching backwards from point for a match that ends at "
"point.  That can be quite slow if it has to search a long distance.  You can "
"bound the time required by specifying a non-@code{nil} value for "
"@var{limit}, which says not to search before @var{limit}.  In this case, the "
"match that is found must begin at or after @var{limit}.  Here's an example:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1206
#, no-wrap
msgid ""
"(looking-back \"read \\\"\" 3)\n"
"     @result{} t\n"
"(looking-back \"read \\\"\" 4)\n"
"     @result{} nil\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1214
msgid ""
"If @var{greedy} is non-@code{nil}, this function extends the match backwards "
"as far as possible, stopping when a single additional previous character "
"cannot be part of a match for @var{regexp}.  When the match is extended, its "
"starting position is allowed to occur before @var{limit}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1219
msgid ""
"As a general recommendation, try to avoid using @code{looking-back} wherever "
"possible, since it is slow.  For this reason, there are no plans to add a "
"@code{looking-back-p} function."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1221
#, no-wrap
msgid "looking-at-p regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1224
msgid ""
"This predicate function works like @code{looking-at}, but without updating "
"the match data."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1226
#, no-wrap
msgid "search-spaces-regexp"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1233
msgid ""
"If this variable is non-@code{nil}, it should be a regular expression that "
"says how to search for whitespace.  In that case, any group of spaces in a "
"regular expression being searched for stands for use of this regular "
"expression.  However, spaces inside of constructs such as @samp{[@dots{}]} "
"and @samp{*}, @samp{+}, @samp{?} are not affected by "
"@code{search-spaces-regexp}."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1237
msgid ""
"Since this variable affects all regular expression search and match "
"constructs, you should bind it temporarily for as small as possible a part "
"of the code."
msgstr ""

#. type: section
#: original_texis/searching.texi:1240
#, no-wrap
msgid "POSIX Regular Expression Searching"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1242
#, no-wrap
msgid "backtracking and POSIX regular expressions"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1247
msgid ""
"The usual regular expression functions do backtracking when necessary to "
"handle the @samp{\\|} and repetition constructs, but they continue this only "
"until they find @emph{some} match.  Then they succeed and report the first "
"match found."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1254
msgid ""
"This section describes alternative search functions which perform the full "
"backtracking specified by the POSIX standard for regular expression "
"matching.  They continue backtracking until they have tried all "
"possibilities and found all matches, so they can report the longest match, "
"as required by POSIX@.  This is much slower, so use these functions only "
"when you really need the longest match."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1259
msgid ""
"The POSIX search and match functions do not properly support the non-greedy "
"repetition operators (@pxref{Regexp Special, non-greedy}).  This is because "
"POSIX backtracking conflicts with the semantics of non-greedy repetition."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1260
#, no-wrap
msgid "Command posix-search-forward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1264
msgid ""
"This is like @code{re-search-forward} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1266
#, no-wrap
msgid "Command posix-search-backward regexp &optional limit noerror count"
msgstr ""

#. type: deffn
#: original_texis/searching.texi:1270
msgid ""
"This is like @code{re-search-backward} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1272
#, no-wrap
msgid "posix-looking-at regexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1276
msgid ""
"This is like @code{looking-at} except that it performs the full backtracking "
"specified by the POSIX standard for regular expression matching."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1278
#, no-wrap
msgid "posix-string-match regexp string &optional start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1282
msgid ""
"This is like @code{string-match} except that it performs the full "
"backtracking specified by the POSIX standard for regular expression "
"matching."
msgstr ""

#. type: section
#: original_texis/searching.texi:1285
#, no-wrap
msgid "The Match Data"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1286
#, no-wrap
msgid "match data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1293
msgid ""
"Emacs keeps track of the start and end positions of the segments of text "
"found during a search; this is called the @dfn{match data}.  Thanks to the "
"match data, you can search for a complex pattern, such as a date in a mail "
"message, and then extract parts of the match under control of the pattern."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1299
msgid ""
"Because the match data normally describe the most recent search only, you "
"must be careful not to do another search inadvertently between the search "
"you wish to refer back to and the use of the match data.  If you can't avoid "
"another intervening search, you must save and restore the match data around "
"it, to prevent it from being overwritten."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1305
msgid ""
"Notice that all functions are allowed to overwrite the match data unless "
"they're explicitly documented not to do so.  A consequence is that functions "
"that are run implicitly in the background (@pxref{Timers}, and @ref{Idle "
"Timers}) should likely save and restore the match data explicitly."
msgstr ""

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1314
#, no-wrap
msgid "Replacing Match"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1312
msgid "Replacing a substring that was matched."
msgstr ""

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1398
#, no-wrap
msgid "Simple Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1312
msgid ""
"Accessing single items of match data, such as where a particular "
"subexpression started."
msgstr ""

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1544
#, no-wrap
msgid "Entire Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1312
msgid "Accessing the entire match data at once, as a list."
msgstr ""

#. type: node
#: original_texis/searching.texi:1312 original_texis/searching.texi:1626
#, no-wrap
msgid "Saving Match Data"
msgstr ""

#. type: menuentry
#: original_texis/searching.texi:1312
msgid "Saving and restoring the match data."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1315
#, no-wrap
msgid "Replacing the Text that Matched"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1316
#, no-wrap
msgid "replace matched text"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1320
msgid ""
"This function replaces all or part of the text matched by the last search.  "
"It works by means of the match data."
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1321
#, no-wrap
msgid "case in replacements"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1322
#, no-wrap
msgid "replace-match replacement &optional fixedcase literal string subexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1324
msgid "This function performs a replacement operation on a buffer or string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1331
msgid ""
"If you did the last search in a buffer, you should omit the @var{string} "
"argument or specify @code{nil} for it, and make sure that the current buffer "
"is the one in which you performed the last search.  Then this function edits "
"the buffer, replacing the matched text with @var{replacement}.  It leaves "
"point at the end of the replacement text."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1335
msgid ""
"If you performed the last search on a string, pass the same string as "
"@var{string}.  Then this function returns a new string, in which the matched "
"text is replaced by @var{replacement}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1345
msgid ""
"If @var{fixedcase} is non-@code{nil}, then @code{replace-match} uses the "
"replacement text without case conversion; otherwise, it converts the "
"replacement text depending upon the capitalization of the text to be "
"replaced.  If the original text is all upper case, this converts the "
"replacement text to upper case.  If all words of the original text are "
"capitalized, this capitalizes all the words of the replacement text.  If all "
"the words are one-letter and they are all upper case, they are treated as "
"capitalized words rather than all-upper-case words."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1351
msgid ""
"If @var{literal} is non-@code{nil}, then @var{replacement} is inserted "
"exactly as it is, the only alterations being case changes as needed.  If it "
"is @code{nil} (the default), then the character @samp{\\} is treated "
"specially.  If a @samp{\\} appears in @var{replacement}, then it must be "
"part of one of the following sequences:"
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:1353
#, no-wrap
msgid "\\&"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1354
#, no-wrap
msgid "@samp{&} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:1356
msgid "This stands for the entire text being replaced."
msgstr ""

#. type: item
#: original_texis/searching.texi:1357
#, no-wrap
msgid "@samp{\\@var{n}}, where @var{n} is a digit"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1358
#, no-wrap
msgid "@samp{\\@var{n}} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:1363
msgid ""
"This stands for the text that matched the @var{n}th subexpression in the "
"original regexp.  Subexpressions are those expressions grouped inside "
"@samp{\\(@dots{}\\)}.  If the @var{n}th subexpression never matched, an "
"empty string is substituted."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:1364
#, no-wrap
msgid "\\\\"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1365
#, no-wrap
msgid "@samp{\\} in replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:1367
msgid "This stands for a single @samp{\\} in the replacement text."
msgstr ""

#. type: samp{#1}
#: original_texis/searching.texi:1368
#, no-wrap
msgid "\\?"
msgstr ""

#. type: table
#: original_texis/searching.texi:1372
msgid ""
"This stands for itself (for compatibility with @code{replace-regexp} and "
"related commands; @pxref{Regexp Replace,,, emacs, The GNU Emacs Manual})."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1376
msgid "Any other character following @samp{\\} signals an error."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1380
msgid ""
"The substitutions performed by @samp{\\&} and @samp{\\@var{n}} occur after "
"case conversion, if any.  Therefore, the strings they substitute are never "
"case-converted."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1386
msgid ""
"If @var{subexp} is non-@code{nil}, that says to replace just subexpression "
"number @var{subexp} of the regexp that was matched, not the entire match.  "
"For example, after matching @samp{foo \\(ba*r\\)}, calling "
"@code{replace-match} with 1 as @var{subexp} means to replace just the text "
"that matched @samp{\\(ba*r\\)}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1388
#, no-wrap
msgid ""
"match-substitute-replacement replacement &optional fixedcase literal string "
"subexp"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1396
msgid ""
"This function returns the text that would be inserted into the buffer by "
"@code{replace-match}, but without modifying the buffer.  It is useful if you "
"want to present the user with actual replacement result, with constructs "
"like @samp{\\@var{n}} or @samp{\\&} substituted with matched groups.  "
"Arguments @var{replacement} and optional @var{fixedcase}, @var{literal}, "
"@var{string} and @var{subexp} have the same meaning as for "
"@code{replace-match}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1399
#, no-wrap
msgid "Simple Match Data Access"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1403
msgid ""
"This section explains how to use the match data to find out what was matched "
"by the last search or match operation, if it succeeded."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1409
msgid ""
"You can ask about the entire matching text, or about a particular "
"parenthetical subexpression of a regular expression.  The @var{count} "
"argument in the functions below specifies which.  If @var{count} is zero, "
"you are asking about the entire match.  If @var{count} is positive, it "
"specifies which subexpression you want."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1417
msgid ""
"Recall that the subexpressions of a regular expression are those expressions "
"grouped with escaped parentheses, @samp{\\(@dots{}\\)}.  The @var{count}th "
"subexpression is found by counting occurrences of @samp{\\(} from the "
"beginning of the whole regular expression.  The first subexpression is "
"numbered 1, the second 2, and so on.  Only regular expressions can have "
"subexpressions---after a simple string search, the only information "
"available is about the entire match."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1425
msgid ""
"Every successful search sets the match data.  Therefore, you should query "
"the match data immediately after searching, before calling any other "
"function that might perform another search.  Alternatively, you may save and "
"restore the match data (@pxref{Saving Match Data}) around the call to "
"functions that could perform another search.  Or use the functions that "
"explicitly do not modify the match data; e.g., @code{string-match-p}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1432
msgid ""
"A search which fails may or may not alter the match data.  In the current "
"implementation, it does not, but we may change it in the future.  Don't try "
"to rely on the value of the match data after a failing search."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1433
#, no-wrap
msgid "match-string count &optional in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1438
msgid ""
"This function returns, as a string, the text matched in the last search or "
"match operation.  It returns the entire text if @var{count} is zero, or just "
"the portion corresponding to the @var{count}th parenthetical subexpression, "
"if @var{count} is positive."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1446
msgid ""
"If the last such operation was done against a string with "
"@code{string-match}, then you should pass the same string as the argument "
"@var{in-string}.  After a buffer search or match, you should omit "
"@var{in-string} or pass @code{nil} for it; but you should make sure that the "
"current buffer when you call @code{match-string} is the one in which you did "
"the searching or matching.  Failure to follow this advice will lead to "
"incorrect results."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1450
msgid ""
"The value is @code{nil} if @var{count} is out of range, or for a "
"subexpression inside a @samp{\\|} alternative that wasn't used or a "
"repetition that repeated zero times."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1452
#, no-wrap
msgid "match-string-no-properties count &optional in-string"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1455
msgid ""
"This function is like @code{match-string} except that the result has no text "
"properties."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1457
#, no-wrap
msgid "match-beginning count"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1461
msgid ""
"If the last regular expression search found a match, this function returns "
"the position of the start of the matching text or of a subexpression of it."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1466
msgid ""
"If @var{count} is zero, then the value is the position of the start of the "
"entire match.  Otherwise, @var{count} specifies a subexpression in the "
"regular expression, and the value of the function is the starting position "
"of the match for that subexpression."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1469
msgid ""
"The value is @code{nil} for a subexpression inside a @samp{\\|} alternative "
"that wasn't used or a repetition that repeated zero times."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1471
#, no-wrap
msgid "match-end count"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1475
msgid ""
"This function is like @code{match-beginning} except that it returns the "
"position of the end of the match, rather than the position of the beginning."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1479
msgid ""
"Here is an example of using the match data, with a comment showing the "
"positions within the text:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1486
#, no-wrap
msgid ""
"(string-match \"\\\\(qu\\\\)\\\\(ick\\\\)\"\n"
"              \"The quick fox jumped quickly.\")\n"
"              ;0123456789\n"
"     @result{} 4\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1495
#, no-wrap
msgid ""
"(match-string 0 \"The quick fox jumped quickly.\")\n"
"     @result{} \"quick\"\n"
"(match-string 1 \"The quick fox jumped quickly.\")\n"
"     @result{} \"qu\"\n"
"(match-string 2 \"The quick fox jumped quickly.\")\n"
"     @result{} \"ick\"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1500
#, no-wrap
msgid ""
"(match-beginning 1)       ; @r{The beginning of the match}\n"
"     @result{} 4                 ;   @r{with @samp{qu} is at index 4.}\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1505
#, no-wrap
msgid ""
"(match-beginning 2)       ; @r{The beginning of the match}\n"
"     @result{} 6                 ;   @r{with @samp{ick} is at index 6.}\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1510
#, no-wrap
msgid ""
"(match-end 1)             ; @r{The end of the match}\n"
"     @result{} 6                 ;   @r{with @samp{qu} is at index 6.}\n"
"\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1513
#, no-wrap
msgid ""
"(match-end 2)             ; @r{The end of the match}\n"
"     @result{} 9                 ;   @r{with @samp{ick} is at index 9.}\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1521
msgid ""
"Here is another example.  Point is initially located at the beginning of the "
"line.  Searching moves point to between the space and the word @samp{in}.  "
"The beginning of the entire match is at the 9th character of the buffer "
"(@samp{T}), and the beginning of the match for the first subexpression is at "
"the 13th character (@samp{c})."
msgstr ""

#. type: group
#: original_texis/searching.texi:1529
#, no-wrap
msgid ""
"(list\n"
"  (re-search-forward \"The \\\\(cat \\\\)\")\n"
"  (match-beginning 0)\n"
"  (match-beginning 1))\n"
"    @result{} (17 9 13)\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1537
#, no-wrap
msgid ""
"---------- Buffer: foo ----------\n"
"I read \"The cat @point{}in the hat comes back\" twice.\n"
"        ^   ^\n"
"        9  13\n"
"---------- Buffer: foo ----------\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1543
msgid ""
"(In this case, the index returned is a buffer position; the first character "
"of the buffer counts as 1.)"
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1545
#, no-wrap
msgid "Accessing the Entire Match Data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1549
msgid ""
"The functions @code{match-data} and @code{set-match-data} read or write the "
"entire match data, all at once."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1550
#, no-wrap
msgid "match-data &optional integers reuse reseat"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1558
msgid ""
"This function returns a list of positions (markers or integers) that record "
"all the information on the text that the last search matched.  Element zero "
"is the position of the beginning of the match for the whole expression; "
"element one is the position of the end of the match for the expression.  The "
"next two elements are the positions of the beginning and end of the match "
"for the first subexpression, and so on.  In general, element"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1560
msgid "number 2@var{n}"
msgstr ""

#. type: tex
#: original_texis/searching.texi:1563
#, no-wrap
msgid "number {\\mathsurround=0pt $2n$}\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1566
msgid "corresponds to @code{(match-beginning @var{n})}; and element"
msgstr ""

#. type: ifnottex
#: original_texis/searching.texi:1568
msgid "number 2@var{n} + 1"
msgstr ""

#. type: tex
#: original_texis/searching.texi:1571
#, no-wrap
msgid "number {\\mathsurround=0pt $2n+1$}\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1573
msgid "corresponds to @code{(match-end @var{n})}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1581
msgid ""
"Normally all the elements are markers or @code{nil}, but if @var{integers} "
"is non-@code{nil}, that means to use integers instead of markers.  (In that "
"case, the buffer itself is appended as an additional element at the end of "
"the list, to facilitate complete restoration of the match data.)  If the "
"last match was done on a string with @code{string-match}, then integers are "
"always used, since markers can't point into a string."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1590
msgid ""
"If @var{reuse} is non-@code{nil}, it should be a list.  In that case, "
"@code{match-data} stores the match data in @var{reuse}.  That is, "
"@var{reuse} is destructively modified.  @var{reuse} does not need to have "
"the right length.  If it is not long enough to contain the match data, it is "
"extended.  If it is too long, the length of @var{reuse} stays the same, but "
"the elements that were not used are set to @code{nil}.  The purpose of this "
"feature is to reduce the need for garbage collection."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1593
msgid ""
"If @var{reseat} is non-@code{nil}, all markers on the @var{reuse} list are "
"reseated to point to nowhere."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1597
msgid ""
"As always, there must be no possibility of intervening searches between the "
"call to a search function and the call to @code{match-data} that is intended "
"to access the match data for that search."
msgstr ""

#. type: group
#: original_texis/searching.texi:1605
#, no-wrap
msgid ""
"(match-data)\n"
"     @result{}  (#<marker at 9 in foo>\n"
"          #<marker at 17 in foo>\n"
"          #<marker at 13 in foo>\n"
"          #<marker at 17 in foo>)\n"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1609
#, no-wrap
msgid "set-match-data match-list &optional reseat"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1614
msgid ""
"This function sets the match data from the elements of @var{match-list}, "
"which should be a list that was the value of a previous call to "
"@code{match-data}.  (More precisely, anything that has the same format will "
"work.)"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1617
msgid ""
"If @var{match-list} refers to a buffer that doesn't exist, you don't get an "
"error; that sets the match data in a meaningless but harmless way."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1620
msgid ""
"If @var{reseat} is non-@code{nil}, all markers on the @var{match-list} list "
"are reseated to point to nowhere."
msgstr ""

#. type: findex
#: original_texis/searching.texi:1622
#, no-wrap
msgid "store-match-data"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1624
msgid "@code{store-match-data} is a semi-obsolete alias for @code{set-match-data}."
msgstr ""

#. type: subsection
#: original_texis/searching.texi:1627
#, no-wrap
msgid "Saving and Restoring the Match Data"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1633
msgid ""
"When you call a function that may search, you may need to save and restore "
"the match data around that call, if you want to preserve the match data from "
"an earlier search for later use.  Here is an example that shows the problem "
"that arises if you fail to save the match data:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1641
#, no-wrap
msgid ""
"(re-search-forward \"The \\\\(cat \\\\)\")\n"
"     @result{} 48\n"
"(foo)                   ; @r{@code{foo} does more searching.}\n"
"(match-end 0)\n"
"     @result{} 61              ; @r{Unexpected result---not 48!}\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1645
msgid "You can save and restore the match data with @code{save-match-data}:"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1646
#, no-wrap
msgid "save-match-data body@dots{}"
msgstr ""

#. type: defmac
#: original_texis/searching.texi:1650
msgid ""
"This macro executes @var{body}, saving and restoring the match data around "
"it.  The return value is the value of the last form in @var{body}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1655
msgid ""
"You could use @code{set-match-data} together with @code{match-data} to "
"imitate the effect of the special form @code{save-match-data}.  Here is how:"
msgstr ""

#. type: group
#: original_texis/searching.texi:1662
#, no-wrap
msgid ""
"(let ((data (match-data)))\n"
"  (unwind-protect\n"
"      @dots{}   ; @r{Ok to change the original match data.}\n"
"    (set-match-data data)))\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1668
msgid ""
"Emacs automatically saves and restores the match data when it runs process "
"filter functions (@pxref{Filter Functions}) and process sentinels "
"(@pxref{Sentinels})."
msgstr ""

#. type: group
#: original_texis/searching.texi:1681
#, no-wrap
msgid ""
"(defun restore-match-data (data)\n"
"  \"Restore the match data DATA unless the buffer is missing.\"\n"
"  (catch 'foo\n"
"    (let ((d data))\n"
msgstr ""

#. type: smallexample
#: original_texis/searching.texi:1685
#, no-wrap
msgid ""
"      (while d\n"
"        (and (car d)\n"
"             (null (marker-buffer (car d)))\n"
msgstr ""

#. type: group
#: original_texis/searching.texi:1690
#, no-wrap
msgid ""
"             ;; @file{match-data} @r{buffer is deleted.}\n"
"             (throw 'foo nil))\n"
"        (setq d (cdr d)))\n"
"      (set-match-data data))))\n"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1696
#, no-wrap
msgid "replacement after search"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1697
#, no-wrap
msgid "searching and replacing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1702
msgid ""
"If you want to find all matches for a regexp in part of the buffer, and "
"replace them, the best way is to write an explicit loop using "
"@code{re-search-forward} and @code{replace-match}, like this:"
msgstr ""

#. type: example
#: original_texis/searching.texi:1706
#, no-wrap
msgid ""
"(while (re-search-forward \"foo[ \\t]+bar\" nil t)\n"
"  (replace-match \"foobar\"))\n"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1711
msgid ""
"@xref{Replacing Match,, Replacing the Text that Matched}, for a description "
"of @code{replace-match}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1715
msgid ""
"However, replacing matches in a string is more complex, especially if you "
"want to do it efficiently.  So Emacs provides a function to do this."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1716
#, no-wrap
msgid ""
"replace-regexp-in-string regexp rep string &optional fixedcase literal "
"subexp start"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1722
msgid ""
"This function copies @var{string} and searches it for matches for "
"@var{regexp}, and replaces them with @var{rep}.  It returns the modified "
"copy.  If @var{start} is non-@code{nil}, the search for matches starts at "
"that index in @var{string}, so matches starting before that index are not "
"changed."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1726
msgid ""
"This function uses @code{replace-match} to do the replacement, and it passes "
"the optional arguments @var{fixedcase}, @var{literal} and @var{subexp} along "
"to @code{replace-match}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1733
msgid ""
"Instead of a string, @var{rep} can be a function.  In that case, "
"@code{replace-regexp-in-string} calls @var{rep} for each match, passing the "
"text of the match as its sole argument.  It collects the value @var{rep} "
"returns and passes that to @code{replace-match} as the replacement string.  "
"The match data at this point are the result of matching @var{regexp} against "
"a substring of @var{string}."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1737
msgid ""
"If you want to write a command along the lines of @code{query-replace}, you "
"can use @code{perform-replace} to do the work."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1738
#, no-wrap
msgid ""
"perform-replace from-string replacements query-flag regexp-flag "
"delimited-flag &optional repeat-count map start end"
msgstr ""

#. type: defun
#: original_texis/searching.texi:1745
msgid ""
"This function is the guts of @code{query-replace} and related commands.  It "
"searches for occurrences of @var{from-string} in the text between positions "
"@var{start} and @var{end} and replaces some or all of them.  If @var{start} "
"is @code{nil} (or omitted), point is used instead, and the end of the "
"buffer's accessible portion is used for @var{end}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1748
msgid ""
"If @var{query-flag} is @code{nil}, it replaces all occurrences; otherwise, "
"it asks the user what to do about each one."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1753
msgid ""
"If @var{regexp-flag} is non-@code{nil}, then @var{from-string} is considered "
"a regular expression; otherwise, it must match literally.  If "
"@var{delimited-flag} is non-@code{nil}, then only replacements surrounded by "
"word boundaries are considered."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1757
msgid ""
"The argument @var{replacements} specifies what to replace occurrences with.  "
"If it is a string, that string is used.  It can also be a list of strings, "
"to be used in cyclic order."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1762
msgid ""
"If @var{replacements} is a cons cell, @w{@code{(@var{function} "
". @var{data})}}, this means to call @var{function} after each match to get "
"the replacement text.  This function is called with two arguments: "
"@var{data}, and the number of replacements already made."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1766
msgid ""
"If @var{repeat-count} is non-@code{nil}, it should be an integer.  Then it "
"specifies how many times to use each of the strings in the "
"@var{replacements} list before advancing cyclically to the next one."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1770
msgid ""
"If @var{from-string} contains upper-case letters, then "
"@code{perform-replace} binds @code{case-fold-search} to @code{nil}, and it "
"uses the @var{replacements} without altering their case."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1775
msgid ""
"Normally, the keymap @code{query-replace-map} defines the possible user "
"responses for queries.  The argument @var{map}, if non-@code{nil}, specifies "
"a keymap to use instead of @code{query-replace-map}."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1782
msgid ""
"This function uses one of two functions to search for the next occurrence of "
"@var{from-string}.  These functions are specified by the values of two "
"variables: @code{replace-re-search-function} and "
"@code{replace-search-function}.  The former is called when the argument "
"@var{regexp-flag} is non-@code{nil}, the latter when it is @code{nil}."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1784
#, no-wrap
msgid "query-replace-map"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1789
msgid ""
"This variable holds a special keymap that defines the valid user responses "
"for @code{perform-replace} and the commands that use it, as well as "
"@code{y-or-n-p} and @code{map-y-or-n-p}.  This map is unusual in two ways:"
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1794
msgid ""
"The key bindings are not commands, just symbols that are meaningful to the "
"functions that use this map."
msgstr ""

#. type: itemize
#: original_texis/searching.texi:1800
msgid ""
"Prefix keys are not supported; each key binding must be for a single-event "
"key sequence.  This is because the functions don't use "
"@code{read-key-sequence} to get the input; instead, they read a single event "
"and look it up ``by hand''."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1806
msgid ""
"Here are the meaningful bindings for @code{query-replace-map}.  Several of "
"them are meaningful only for @code{query-replace} and friends."
msgstr ""

#. type: item
#: original_texis/searching.texi:1808
#, no-wrap
msgid "act"
msgstr ""

#. type: table
#: original_texis/searching.texi:1810
msgid "Do take the action being considered---in other words, ``yes''."
msgstr ""

#. type: item
#: original_texis/searching.texi:1811
#, no-wrap
msgid "skip"
msgstr ""

#. type: table
#: original_texis/searching.texi:1813
msgid "Do not take action for this question---in other words, ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:1814
#, no-wrap
msgid "exit"
msgstr ""

#. type: table
#: original_texis/searching.texi:1817
msgid ""
"Answer this question ``no'', and give up on the entire series of questions, "
"assuming that the answers will be ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:1818
#, no-wrap
msgid "exit-prefix"
msgstr ""

#. type: table
#: original_texis/searching.texi:1821
msgid ""
"Like @code{exit}, but add the key that was pressed to "
"@code{unread-command-events} (@pxref{Event Input Misc})."
msgstr ""

#. type: item
#: original_texis/searching.texi:1822
#, no-wrap
msgid "act-and-exit"
msgstr ""

#. type: table
#: original_texis/searching.texi:1825
msgid ""
"Answer this question ``yes'', and give up on the entire series of questions, "
"assuming that subsequent answers will be ``no''."
msgstr ""

#. type: item
#: original_texis/searching.texi:1826
#, no-wrap
msgid "act-and-show"
msgstr ""

#. type: table
#: original_texis/searching.texi:1829
msgid ""
"Answer this question ``yes'', but show the results---don't advance yet to "
"the next question."
msgstr ""

#. type: item
#: original_texis/searching.texi:1830
#, no-wrap
msgid "automatic"
msgstr ""

#. type: table
#: original_texis/searching.texi:1833
msgid ""
"Answer this question and all subsequent questions in the series with "
"``yes'', without further user interaction."
msgstr ""

#. type: item
#: original_texis/searching.texi:1834
#, no-wrap
msgid "backup"
msgstr ""

#. type: table
#: original_texis/searching.texi:1836
msgid "Move back to the previous place that a question was asked about."
msgstr ""

#. type: item
#: original_texis/searching.texi:1837
#, no-wrap
msgid "edit"
msgstr ""

#. type: table
#: original_texis/searching.texi:1840
msgid ""
"Enter a recursive edit to deal with this question---instead of any other "
"action that would normally be taken."
msgstr ""

#. type: item
#: original_texis/searching.texi:1841
#, no-wrap
msgid "edit-replacement"
msgstr ""

#. type: table
#: original_texis/searching.texi:1843
msgid "Edit the replacement for this question in the minibuffer."
msgstr ""

#. type: item
#: original_texis/searching.texi:1844
#, no-wrap
msgid "delete-and-edit"
msgstr ""

#. type: table
#: original_texis/searching.texi:1847
msgid "Delete the text being considered, then enter a recursive edit to replace it."
msgstr ""

#. type: item
#: original_texis/searching.texi:1848
#, no-wrap
msgid "recenter"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1849
#, no-wrap
msgid "scroll-up"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1850
#, no-wrap
msgid "scroll-down"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1851
#, no-wrap
msgid "scroll-other-window"
msgstr ""

#. type: itemx
#: original_texis/searching.texi:1852
#, no-wrap
msgid "scroll-other-window-down"
msgstr ""

#. type: table
#: original_texis/searching.texi:1856
msgid ""
"Perform the specified window scroll operation, then ask the same question "
"again.  Only @code{y-or-n-p} and related functions use this answer."
msgstr ""

#. type: item
#: original_texis/searching.texi:1857
#, no-wrap
msgid "quit"
msgstr ""

#. type: table
#: original_texis/searching.texi:1860
msgid ""
"Perform a quit right away.  Only @code{y-or-n-p} and related functions use "
"this answer."
msgstr ""

#. type: item
#: original_texis/searching.texi:1861
#, no-wrap
msgid "help"
msgstr ""

#. type: table
#: original_texis/searching.texi:1863
msgid "Display some help, then ask again."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1865
#, no-wrap
msgid "multi-query-replace-map"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1869
msgid ""
"This variable holds a keymap that extends @code{query-replace-map} by "
"providing additional keybindings that are useful in multi-buffer "
"replacements.  The additional bindings are:"
msgstr ""

#. type: item
#: original_texis/searching.texi:1871
#, no-wrap
msgid "automatic-all"
msgstr ""

#. type: table
#: original_texis/searching.texi:1874
msgid ""
"Answer this question and all subsequent questions in the series with "
"``yes'', without further user interaction, for all remaining buffers."
msgstr ""

#. type: item
#: original_texis/searching.texi:1875
#, no-wrap
msgid "exit-current"
msgstr ""

#. type: table
#: original_texis/searching.texi:1879
msgid ""
"Answer this question ``no'', and give up on the entire series of questions "
"for the current buffer.  Continue to the next buffer in the sequence."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1882
#, no-wrap
msgid "replace-search-function"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1888
msgid ""
"This variable specifies a function that @code{perform-replace} calls to "
"search for the next string to replace.  Its default value is "
"@code{search-forward}.  Any other value should name a function of 3 "
"arguments: the first 3 arguments of @code{search-forward} (@pxref{String "
"Search})."
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1890
#, no-wrap
msgid "replace-re-search-function"
msgstr ""

#. type: defvar
#: original_texis/searching.texi:1896
msgid ""
"This variable specifies a function that @code{perform-replace} calls to "
"search for the next regexp to replace.  Its default value is "
"@code{re-search-forward}.  Any other value should name a function of 3 "
"arguments: the first 3 arguments of @code{re-search-forward} (@pxref{Regexp "
"Search})."
msgstr ""

#. type: section
#: original_texis/searching.texi:1899
#, no-wrap
msgid "Standard Regular Expressions Used in Editing"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1900
#, no-wrap
msgid "regexps used standardly in editing"
msgstr ""

#. type: cindex
#: original_texis/searching.texi:1901
#, no-wrap
msgid "standard regexps used in editing"
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1905
msgid ""
"This section describes some variables that hold regular expressions used for "
"certain purposes in editing:"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1906
#, no-wrap
msgid "page-delimiter"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1911
msgid ""
"This is the regular expression describing line-beginnings that separate "
"pages.  The default value is @code{\"^\\014\"} (i.e., @code{\"^^L\"} or "
"@code{\"^\\C-l\"}); this matches a line that starts with a formfeed "
"character."
msgstr ""

#. type: Plain text
#: original_texis/searching.texi:1921
msgid ""
"The following two regular expressions should @emph{not} assume the match "
"always starts at the beginning of a line; they should not use @samp{^} to "
"anchor the match.  Most often, the paragraph commands do check for a match "
"only at the beginning of a line, which means that @samp{^} would be "
"superfluous.  When there is a nonzero left margin, they accept matches that "
"start after the left margin.  In that case, a @samp{^} would be incorrect.  "
"However, a @samp{^} is harmless in modes where a left margin is never used."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1922
#, no-wrap
msgid "paragraph-separate"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1928
msgid ""
"This is the regular expression for recognizing the beginning of a line that "
"separates paragraphs.  (If you change this, you may have to change "
"@code{paragraph-start} also.)  The default value is @w{@code{\"[@ "
"\\t\\f]*$\"}}, which matches a line that consists entirely of spaces, tabs, "
"and form feeds (after its left margin)."
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1930
#, no-wrap
msgid "paragraph-start"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1935
msgid ""
"This is the regular expression for recognizing the beginning of a line that "
"starts @emph{or} separates paragraphs.  The default value is "
"@w{@code{\"\\f\\\\|[ \\t]*$\"}}, which matches a line containing only "
"whitespace or starting with a form feed (after its left margin)."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1937 original_texis/searching.texi:1948
#, no-wrap
msgid "sentence-end"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1941
msgid ""
"If non-@code{nil}, the value should be a regular expression describing the "
"end of a sentence, including the whitespace following the sentence.  (All "
"paragraph boundaries also end sentences, regardless.)"
msgstr ""

#. type: defopt
#: original_texis/searching.texi:1946
msgid ""
"If the value is @code{nil}, as it is by default, then the function "
"@code{sentence-end} constructs the regexp.  That is why you should always "
"call the function @code{sentence-end} to obtain the regexp to be used to "
"recognize the end of a sentence."
msgstr ""

#. type: defun
#: original_texis/searching.texi:1955
msgid ""
"This function returns the value of the variable @code{sentence-end}, if "
"non-@code{nil}.  Otherwise it returns a default value based on the values of "
"the variables @code{sentence-end-double-space} (@pxref{Definition of "
"sentence-end-double-space}), @code{sentence-end-without-period}, and "
"@code{sentence-end-without-space}."
msgstr ""
